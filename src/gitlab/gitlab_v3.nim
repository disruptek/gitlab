
import
  json, options, hashes, uri, strutils, rest, os, uri, httpcore, rest

## auto-generated via openapi macro
## title: Gitlab
## version: v3
## termsOfService: (not provided)
## license: (not provided)
## 
## The platform for modern developers
## GitLab unifies issues, code review, CI and CD into a single UI
## 
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_758573 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_758573](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_758573): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

type
  Call_PutV3ApplicationSettings_758995 = ref object of OpenApiRestCall_758573
proc url_PutV3ApplicationSettings_758997(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PutV3ApplicationSettings_758996(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modify application settings
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   gravatar_enabled: JBool
  ##                   : Flag indicating if the Gravatar service is enabled
  ##   housekeeping_full_repack_period: JInt (required)
  ##                                  : Number of Git pushes after which a full 'git repack' is run.
  ##   session_expire_delay: JInt
  ##                       : Session duration in minutes. GitLab restart is required to apply changes.
  ##   metrics_port: JInt (required)
  ##               : The UDP port to use for connecting to InfluxDB
  ##   version_check_enabled: JBool
  ##                        : Let GitLab inform you when an update is available.
  ##   disabled_oauth_sign_in_sources: JArray
  ##                                 : Disable certain OAuth sign-in sources
  ##   shared_runners_text: JString (required)
  ##                      : Shared runners text 
  ##   metrics_sample_interval: JInt (required)
  ##                          : The sampling interval in seconds
  ##   require_two_factor_authentication: JBool
  ##                                    : Require all users to setup Two-factor authentication
  ##   max_artifacts_size: JInt
  ##                     : Set the maximum file size each build's artifacts can have
  ##   recaptcha_enabled: JBool
  ##                    : Helps prevent bots from creating accounts
  ##   housekeeping_gc_period: JInt (required)
  ##                         : Number of Git pushes after which 'git gc' is run.
  ##   shared_runners_enabled: JBool
  ##                         : Enable shared runners for new projects
  ##   enabled_git_access_protocol: JString
  ##                              : Allow only the selected protocols to be used for Git access.
  ##   user_default_external: JBool
  ##                        : Newly registered users will by default be external
  ##   domain_whitelist: JString
  ##                   : ONLY users with e-mail addresses that match these domain(s) will be able to sign-up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com
  ##   metrics_host: JString (required)
  ##               : The InfluxDB host
  ##   container_registry_token_expire_delay: JInt
  ##                                        : Authorization token duration (minutes)
  ##   recaptcha_site_key: JString (required)
  ##                     : Generate site key at http://www.google.com/recaptcha
  ##   plantuml_url: JString (required)
  ##               : The PlantUML server URL
  ##   sidekiq_throttling_queus: JArray (required)
  ##                           : Choose which queues you wish to throttle
  ##   repository_storage: JString
  ##                     : Storage paths for new projects
  ##   html_emails_enabled: JBool
  ##                      : By default GitLab sends emails in HTML and plain text formats so mail clients can choose what format to use. Disable this option if you only want to send emails in plain text format.
  ##   koding_url: JString (required)
  ##             : The Koding team URL
  ##   domain_blacklist: JString (required)
  ##                   : Users with e-mail addresses that match these domain(s) will NOT be able to sign-up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com
  ##   home_page_url: JString
  ##                : We will redirect non-logged in users to this page
  ##   default_group_visibility: JInt
  ##                           : The default group visibility
  ##   send_user_confirmation_email: JBool
  ##                               : Send confirmation email on sign-up
  ##   domain_blacklist_enabled: JBool
  ##                           : Enable domain blacklist for sign ups
  ##   metrics_method_call_threshold: JInt (required)
  ##                                : A method call is only tracked when it takes longer to complete than the given amount of milliseconds.
  ##   import_sources: JArray
  ##                 : Enabled sources for code import during project creation. OmniAuth must be configured for GitHub, Bitbucket, and GitLab.com
  ##   metrics_timeout: JInt (required)
  ##                  : The amount of seconds after which an InfluxDB connection will time out
  ##   restricted_visibility_levels: JArray
  ##                               : Selected levels cannot be used by non-admin users for projects or snippets. If the public level is restricted, user profiles are only visible to logged in users.
  ##   default_projects_limit: JInt
  ##                         : The maximum number of personal projects
  ##   akismet_api_key: JString (required)
  ##                  : Generate API key at http://www.akismet.com
  ##   sentry_dsn: JString (required)
  ##             : Sentry Data Source Name
  ##   akismet_enabled: JBool
  ##                  : Helps prevent bots from creating issues
  ##   signin_enabled: JBool
  ##                 : Flag indicating if sign in is enabled
  ##   housekeeping_incremental_repack_period: JInt (required)
  ##                                         : Number of Git pushes after which an incremental 'git repack' is run.
  ##   housekeeping_bitmaps_enabled: JBool (required)
  ##                               : Creating pack file bitmaps makes housekeeping take a little longer but bitmaps should accelerate 'git clone' performance.
  ##   default_project_visibility: JInt
  ##                             : The default project visibility
  ##   recaptcha_private_key: JString (required)
  ##                        : Generate private key at http://www.google.com/recaptcha
  ##   help_page_text: JString
  ##                 : Custom text displayed on the help page
  ##   after_sign_up_text: JString
  ##                     : Text shown after sign up
  ##   plantuml_enabled: JBool
  ##                   : Enable PlantUML
  ##   sidekiq_throttling_enabled: JBool
  ##                             : Enable Sidekiq Job Throttling
  ##   metrics_pool_size: JInt (required)
  ##                    : The amount of InfluxDB connections to open
  ##   sentry_enabled: JBool
  ##                 : Sentry is an error reporting and logging tool which is currently not shipped with GitLab, get it here: https://getsentry.com
  ##   after_sign_out_path: JString
  ##                      : We will redirect users to this page after they sign out
  ##   metrics_packet_size: JInt (required)
  ##                      : The amount of points to store in a single UDP packet
  ##   koding_enabled: JBool
  ##                 : Enable Koding
  ##   signup_enabled: JBool
  ##                 : Flag indicating if sign up is enabled
  ##   admin_notification_email: JString
  ##                           : Abuse reports will be sent to this address if it is set. Abuse reports are always available in the admin area.
  ##   two_factor_grace_period: JInt (required)
  ##                          : Amount of time (in hours) that users are allowed to skip forced configuration of two-factor authentication
  ##   metrics_enabled: JBool
  ##                  : Enable the InfluxDB metrics
  ##   email_author_in_body: JBool
  ##                       : Some email servers do not support overriding the email sender name. Enable this option to include the name of the author of the issue, merge request or comment in the email body instead.
  ##   repository_checks_enabled: JBool
  ##                            : GitLab will periodically run 'git fsck' in all project and wiki repositories to look for silent disk corruption issues.
  ##   user_oauth_applications: JBool
  ##                          : Allow users to register any application to use GitLab as an OAuth provider
  ##   max_attachment_size: JInt
  ##                      : Maximum attachment size in MB
  ##   sidekiq_throttling_factor: JFloat (required)
  ##                            : The factor by which the queues should be throttled. A value between 0.0 and 1.0, exclusive.
  ##   default_branch_protection: JInt
  ##                            : Determine if developers can push to master
  ##   sign_in_text: JString
  ##               : The sign in text of the GitLab application
  ##   default_snippet_visibility: JInt
  ##                             : The default snippet visibility
  ##   housekeeping_enabled: JBool
  ##                       : Enable automatic repository housekeeping (git repack, git gc)
  section = newJObject()
  var valid_759072 = formData.getOrDefault("gravatar_enabled")
  valid_759072 = validateParameter(valid_759072, JBool, required = false, default = nil)
  if valid_759072 != nil:
    section.add "gravatar_enabled", valid_759072
  assert formData != nil, "formData argument is necessary due to required `housekeeping_full_repack_period` field"
  var valid_759073 = formData.getOrDefault("housekeeping_full_repack_period")
  valid_759073 = validateParameter(valid_759073, JInt, required = true, default = nil)
  if valid_759073 != nil:
    section.add "housekeeping_full_repack_period", valid_759073
  var valid_759074 = formData.getOrDefault("session_expire_delay")
  valid_759074 = validateParameter(valid_759074, JInt, required = false, default = nil)
  if valid_759074 != nil:
    section.add "session_expire_delay", valid_759074
  var valid_759075 = formData.getOrDefault("metrics_port")
  valid_759075 = validateParameter(valid_759075, JInt, required = true, default = nil)
  if valid_759075 != nil:
    section.add "metrics_port", valid_759075
  var valid_759076 = formData.getOrDefault("version_check_enabled")
  valid_759076 = validateParameter(valid_759076, JBool, required = false, default = nil)
  if valid_759076 != nil:
    section.add "version_check_enabled", valid_759076
  var valid_759077 = formData.getOrDefault("disabled_oauth_sign_in_sources")
  valid_759077 = validateParameter(valid_759077, JArray, required = false,
                                 default = nil)
  if valid_759077 != nil:
    section.add "disabled_oauth_sign_in_sources", valid_759077
  var valid_759078 = formData.getOrDefault("shared_runners_text")
  valid_759078 = validateParameter(valid_759078, JString, required = true,
                                 default = nil)
  if valid_759078 != nil:
    section.add "shared_runners_text", valid_759078
  var valid_759079 = formData.getOrDefault("metrics_sample_interval")
  valid_759079 = validateParameter(valid_759079, JInt, required = true, default = nil)
  if valid_759079 != nil:
    section.add "metrics_sample_interval", valid_759079
  var valid_759080 = formData.getOrDefault("require_two_factor_authentication")
  valid_759080 = validateParameter(valid_759080, JBool, required = false, default = nil)
  if valid_759080 != nil:
    section.add "require_two_factor_authentication", valid_759080
  var valid_759081 = formData.getOrDefault("max_artifacts_size")
  valid_759081 = validateParameter(valid_759081, JInt, required = false, default = nil)
  if valid_759081 != nil:
    section.add "max_artifacts_size", valid_759081
  var valid_759082 = formData.getOrDefault("recaptcha_enabled")
  valid_759082 = validateParameter(valid_759082, JBool, required = false, default = nil)
  if valid_759082 != nil:
    section.add "recaptcha_enabled", valid_759082
  var valid_759083 = formData.getOrDefault("housekeeping_gc_period")
  valid_759083 = validateParameter(valid_759083, JInt, required = true, default = nil)
  if valid_759083 != nil:
    section.add "housekeeping_gc_period", valid_759083
  var valid_759084 = formData.getOrDefault("shared_runners_enabled")
  valid_759084 = validateParameter(valid_759084, JBool, required = false, default = nil)
  if valid_759084 != nil:
    section.add "shared_runners_enabled", valid_759084
  var valid_759098 = formData.getOrDefault("enabled_git_access_protocol")
  valid_759098 = validateParameter(valid_759098, JString, required = false,
                                 default = newJString("ssh"))
  if valid_759098 != nil:
    section.add "enabled_git_access_protocol", valid_759098
  var valid_759099 = formData.getOrDefault("user_default_external")
  valid_759099 = validateParameter(valid_759099, JBool, required = false, default = nil)
  if valid_759099 != nil:
    section.add "user_default_external", valid_759099
  var valid_759100 = formData.getOrDefault("domain_whitelist")
  valid_759100 = validateParameter(valid_759100, JString, required = false,
                                 default = nil)
  if valid_759100 != nil:
    section.add "domain_whitelist", valid_759100
  var valid_759101 = formData.getOrDefault("metrics_host")
  valid_759101 = validateParameter(valid_759101, JString, required = true,
                                 default = nil)
  if valid_759101 != nil:
    section.add "metrics_host", valid_759101
  var valid_759102 = formData.getOrDefault("container_registry_token_expire_delay")
  valid_759102 = validateParameter(valid_759102, JInt, required = false, default = nil)
  if valid_759102 != nil:
    section.add "container_registry_token_expire_delay", valid_759102
  var valid_759103 = formData.getOrDefault("recaptcha_site_key")
  valid_759103 = validateParameter(valid_759103, JString, required = true,
                                 default = nil)
  if valid_759103 != nil:
    section.add "recaptcha_site_key", valid_759103
  var valid_759104 = formData.getOrDefault("plantuml_url")
  valid_759104 = validateParameter(valid_759104, JString, required = true,
                                 default = nil)
  if valid_759104 != nil:
    section.add "plantuml_url", valid_759104
  var valid_759105 = formData.getOrDefault("sidekiq_throttling_queus")
  valid_759105 = validateParameter(valid_759105, JArray, required = true, default = nil)
  if valid_759105 != nil:
    section.add "sidekiq_throttling_queus", valid_759105
  var valid_759106 = formData.getOrDefault("repository_storage")
  valid_759106 = validateParameter(valid_759106, JString, required = false,
                                 default = nil)
  if valid_759106 != nil:
    section.add "repository_storage", valid_759106
  var valid_759107 = formData.getOrDefault("html_emails_enabled")
  valid_759107 = validateParameter(valid_759107, JBool, required = false, default = nil)
  if valid_759107 != nil:
    section.add "html_emails_enabled", valid_759107
  var valid_759108 = formData.getOrDefault("koding_url")
  valid_759108 = validateParameter(valid_759108, JString, required = true,
                                 default = nil)
  if valid_759108 != nil:
    section.add "koding_url", valid_759108
  var valid_759109 = formData.getOrDefault("domain_blacklist")
  valid_759109 = validateParameter(valid_759109, JString, required = true,
                                 default = nil)
  if valid_759109 != nil:
    section.add "domain_blacklist", valid_759109
  var valid_759110 = formData.getOrDefault("home_page_url")
  valid_759110 = validateParameter(valid_759110, JString, required = false,
                                 default = nil)
  if valid_759110 != nil:
    section.add "home_page_url", valid_759110
  var valid_759111 = formData.getOrDefault("default_group_visibility")
  valid_759111 = validateParameter(valid_759111, JInt, required = false, default = nil)
  if valid_759111 != nil:
    section.add "default_group_visibility", valid_759111
  var valid_759112 = formData.getOrDefault("send_user_confirmation_email")
  valid_759112 = validateParameter(valid_759112, JBool, required = false, default = nil)
  if valid_759112 != nil:
    section.add "send_user_confirmation_email", valid_759112
  var valid_759113 = formData.getOrDefault("domain_blacklist_enabled")
  valid_759113 = validateParameter(valid_759113, JBool, required = false, default = nil)
  if valid_759113 != nil:
    section.add "domain_blacklist_enabled", valid_759113
  var valid_759114 = formData.getOrDefault("metrics_method_call_threshold")
  valid_759114 = validateParameter(valid_759114, JInt, required = true, default = nil)
  if valid_759114 != nil:
    section.add "metrics_method_call_threshold", valid_759114
  var valid_759115 = formData.getOrDefault("import_sources")
  valid_759115 = validateParameter(valid_759115, JArray, required = false,
                                 default = nil)
  if valid_759115 != nil:
    section.add "import_sources", valid_759115
  var valid_759116 = formData.getOrDefault("metrics_timeout")
  valid_759116 = validateParameter(valid_759116, JInt, required = true, default = nil)
  if valid_759116 != nil:
    section.add "metrics_timeout", valid_759116
  var valid_759117 = formData.getOrDefault("restricted_visibility_levels")
  valid_759117 = validateParameter(valid_759117, JArray, required = false,
                                 default = nil)
  if valid_759117 != nil:
    section.add "restricted_visibility_levels", valid_759117
  var valid_759118 = formData.getOrDefault("default_projects_limit")
  valid_759118 = validateParameter(valid_759118, JInt, required = false, default = nil)
  if valid_759118 != nil:
    section.add "default_projects_limit", valid_759118
  var valid_759119 = formData.getOrDefault("akismet_api_key")
  valid_759119 = validateParameter(valid_759119, JString, required = true,
                                 default = nil)
  if valid_759119 != nil:
    section.add "akismet_api_key", valid_759119
  var valid_759120 = formData.getOrDefault("sentry_dsn")
  valid_759120 = validateParameter(valid_759120, JString, required = true,
                                 default = nil)
  if valid_759120 != nil:
    section.add "sentry_dsn", valid_759120
  var valid_759121 = formData.getOrDefault("akismet_enabled")
  valid_759121 = validateParameter(valid_759121, JBool, required = false, default = nil)
  if valid_759121 != nil:
    section.add "akismet_enabled", valid_759121
  var valid_759122 = formData.getOrDefault("signin_enabled")
  valid_759122 = validateParameter(valid_759122, JBool, required = false, default = nil)
  if valid_759122 != nil:
    section.add "signin_enabled", valid_759122
  var valid_759123 = formData.getOrDefault("housekeeping_incremental_repack_period")
  valid_759123 = validateParameter(valid_759123, JInt, required = true, default = nil)
  if valid_759123 != nil:
    section.add "housekeeping_incremental_repack_period", valid_759123
  var valid_759124 = formData.getOrDefault("housekeeping_bitmaps_enabled")
  valid_759124 = validateParameter(valid_759124, JBool, required = true, default = nil)
  if valid_759124 != nil:
    section.add "housekeeping_bitmaps_enabled", valid_759124
  var valid_759125 = formData.getOrDefault("default_project_visibility")
  valid_759125 = validateParameter(valid_759125, JInt, required = false, default = nil)
  if valid_759125 != nil:
    section.add "default_project_visibility", valid_759125
  var valid_759126 = formData.getOrDefault("recaptcha_private_key")
  valid_759126 = validateParameter(valid_759126, JString, required = true,
                                 default = nil)
  if valid_759126 != nil:
    section.add "recaptcha_private_key", valid_759126
  var valid_759127 = formData.getOrDefault("help_page_text")
  valid_759127 = validateParameter(valid_759127, JString, required = false,
                                 default = nil)
  if valid_759127 != nil:
    section.add "help_page_text", valid_759127
  var valid_759128 = formData.getOrDefault("after_sign_up_text")
  valid_759128 = validateParameter(valid_759128, JString, required = false,
                                 default = nil)
  if valid_759128 != nil:
    section.add "after_sign_up_text", valid_759128
  var valid_759129 = formData.getOrDefault("plantuml_enabled")
  valid_759129 = validateParameter(valid_759129, JBool, required = false, default = nil)
  if valid_759129 != nil:
    section.add "plantuml_enabled", valid_759129
  var valid_759130 = formData.getOrDefault("sidekiq_throttling_enabled")
  valid_759130 = validateParameter(valid_759130, JBool, required = false, default = nil)
  if valid_759130 != nil:
    section.add "sidekiq_throttling_enabled", valid_759130
  var valid_759131 = formData.getOrDefault("metrics_pool_size")
  valid_759131 = validateParameter(valid_759131, JInt, required = true, default = nil)
  if valid_759131 != nil:
    section.add "metrics_pool_size", valid_759131
  var valid_759132 = formData.getOrDefault("sentry_enabled")
  valid_759132 = validateParameter(valid_759132, JBool, required = false, default = nil)
  if valid_759132 != nil:
    section.add "sentry_enabled", valid_759132
  var valid_759133 = formData.getOrDefault("after_sign_out_path")
  valid_759133 = validateParameter(valid_759133, JString, required = false,
                                 default = nil)
  if valid_759133 != nil:
    section.add "after_sign_out_path", valid_759133
  var valid_759134 = formData.getOrDefault("metrics_packet_size")
  valid_759134 = validateParameter(valid_759134, JInt, required = true, default = nil)
  if valid_759134 != nil:
    section.add "metrics_packet_size", valid_759134
  var valid_759135 = formData.getOrDefault("koding_enabled")
  valid_759135 = validateParameter(valid_759135, JBool, required = false, default = nil)
  if valid_759135 != nil:
    section.add "koding_enabled", valid_759135
  var valid_759136 = formData.getOrDefault("signup_enabled")
  valid_759136 = validateParameter(valid_759136, JBool, required = false, default = nil)
  if valid_759136 != nil:
    section.add "signup_enabled", valid_759136
  var valid_759137 = formData.getOrDefault("admin_notification_email")
  valid_759137 = validateParameter(valid_759137, JString, required = false,
                                 default = nil)
  if valid_759137 != nil:
    section.add "admin_notification_email", valid_759137
  var valid_759138 = formData.getOrDefault("two_factor_grace_period")
  valid_759138 = validateParameter(valid_759138, JInt, required = true, default = nil)
  if valid_759138 != nil:
    section.add "two_factor_grace_period", valid_759138
  var valid_759139 = formData.getOrDefault("metrics_enabled")
  valid_759139 = validateParameter(valid_759139, JBool, required = false, default = nil)
  if valid_759139 != nil:
    section.add "metrics_enabled", valid_759139
  var valid_759140 = formData.getOrDefault("email_author_in_body")
  valid_759140 = validateParameter(valid_759140, JBool, required = false, default = nil)
  if valid_759140 != nil:
    section.add "email_author_in_body", valid_759140
  var valid_759141 = formData.getOrDefault("repository_checks_enabled")
  valid_759141 = validateParameter(valid_759141, JBool, required = false, default = nil)
  if valid_759141 != nil:
    section.add "repository_checks_enabled", valid_759141
  var valid_759142 = formData.getOrDefault("user_oauth_applications")
  valid_759142 = validateParameter(valid_759142, JBool, required = false, default = nil)
  if valid_759142 != nil:
    section.add "user_oauth_applications", valid_759142
  var valid_759143 = formData.getOrDefault("max_attachment_size")
  valid_759143 = validateParameter(valid_759143, JInt, required = false, default = nil)
  if valid_759143 != nil:
    section.add "max_attachment_size", valid_759143
  var valid_759144 = formData.getOrDefault("sidekiq_throttling_factor")
  valid_759144 = validateParameter(valid_759144, JFloat, required = true, default = nil)
  if valid_759144 != nil:
    section.add "sidekiq_throttling_factor", valid_759144
  var valid_759145 = formData.getOrDefault("default_branch_protection")
  valid_759145 = validateParameter(valid_759145, JInt, required = false, default = nil)
  if valid_759145 != nil:
    section.add "default_branch_protection", valid_759145
  var valid_759146 = formData.getOrDefault("sign_in_text")
  valid_759146 = validateParameter(valid_759146, JString, required = false,
                                 default = nil)
  if valid_759146 != nil:
    section.add "sign_in_text", valid_759146
  var valid_759147 = formData.getOrDefault("default_snippet_visibility")
  valid_759147 = validateParameter(valid_759147, JInt, required = false, default = nil)
  if valid_759147 != nil:
    section.add "default_snippet_visibility", valid_759147
  var valid_759148 = formData.getOrDefault("housekeeping_enabled")
  valid_759148 = validateParameter(valid_759148, JBool, required = false, default = nil)
  if valid_759148 != nil:
    section.add "housekeeping_enabled", valid_759148
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759149: Call_PutV3ApplicationSettings_758995; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modify application settings
  ## 
  let valid = call_759149.validator(path, query, header, formData, body)
  let scheme = call_759149.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759149.url(scheme.get, call_759149.host, call_759149.base,
                         call_759149.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759149, url, valid)

proc call*(call_759150: Call_PutV3ApplicationSettings_758995;
          housekeepingFullRepackPeriod: int; metricsPort: int;
          sharedRunnersText: string; metricsSampleInterval: int;
          housekeepingGcPeriod: int; metricsHost: string; recaptchaSiteKey: string;
          plantumlUrl: string; sidekiqThrottlingQueus: JsonNode; kodingUrl: string;
          domainBlacklist: string; metricsMethodCallThreshold: int;
          metricsTimeout: int; akismetApiKey: string; sentryDsn: string;
          housekeepingIncrementalRepackPeriod: int;
          housekeepingBitmapsEnabled: bool; recaptchaPrivateKey: string;
          metricsPoolSize: int; metricsPacketSize: int; twoFactorGracePeriod: int;
          sidekiqThrottlingFactor: float; gravatarEnabled: bool = false;
          sessionExpireDelay: int = 0; versionCheckEnabled: bool = false;
          disabledOauthSignInSources: JsonNode = nil;
          requireTwoFactorAuthentication: bool = false; maxArtifactsSize: int = 0;
          recaptchaEnabled: bool = false; sharedRunnersEnabled: bool = false;
          enabledGitAccessProtocol: string = "ssh";
          userDefaultExternal: bool = false; domainWhitelist: string = "";
          containerRegistryTokenExpireDelay: int = 0;
          repositoryStorage: string = ""; htmlEmailsEnabled: bool = false;
          homePageUrl: string = ""; defaultGroupVisibility: int = 0;
          sendUserConfirmationEmail: bool = false;
          domainBlacklistEnabled: bool = false; importSources: JsonNode = nil;
          restrictedVisibilityLevels: JsonNode = nil; defaultProjectsLimit: int = 0;
          akismetEnabled: bool = false; signinEnabled: bool = false;
          defaultProjectVisibility: int = 0; helpPageText: string = "";
          afterSignUpText: string = ""; plantumlEnabled: bool = false;
          sidekiqThrottlingEnabled: bool = false; sentryEnabled: bool = false;
          afterSignOutPath: string = ""; kodingEnabled: bool = false;
          signupEnabled: bool = false; adminNotificationEmail: string = "";
          metricsEnabled: bool = false; emailAuthorInBody: bool = false;
          repositoryChecksEnabled: bool = false;
          userOauthApplications: bool = false; maxAttachmentSize: int = 0;
          defaultBranchProtection: int = 0; signInText: string = "";
          defaultSnippetVisibility: int = 0; housekeepingEnabled: bool = false): Recallable =
  ## putV3ApplicationSettings
  ## Modify application settings
  ##   gravatarEnabled: bool
  ##                  : Flag indicating if the Gravatar service is enabled
  ##   housekeepingFullRepackPeriod: int (required)
  ##                               : Number of Git pushes after which a full 'git repack' is run.
  ##   sessionExpireDelay: int
  ##                     : Session duration in minutes. GitLab restart is required to apply changes.
  ##   metricsPort: int (required)
  ##              : The UDP port to use for connecting to InfluxDB
  ##   versionCheckEnabled: bool
  ##                      : Let GitLab inform you when an update is available.
  ##   disabledOauthSignInSources: JArray
  ##                             : Disable certain OAuth sign-in sources
  ##   sharedRunnersText: string (required)
  ##                    : Shared runners text 
  ##   metricsSampleInterval: int (required)
  ##                        : The sampling interval in seconds
  ##   requireTwoFactorAuthentication: bool
  ##                                 : Require all users to setup Two-factor authentication
  ##   maxArtifactsSize: int
  ##                   : Set the maximum file size each build's artifacts can have
  ##   recaptchaEnabled: bool
  ##                   : Helps prevent bots from creating accounts
  ##   housekeepingGcPeriod: int (required)
  ##                       : Number of Git pushes after which 'git gc' is run.
  ##   sharedRunnersEnabled: bool
  ##                       : Enable shared runners for new projects
  ##   enabledGitAccessProtocol: string
  ##                           : Allow only the selected protocols to be used for Git access.
  ##   userDefaultExternal: bool
  ##                      : Newly registered users will by default be external
  ##   domainWhitelist: string
  ##                  : ONLY users with e-mail addresses that match these domain(s) will be able to sign-up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com
  ##   metricsHost: string (required)
  ##              : The InfluxDB host
  ##   containerRegistryTokenExpireDelay: int
  ##                                    : Authorization token duration (minutes)
  ##   recaptchaSiteKey: string (required)
  ##                   : Generate site key at http://www.google.com/recaptcha
  ##   plantumlUrl: string (required)
  ##              : The PlantUML server URL
  ##   sidekiqThrottlingQueus: JArray (required)
  ##                         : Choose which queues you wish to throttle
  ##   repositoryStorage: string
  ##                    : Storage paths for new projects
  ##   htmlEmailsEnabled: bool
  ##                    : By default GitLab sends emails in HTML and plain text formats so mail clients can choose what format to use. Disable this option if you only want to send emails in plain text format.
  ##   kodingUrl: string (required)
  ##            : The Koding team URL
  ##   domainBlacklist: string (required)
  ##                  : Users with e-mail addresses that match these domain(s) will NOT be able to sign-up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com
  ##   homePageUrl: string
  ##              : We will redirect non-logged in users to this page
  ##   defaultGroupVisibility: int
  ##                         : The default group visibility
  ##   sendUserConfirmationEmail: bool
  ##                            : Send confirmation email on sign-up
  ##   domainBlacklistEnabled: bool
  ##                         : Enable domain blacklist for sign ups
  ##   metricsMethodCallThreshold: int (required)
  ##                             : A method call is only tracked when it takes longer to complete than the given amount of milliseconds.
  ##   importSources: JArray
  ##                : Enabled sources for code import during project creation. OmniAuth must be configured for GitHub, Bitbucket, and GitLab.com
  ##   metricsTimeout: int (required)
  ##                 : The amount of seconds after which an InfluxDB connection will time out
  ##   restrictedVisibilityLevels: JArray
  ##                             : Selected levels cannot be used by non-admin users for projects or snippets. If the public level is restricted, user profiles are only visible to logged in users.
  ##   defaultProjectsLimit: int
  ##                       : The maximum number of personal projects
  ##   akismetApiKey: string (required)
  ##                : Generate API key at http://www.akismet.com
  ##   sentryDsn: string (required)
  ##            : Sentry Data Source Name
  ##   akismetEnabled: bool
  ##                 : Helps prevent bots from creating issues
  ##   signinEnabled: bool
  ##                : Flag indicating if sign in is enabled
  ##   housekeepingIncrementalRepackPeriod: int (required)
  ##                                      : Number of Git pushes after which an incremental 'git repack' is run.
  ##   housekeepingBitmapsEnabled: bool (required)
  ##                             : Creating pack file bitmaps makes housekeeping take a little longer but bitmaps should accelerate 'git clone' performance.
  ##   defaultProjectVisibility: int
  ##                           : The default project visibility
  ##   recaptchaPrivateKey: string (required)
  ##                      : Generate private key at http://www.google.com/recaptcha
  ##   helpPageText: string
  ##               : Custom text displayed on the help page
  ##   afterSignUpText: string
  ##                  : Text shown after sign up
  ##   plantumlEnabled: bool
  ##                  : Enable PlantUML
  ##   sidekiqThrottlingEnabled: bool
  ##                           : Enable Sidekiq Job Throttling
  ##   metricsPoolSize: int (required)
  ##                  : The amount of InfluxDB connections to open
  ##   sentryEnabled: bool
  ##                : Sentry is an error reporting and logging tool which is currently not shipped with GitLab, get it here: https://getsentry.com
  ##   afterSignOutPath: string
  ##                   : We will redirect users to this page after they sign out
  ##   metricsPacketSize: int (required)
  ##                    : The amount of points to store in a single UDP packet
  ##   kodingEnabled: bool
  ##                : Enable Koding
  ##   signupEnabled: bool
  ##                : Flag indicating if sign up is enabled
  ##   adminNotificationEmail: string
  ##                         : Abuse reports will be sent to this address if it is set. Abuse reports are always available in the admin area.
  ##   twoFactorGracePeriod: int (required)
  ##                       : Amount of time (in hours) that users are allowed to skip forced configuration of two-factor authentication
  ##   metricsEnabled: bool
  ##                 : Enable the InfluxDB metrics
  ##   emailAuthorInBody: bool
  ##                    : Some email servers do not support overriding the email sender name. Enable this option to include the name of the author of the issue, merge request or comment in the email body instead.
  ##   repositoryChecksEnabled: bool
  ##                          : GitLab will periodically run 'git fsck' in all project and wiki repositories to look for silent disk corruption issues.
  ##   userOauthApplications: bool
  ##                        : Allow users to register any application to use GitLab as an OAuth provider
  ##   maxAttachmentSize: int
  ##                    : Maximum attachment size in MB
  ##   sidekiqThrottlingFactor: float (required)
  ##                          : The factor by which the queues should be throttled. A value between 0.0 and 1.0, exclusive.
  ##   defaultBranchProtection: int
  ##                          : Determine if developers can push to master
  ##   signInText: string
  ##             : The sign in text of the GitLab application
  ##   defaultSnippetVisibility: int
  ##                           : The default snippet visibility
  ##   housekeepingEnabled: bool
  ##                      : Enable automatic repository housekeeping (git repack, git gc)
  var formData_759151 = newJObject()
  add(formData_759151, "gravatar_enabled", newJBool(gravatarEnabled))
  add(formData_759151, "housekeeping_full_repack_period",
      newJInt(housekeepingFullRepackPeriod))
  add(formData_759151, "session_expire_delay", newJInt(sessionExpireDelay))
  add(formData_759151, "metrics_port", newJInt(metricsPort))
  add(formData_759151, "version_check_enabled", newJBool(versionCheckEnabled))
  if disabledOauthSignInSources != nil:
    formData_759151.add "disabled_oauth_sign_in_sources",
                       disabledOauthSignInSources
  add(formData_759151, "shared_runners_text", newJString(sharedRunnersText))
  add(formData_759151, "metrics_sample_interval", newJInt(metricsSampleInterval))
  add(formData_759151, "require_two_factor_authentication",
      newJBool(requireTwoFactorAuthentication))
  add(formData_759151, "max_artifacts_size", newJInt(maxArtifactsSize))
  add(formData_759151, "recaptcha_enabled", newJBool(recaptchaEnabled))
  add(formData_759151, "housekeeping_gc_period", newJInt(housekeepingGcPeriod))
  add(formData_759151, "shared_runners_enabled", newJBool(sharedRunnersEnabled))
  add(formData_759151, "enabled_git_access_protocol",
      newJString(enabledGitAccessProtocol))
  add(formData_759151, "user_default_external", newJBool(userDefaultExternal))
  add(formData_759151, "domain_whitelist", newJString(domainWhitelist))
  add(formData_759151, "metrics_host", newJString(metricsHost))
  add(formData_759151, "container_registry_token_expire_delay",
      newJInt(containerRegistryTokenExpireDelay))
  add(formData_759151, "recaptcha_site_key", newJString(recaptchaSiteKey))
  add(formData_759151, "plantuml_url", newJString(plantumlUrl))
  if sidekiqThrottlingQueus != nil:
    formData_759151.add "sidekiq_throttling_queus", sidekiqThrottlingQueus
  add(formData_759151, "repository_storage", newJString(repositoryStorage))
  add(formData_759151, "html_emails_enabled", newJBool(htmlEmailsEnabled))
  add(formData_759151, "koding_url", newJString(kodingUrl))
  add(formData_759151, "domain_blacklist", newJString(domainBlacklist))
  add(formData_759151, "home_page_url", newJString(homePageUrl))
  add(formData_759151, "default_group_visibility", newJInt(defaultGroupVisibility))
  add(formData_759151, "send_user_confirmation_email",
      newJBool(sendUserConfirmationEmail))
  add(formData_759151, "domain_blacklist_enabled",
      newJBool(domainBlacklistEnabled))
  add(formData_759151, "metrics_method_call_threshold",
      newJInt(metricsMethodCallThreshold))
  if importSources != nil:
    formData_759151.add "import_sources", importSources
  add(formData_759151, "metrics_timeout", newJInt(metricsTimeout))
  if restrictedVisibilityLevels != nil:
    formData_759151.add "restricted_visibility_levels", restrictedVisibilityLevels
  add(formData_759151, "default_projects_limit", newJInt(defaultProjectsLimit))
  add(formData_759151, "akismet_api_key", newJString(akismetApiKey))
  add(formData_759151, "sentry_dsn", newJString(sentryDsn))
  add(formData_759151, "akismet_enabled", newJBool(akismetEnabled))
  add(formData_759151, "signin_enabled", newJBool(signinEnabled))
  add(formData_759151, "housekeeping_incremental_repack_period",
      newJInt(housekeepingIncrementalRepackPeriod))
  add(formData_759151, "housekeeping_bitmaps_enabled",
      newJBool(housekeepingBitmapsEnabled))
  add(formData_759151, "default_project_visibility",
      newJInt(defaultProjectVisibility))
  add(formData_759151, "recaptcha_private_key", newJString(recaptchaPrivateKey))
  add(formData_759151, "help_page_text", newJString(helpPageText))
  add(formData_759151, "after_sign_up_text", newJString(afterSignUpText))
  add(formData_759151, "plantuml_enabled", newJBool(plantumlEnabled))
  add(formData_759151, "sidekiq_throttling_enabled",
      newJBool(sidekiqThrottlingEnabled))
  add(formData_759151, "metrics_pool_size", newJInt(metricsPoolSize))
  add(formData_759151, "sentry_enabled", newJBool(sentryEnabled))
  add(formData_759151, "after_sign_out_path", newJString(afterSignOutPath))
  add(formData_759151, "metrics_packet_size", newJInt(metricsPacketSize))
  add(formData_759151, "koding_enabled", newJBool(kodingEnabled))
  add(formData_759151, "signup_enabled", newJBool(signupEnabled))
  add(formData_759151, "admin_notification_email",
      newJString(adminNotificationEmail))
  add(formData_759151, "two_factor_grace_period", newJInt(twoFactorGracePeriod))
  add(formData_759151, "metrics_enabled", newJBool(metricsEnabled))
  add(formData_759151, "email_author_in_body", newJBool(emailAuthorInBody))
  add(formData_759151, "repository_checks_enabled",
      newJBool(repositoryChecksEnabled))
  add(formData_759151, "user_oauth_applications", newJBool(userOauthApplications))
  add(formData_759151, "max_attachment_size", newJInt(maxAttachmentSize))
  add(formData_759151, "sidekiq_throttling_factor",
      newJFloat(sidekiqThrottlingFactor))
  add(formData_759151, "default_branch_protection",
      newJInt(defaultBranchProtection))
  add(formData_759151, "sign_in_text", newJString(signInText))
  add(formData_759151, "default_snippet_visibility",
      newJInt(defaultSnippetVisibility))
  add(formData_759151, "housekeeping_enabled", newJBool(housekeepingEnabled))
  result = call_759150.call(nil, nil, nil, formData_759151, nil)

var putV3ApplicationSettings* = Call_PutV3ApplicationSettings_758995(
    name: "putV3ApplicationSettings", meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/application/settings",
    validator: validate_PutV3ApplicationSettings_758996, base: "/api",
    url: url_PutV3ApplicationSettings_758997, schemes: {Scheme.Https})
type
  Call_GetV3ApplicationSettings_758770 = ref object of OpenApiRestCall_758573
proc url_GetV3ApplicationSettings_758772(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3ApplicationSettings_758771(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the current application settings
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_758873: Call_GetV3ApplicationSettings_758770; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the current application settings
  ## 
  let valid = call_758873.validator(path, query, header, formData, body)
  let scheme = call_758873.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_758873.url(scheme.get, call_758873.host, call_758873.base,
                         call_758873.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_758873, url, valid)

proc call*(call_758957: Call_GetV3ApplicationSettings_758770): Recallable =
  ## getV3ApplicationSettings
  ## Get the current application settings
  result = call_758957.call(nil, nil, nil, nil, nil)

var getV3ApplicationSettings* = Call_GetV3ApplicationSettings_758770(
    name: "getV3ApplicationSettings", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/application/settings",
    validator: validate_GetV3ApplicationSettings_758771, base: "/api",
    url: url_GetV3ApplicationSettings_758772, schemes: {Scheme.Https})
type
  Call_PostV3CiLint_759154 = ref object of OpenApiRestCall_758573
proc url_PostV3CiLint_759156(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3CiLint_759155(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Validation of .gitlab-ci.yml content
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   content: JString (required)
  ##          : Content of .gitlab-ci.yml
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `content` field"
  var valid_759157 = formData.getOrDefault("content")
  valid_759157 = validateParameter(valid_759157, JString, required = true,
                                 default = nil)
  if valid_759157 != nil:
    section.add "content", valid_759157
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759158: Call_PostV3CiLint_759154; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validation of .gitlab-ci.yml content
  ## 
  let valid = call_759158.validator(path, query, header, formData, body)
  let scheme = call_759158.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759158.url(scheme.get, call_759158.host, call_759158.base,
                         call_759158.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759158, url, valid)

proc call*(call_759159: Call_PostV3CiLint_759154; content: string): Recallable =
  ## postV3CiLint
  ## Validation of .gitlab-ci.yml content
  ##   content: string (required)
  ##          : Content of .gitlab-ci.yml
  var formData_759160 = newJObject()
  add(formData_759160, "content", newJString(content))
  result = call_759159.call(nil, nil, nil, formData_759160, nil)

var postV3CiLint* = Call_PostV3CiLint_759154(name: "postV3CiLint",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/ci/lint",
    validator: validate_PostV3CiLint_759155, base: "/api", url: url_PostV3CiLint_759156,
    schemes: {Scheme.Https})
type
  Call_GetV3DeployKeys_759161 = ref object of OpenApiRestCall_758573
proc url_GetV3DeployKeys_759163(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3DeployKeys_759162(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759164: Call_GetV3DeployKeys_759161; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  let valid = call_759164.validator(path, query, header, formData, body)
  let scheme = call_759164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759164.url(scheme.get, call_759164.host, call_759164.base,
                         call_759164.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759164, url, valid)

proc call*(call_759165: Call_GetV3DeployKeys_759161): Recallable =
  ## getV3DeployKeys
  result = call_759165.call(nil, nil, nil, nil, nil)

var getV3DeployKeys* = Call_GetV3DeployKeys_759161(name: "getV3DeployKeys",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/deploy_keys",
    validator: validate_GetV3DeployKeys_759162, base: "/api",
    url: url_GetV3DeployKeys_759163, schemes: {Scheme.Https})
type
  Call_GetV3Dockerfiles_759166 = ref object of OpenApiRestCall_758573
proc url_GetV3Dockerfiles_759168(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Dockerfiles_759167(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759169: Call_GetV3Dockerfiles_759166; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  let valid = call_759169.validator(path, query, header, formData, body)
  let scheme = call_759169.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759169.url(scheme.get, call_759169.host, call_759169.base,
                         call_759169.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759169, url, valid)

proc call*(call_759170: Call_GetV3Dockerfiles_759166): Recallable =
  ## getV3Dockerfiles
  ## This feature was introduced in GitLab 8.15. This endpoint is deprecated and will be removed in GitLab 9.0.
  result = call_759170.call(nil, nil, nil, nil, nil)

var getV3Dockerfiles* = Call_GetV3Dockerfiles_759166(name: "getV3Dockerfiles",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/dockerfiles",
    validator: validate_GetV3Dockerfiles_759167, base: "/api",
    url: url_GetV3Dockerfiles_759168, schemes: {Scheme.Https})
type
  Call_GetV3DockerfilesName_759171 = ref object of OpenApiRestCall_758573
proc url_GetV3DockerfilesName_759173(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/dockerfiles/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3DockerfilesName_759172(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : The name of the template
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_759188 = path.getOrDefault("name")
  valid_759188 = validateParameter(valid_759188, JString, required = true,
                                 default = nil)
  if valid_759188 != nil:
    section.add "name", valid_759188
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759189: Call_GetV3DockerfilesName_759171; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  let valid = call_759189.validator(path, query, header, formData, body)
  let scheme = call_759189.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759189.url(scheme.get, call_759189.host, call_759189.base,
                         call_759189.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759189, url, valid)

proc call*(call_759190: Call_GetV3DockerfilesName_759171; name: string): Recallable =
  ## getV3DockerfilesName
  ## This feature was introduced in GitLab 8.15. This endpoint is deprecated and will be removed in GitLab 9.0.
  ##   name: string (required)
  ##       : The name of the template
  var path_759191 = newJObject()
  add(path_759191, "name", newJString(name))
  result = call_759190.call(path_759191, nil, nil, nil, nil)

var getV3DockerfilesName* = Call_GetV3DockerfilesName_759171(
    name: "getV3DockerfilesName", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/dockerfiles/{name}", validator: validate_GetV3DockerfilesName_759172,
    base: "/api", url: url_GetV3DockerfilesName_759173, schemes: {Scheme.Https})
type
  Call_GetV3Gitignores_759192 = ref object of OpenApiRestCall_758573
proc url_GetV3Gitignores_759194(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Gitignores_759193(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.8. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759195: Call_GetV3Gitignores_759192; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.8. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  let valid = call_759195.validator(path, query, header, formData, body)
  let scheme = call_759195.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759195.url(scheme.get, call_759195.host, call_759195.base,
                         call_759195.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759195, url, valid)

proc call*(call_759196: Call_GetV3Gitignores_759192): Recallable =
  ## getV3Gitignores
  ## This feature was introduced in GitLab 8.8. This endpoint is deprecated and will be removed in GitLab 9.0.
  result = call_759196.call(nil, nil, nil, nil, nil)

var getV3Gitignores* = Call_GetV3Gitignores_759192(name: "getV3Gitignores",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/gitignores",
    validator: validate_GetV3Gitignores_759193, base: "/api",
    url: url_GetV3Gitignores_759194, schemes: {Scheme.Https})
type
  Call_GetV3GitignoresName_759197 = ref object of OpenApiRestCall_758573
proc url_GetV3GitignoresName_759199(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/gitignores/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3GitignoresName_759198(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.8. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : The name of the template
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_759200 = path.getOrDefault("name")
  valid_759200 = validateParameter(valid_759200, JString, required = true,
                                 default = nil)
  if valid_759200 != nil:
    section.add "name", valid_759200
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759201: Call_GetV3GitignoresName_759197; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.8. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  let valid = call_759201.validator(path, query, header, formData, body)
  let scheme = call_759201.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759201.url(scheme.get, call_759201.host, call_759201.base,
                         call_759201.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759201, url, valid)

proc call*(call_759202: Call_GetV3GitignoresName_759197; name: string): Recallable =
  ## getV3GitignoresName
  ## This feature was introduced in GitLab 8.8. This endpoint is deprecated and will be removed in GitLab 9.0.
  ##   name: string (required)
  ##       : The name of the template
  var path_759203 = newJObject()
  add(path_759203, "name", newJString(name))
  result = call_759202.call(path_759203, nil, nil, nil, nil)

var getV3GitignoresName* = Call_GetV3GitignoresName_759197(
    name: "getV3GitignoresName", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/gitignores/{name}", validator: validate_GetV3GitignoresName_759198,
    base: "/api", url: url_GetV3GitignoresName_759199, schemes: {Scheme.Https})
type
  Call_GetV3GitlabCiYmls_759204 = ref object of OpenApiRestCall_758573
proc url_GetV3GitlabCiYmls_759206(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3GitlabCiYmls_759205(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.9. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759207: Call_GetV3GitlabCiYmls_759204; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.9. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  let valid = call_759207.validator(path, query, header, formData, body)
  let scheme = call_759207.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759207.url(scheme.get, call_759207.host, call_759207.base,
                         call_759207.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759207, url, valid)

proc call*(call_759208: Call_GetV3GitlabCiYmls_759204): Recallable =
  ## getV3GitlabCiYmls
  ## This feature was introduced in GitLab 8.9. This endpoint is deprecated and will be removed in GitLab 9.0.
  result = call_759208.call(nil, nil, nil, nil, nil)

var getV3GitlabCiYmls* = Call_GetV3GitlabCiYmls_759204(name: "getV3GitlabCiYmls",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/gitlab_ci_ymls",
    validator: validate_GetV3GitlabCiYmls_759205, base: "/api",
    url: url_GetV3GitlabCiYmls_759206, schemes: {Scheme.Https})
type
  Call_GetV3GitlabCiYmlsName_759209 = ref object of OpenApiRestCall_758573
proc url_GetV3GitlabCiYmlsName_759211(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/gitlab_ci_ymls/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3GitlabCiYmlsName_759210(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.9. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : The name of the template
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_759212 = path.getOrDefault("name")
  valid_759212 = validateParameter(valid_759212, JString, required = true,
                                 default = nil)
  if valid_759212 != nil:
    section.add "name", valid_759212
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759213: Call_GetV3GitlabCiYmlsName_759209; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.9. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  let valid = call_759213.validator(path, query, header, formData, body)
  let scheme = call_759213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759213.url(scheme.get, call_759213.host, call_759213.base,
                         call_759213.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759213, url, valid)

proc call*(call_759214: Call_GetV3GitlabCiYmlsName_759209; name: string): Recallable =
  ## getV3GitlabCiYmlsName
  ## This feature was introduced in GitLab 8.9. This endpoint is deprecated and will be removed in GitLab 9.0.
  ##   name: string (required)
  ##       : The name of the template
  var path_759215 = newJObject()
  add(path_759215, "name", newJString(name))
  result = call_759214.call(path_759215, nil, nil, nil, nil)

var getV3GitlabCiYmlsName* = Call_GetV3GitlabCiYmlsName_759209(
    name: "getV3GitlabCiYmlsName", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/gitlab_ci_ymls/{name}", validator: validate_GetV3GitlabCiYmlsName_759210,
    base: "/api", url: url_GetV3GitlabCiYmlsName_759211, schemes: {Scheme.Https})
type
  Call_PostV3Groups_759231 = ref object of OpenApiRestCall_758573
proc url_PostV3Groups_759233(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3Groups_759232(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a group. Available only for users who can create groups.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   path: JString (required)
  ##       : The path of the group
  ##   lfs_enabled: JBool
  ##              : Enable/disable LFS for the projects in this group
  ##   description: JString
  ##              : The description of the group
  ##   request_access_enabled: JBool
  ##                         : Allow users to request member access
  ##   visibility_level: JInt
  ##                   : The visibility level of the group
  ##   name: JString (required)
  ##       : The name of the group
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `path` field"
  var valid_759234 = formData.getOrDefault("path")
  valid_759234 = validateParameter(valid_759234, JString, required = true,
                                 default = nil)
  if valid_759234 != nil:
    section.add "path", valid_759234
  var valid_759235 = formData.getOrDefault("lfs_enabled")
  valid_759235 = validateParameter(valid_759235, JBool, required = false, default = nil)
  if valid_759235 != nil:
    section.add "lfs_enabled", valid_759235
  var valid_759236 = formData.getOrDefault("description")
  valid_759236 = validateParameter(valid_759236, JString, required = false,
                                 default = nil)
  if valid_759236 != nil:
    section.add "description", valid_759236
  var valid_759237 = formData.getOrDefault("request_access_enabled")
  valid_759237 = validateParameter(valid_759237, JBool, required = false, default = nil)
  if valid_759237 != nil:
    section.add "request_access_enabled", valid_759237
  var valid_759238 = formData.getOrDefault("visibility_level")
  valid_759238 = validateParameter(valid_759238, JInt, required = false, default = nil)
  if valid_759238 != nil:
    section.add "visibility_level", valid_759238
  var valid_759239 = formData.getOrDefault("name")
  valid_759239 = validateParameter(valid_759239, JString, required = true,
                                 default = nil)
  if valid_759239 != nil:
    section.add "name", valid_759239
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759240: Call_PostV3Groups_759231; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a group. Available only for users who can create groups.
  ## 
  let valid = call_759240.validator(path, query, header, formData, body)
  let scheme = call_759240.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759240.url(scheme.get, call_759240.host, call_759240.base,
                         call_759240.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759240, url, valid)

proc call*(call_759241: Call_PostV3Groups_759231; path: string; name: string;
          lfsEnabled: bool = false; description: string = "";
          requestAccessEnabled: bool = false; visibilityLevel: int = 0): Recallable =
  ## postV3Groups
  ## Create a group. Available only for users who can create groups.
  ##   path: string (required)
  ##       : The path of the group
  ##   lfsEnabled: bool
  ##             : Enable/disable LFS for the projects in this group
  ##   description: string
  ##              : The description of the group
  ##   requestAccessEnabled: bool
  ##                       : Allow users to request member access
  ##   visibilityLevel: int
  ##                  : The visibility level of the group
  ##   name: string (required)
  ##       : The name of the group
  var formData_759242 = newJObject()
  add(formData_759242, "path", newJString(path))
  add(formData_759242, "lfs_enabled", newJBool(lfsEnabled))
  add(formData_759242, "description", newJString(description))
  add(formData_759242, "request_access_enabled", newJBool(requestAccessEnabled))
  add(formData_759242, "visibility_level", newJInt(visibilityLevel))
  add(formData_759242, "name", newJString(name))
  result = call_759241.call(nil, nil, nil, formData_759242, nil)

var postV3Groups* = Call_PostV3Groups_759231(name: "postV3Groups",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/groups",
    validator: validate_PostV3Groups_759232, base: "/api", url: url_PostV3Groups_759233,
    schemes: {Scheme.Https})
type
  Call_GetV3Groups_759216 = ref object of OpenApiRestCall_758573
proc url_GetV3Groups_759218(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Groups_759217(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a groups list
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   statistics: JBool
  ##             : Include project statistics
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   all_available: JBool
  ##                : Show all group that you have access to
  ##   search: JString
  ##         : Search for a specific group
  ##   order_by: JString
  ##           : Order by name or path
  ##   sort: JString
  ##       : Sort by asc (ascending) or desc (descending)
  section = newJObject()
  var valid_759219 = query.getOrDefault("statistics")
  valid_759219 = validateParameter(valid_759219, JBool, required = false, default = nil)
  if valid_759219 != nil:
    section.add "statistics", valid_759219
  var valid_759220 = query.getOrDefault("per_page")
  valid_759220 = validateParameter(valid_759220, JInt, required = false, default = nil)
  if valid_759220 != nil:
    section.add "per_page", valid_759220
  var valid_759221 = query.getOrDefault("page")
  valid_759221 = validateParameter(valid_759221, JInt, required = false, default = nil)
  if valid_759221 != nil:
    section.add "page", valid_759221
  var valid_759222 = query.getOrDefault("all_available")
  valid_759222 = validateParameter(valid_759222, JBool, required = false, default = nil)
  if valid_759222 != nil:
    section.add "all_available", valid_759222
  var valid_759223 = query.getOrDefault("search")
  valid_759223 = validateParameter(valid_759223, JString, required = false,
                                 default = nil)
  if valid_759223 != nil:
    section.add "search", valid_759223
  var valid_759224 = query.getOrDefault("order_by")
  valid_759224 = validateParameter(valid_759224, JString, required = false,
                                 default = newJString("name"))
  if valid_759224 != nil:
    section.add "order_by", valid_759224
  var valid_759225 = query.getOrDefault("sort")
  valid_759225 = validateParameter(valid_759225, JString, required = false,
                                 default = newJString("asc"))
  if valid_759225 != nil:
    section.add "sort", valid_759225
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   skip_groups: JArray
  ##              : Array of group ids to exclude from list
  section = newJObject()
  var valid_759226 = formData.getOrDefault("skip_groups")
  valid_759226 = validateParameter(valid_759226, JArray, required = false,
                                 default = nil)
  if valid_759226 != nil:
    section.add "skip_groups", valid_759226
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759227: Call_GetV3Groups_759216; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a groups list
  ## 
  let valid = call_759227.validator(path, query, header, formData, body)
  let scheme = call_759227.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759227.url(scheme.get, call_759227.host, call_759227.base,
                         call_759227.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759227, url, valid)

proc call*(call_759228: Call_GetV3Groups_759216; statistics: bool = false;
          perPage: int = 0; page: int = 0; allAvailable: bool = false;
          skipGroups: JsonNode = nil; search: string = ""; orderBy: string = "name";
          sort: string = "asc"): Recallable =
  ## getV3Groups
  ## Get a groups list
  ##   statistics: bool
  ##             : Include project statistics
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   allAvailable: bool
  ##               : Show all group that you have access to
  ##   skipGroups: JArray
  ##             : Array of group ids to exclude from list
  ##   search: string
  ##         : Search for a specific group
  ##   orderBy: string
  ##          : Order by name or path
  ##   sort: string
  ##       : Sort by asc (ascending) or desc (descending)
  var query_759229 = newJObject()
  var formData_759230 = newJObject()
  add(query_759229, "statistics", newJBool(statistics))
  add(query_759229, "per_page", newJInt(perPage))
  add(query_759229, "page", newJInt(page))
  add(query_759229, "all_available", newJBool(allAvailable))
  if skipGroups != nil:
    formData_759230.add "skip_groups", skipGroups
  add(query_759229, "search", newJString(search))
  add(query_759229, "order_by", newJString(orderBy))
  add(query_759229, "sort", newJString(sort))
  result = call_759228.call(nil, query_759229, nil, formData_759230, nil)

var getV3Groups* = Call_GetV3Groups_759216(name: "getV3Groups",
                                        meth: HttpMethod.HttpGet,
                                        host: "gitlab.com", route: "/v3/groups",
                                        validator: validate_GetV3Groups_759217,
                                        base: "/api", url: url_GetV3Groups_759218,
                                        schemes: {Scheme.Https})
type
  Call_GetV3GroupsOwned_759243 = ref object of OpenApiRestCall_758573
proc url_GetV3GroupsOwned_759245(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3GroupsOwned_759244(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Get list of owned groups for authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   statistics: JBool
  ##             : Include project statistics
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_759246 = query.getOrDefault("statistics")
  valid_759246 = validateParameter(valid_759246, JBool, required = false, default = nil)
  if valid_759246 != nil:
    section.add "statistics", valid_759246
  var valid_759247 = query.getOrDefault("per_page")
  valid_759247 = validateParameter(valid_759247, JInt, required = false, default = nil)
  if valid_759247 != nil:
    section.add "per_page", valid_759247
  var valid_759248 = query.getOrDefault("page")
  valid_759248 = validateParameter(valid_759248, JInt, required = false, default = nil)
  if valid_759248 != nil:
    section.add "page", valid_759248
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759249: Call_GetV3GroupsOwned_759243; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of owned groups for authenticated user
  ## 
  let valid = call_759249.validator(path, query, header, formData, body)
  let scheme = call_759249.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759249.url(scheme.get, call_759249.host, call_759249.base,
                         call_759249.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759249, url, valid)

proc call*(call_759250: Call_GetV3GroupsOwned_759243; statistics: bool = false;
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3GroupsOwned
  ## Get list of owned groups for authenticated user
  ##   statistics: bool
  ##             : Include project statistics
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var query_759251 = newJObject()
  add(query_759251, "statistics", newJBool(statistics))
  add(query_759251, "per_page", newJInt(perPage))
  add(query_759251, "page", newJInt(page))
  result = call_759250.call(nil, query_759251, nil, nil, nil)

var getV3GroupsOwned* = Call_GetV3GroupsOwned_759243(name: "getV3GroupsOwned",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/groups/owned",
    validator: validate_GetV3GroupsOwned_759244, base: "/api",
    url: url_GetV3GroupsOwned_759245, schemes: {Scheme.Https})
type
  Call_PutV3GroupsId_759259 = ref object of OpenApiRestCall_758573
proc url_PutV3GroupsId_759261(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3GroupsId_759260(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a group. Available only for users who can administrate groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a group
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759262 = path.getOrDefault("id")
  valid_759262 = validateParameter(valid_759262, JString, required = true,
                                 default = nil)
  if valid_759262 != nil:
    section.add "id", valid_759262
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   path: JString
  ##       : The path of the group
  ##   lfs_enabled: JBool
  ##              : Enable/disable LFS for the projects in this group
  ##   description: JString
  ##              : The description of the group
  ##   request_access_enabled: JBool
  ##                         : Allow users to request member access
  ##   visibility_level: JInt
  ##                   : The visibility level of the group
  ##   name: JString
  ##       : The name of the group
  section = newJObject()
  var valid_759263 = formData.getOrDefault("path")
  valid_759263 = validateParameter(valid_759263, JString, required = false,
                                 default = nil)
  if valid_759263 != nil:
    section.add "path", valid_759263
  var valid_759264 = formData.getOrDefault("lfs_enabled")
  valid_759264 = validateParameter(valid_759264, JBool, required = false, default = nil)
  if valid_759264 != nil:
    section.add "lfs_enabled", valid_759264
  var valid_759265 = formData.getOrDefault("description")
  valid_759265 = validateParameter(valid_759265, JString, required = false,
                                 default = nil)
  if valid_759265 != nil:
    section.add "description", valid_759265
  var valid_759266 = formData.getOrDefault("request_access_enabled")
  valid_759266 = validateParameter(valid_759266, JBool, required = false, default = nil)
  if valid_759266 != nil:
    section.add "request_access_enabled", valid_759266
  var valid_759267 = formData.getOrDefault("visibility_level")
  valid_759267 = validateParameter(valid_759267, JInt, required = false, default = nil)
  if valid_759267 != nil:
    section.add "visibility_level", valid_759267
  var valid_759268 = formData.getOrDefault("name")
  valid_759268 = validateParameter(valid_759268, JString, required = false,
                                 default = nil)
  if valid_759268 != nil:
    section.add "name", valid_759268
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759269: Call_PutV3GroupsId_759259; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a group. Available only for users who can administrate groups.
  ## 
  let valid = call_759269.validator(path, query, header, formData, body)
  let scheme = call_759269.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759269.url(scheme.get, call_759269.host, call_759269.base,
                         call_759269.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759269, url, valid)

proc call*(call_759270: Call_PutV3GroupsId_759259; id: string; path: string = "";
          lfsEnabled: bool = false; description: string = "";
          requestAccessEnabled: bool = false; visibilityLevel: int = 0;
          name: string = ""): Recallable =
  ## putV3GroupsId
  ## Update a group. Available only for users who can administrate groups.
  ##   id: string (required)
  ##     : The ID of a group
  ##   path: string
  ##       : The path of the group
  ##   lfsEnabled: bool
  ##             : Enable/disable LFS for the projects in this group
  ##   description: string
  ##              : The description of the group
  ##   requestAccessEnabled: bool
  ##                       : Allow users to request member access
  ##   visibilityLevel: int
  ##                  : The visibility level of the group
  ##   name: string
  ##       : The name of the group
  var path_759271 = newJObject()
  var formData_759272 = newJObject()
  add(path_759271, "id", newJString(id))
  add(formData_759272, "path", newJString(path))
  add(formData_759272, "lfs_enabled", newJBool(lfsEnabled))
  add(formData_759272, "description", newJString(description))
  add(formData_759272, "request_access_enabled", newJBool(requestAccessEnabled))
  add(formData_759272, "visibility_level", newJInt(visibilityLevel))
  add(formData_759272, "name", newJString(name))
  result = call_759270.call(path_759271, nil, nil, formData_759272, nil)

var putV3GroupsId* = Call_PutV3GroupsId_759259(name: "putV3GroupsId",
    meth: HttpMethod.HttpPut, host: "gitlab.com", route: "/v3/groups/{id}",
    validator: validate_PutV3GroupsId_759260, base: "/api", url: url_PutV3GroupsId_759261,
    schemes: {Scheme.Https})
type
  Call_GetV3GroupsId_759252 = ref object of OpenApiRestCall_758573
proc url_GetV3GroupsId_759254(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3GroupsId_759253(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single group, with containing projects.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a group
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759255 = path.getOrDefault("id")
  valid_759255 = validateParameter(valid_759255, JString, required = true,
                                 default = nil)
  if valid_759255 != nil:
    section.add "id", valid_759255
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759256: Call_GetV3GroupsId_759252; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single group, with containing projects.
  ## 
  let valid = call_759256.validator(path, query, header, formData, body)
  let scheme = call_759256.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759256.url(scheme.get, call_759256.host, call_759256.base,
                         call_759256.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759256, url, valid)

proc call*(call_759257: Call_GetV3GroupsId_759252; id: string): Recallable =
  ## getV3GroupsId
  ## Get a single group, with containing projects.
  ##   id: string (required)
  ##     : The ID of a group
  var path_759258 = newJObject()
  add(path_759258, "id", newJString(id))
  result = call_759257.call(path_759258, nil, nil, nil, nil)

var getV3GroupsId* = Call_GetV3GroupsId_759252(name: "getV3GroupsId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/groups/{id}",
    validator: validate_GetV3GroupsId_759253, base: "/api", url: url_GetV3GroupsId_759254,
    schemes: {Scheme.Https})
type
  Call_DeleteV3GroupsId_759273 = ref object of OpenApiRestCall_758573
proc url_DeleteV3GroupsId_759275(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3GroupsId_759274(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Remove a group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a group
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759276 = path.getOrDefault("id")
  valid_759276 = validateParameter(valid_759276, JString, required = true,
                                 default = nil)
  if valid_759276 != nil:
    section.add "id", valid_759276
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759277: Call_DeleteV3GroupsId_759273; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove a group.
  ## 
  let valid = call_759277.validator(path, query, header, formData, body)
  let scheme = call_759277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759277.url(scheme.get, call_759277.host, call_759277.base,
                         call_759277.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759277, url, valid)

proc call*(call_759278: Call_DeleteV3GroupsId_759273; id: string): Recallable =
  ## deleteV3GroupsId
  ## Remove a group.
  ##   id: string (required)
  ##     : The ID of a group
  var path_759279 = newJObject()
  add(path_759279, "id", newJString(id))
  result = call_759278.call(path_759279, nil, nil, nil, nil)

var deleteV3GroupsId* = Call_DeleteV3GroupsId_759273(name: "deleteV3GroupsId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com", route: "/v3/groups/{id}",
    validator: validate_DeleteV3GroupsId_759274, base: "/api",
    url: url_DeleteV3GroupsId_759275, schemes: {Scheme.Https})
type
  Call_PostV3GroupsIdAccessRequests_759290 = ref object of OpenApiRestCall_758573
proc url_PostV3GroupsIdAccessRequests_759292(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/access_requests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3GroupsIdAccessRequests_759291(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759293 = path.getOrDefault("id")
  valid_759293 = validateParameter(valid_759293, JString, required = true,
                                 default = nil)
  if valid_759293 != nil:
    section.add "id", valid_759293
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759294: Call_PostV3GroupsIdAccessRequests_759290; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_759294.validator(path, query, header, formData, body)
  let scheme = call_759294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759294.url(scheme.get, call_759294.host, call_759294.base,
                         call_759294.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759294, url, valid)

proc call*(call_759295: Call_PostV3GroupsIdAccessRequests_759290; id: string): Recallable =
  ## postV3GroupsIdAccessRequests
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The group ID
  var path_759296 = newJObject()
  add(path_759296, "id", newJString(id))
  result = call_759295.call(path_759296, nil, nil, nil, nil)

var postV3GroupsIdAccessRequests* = Call_PostV3GroupsIdAccessRequests_759290(
    name: "postV3GroupsIdAccessRequests", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/groups/{id}/access_requests",
    validator: validate_PostV3GroupsIdAccessRequests_759291, base: "/api",
    url: url_PostV3GroupsIdAccessRequests_759292, schemes: {Scheme.Https})
type
  Call_GetV3GroupsIdAccessRequests_759280 = ref object of OpenApiRestCall_758573
proc url_GetV3GroupsIdAccessRequests_759282(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/access_requests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3GroupsIdAccessRequests_759281(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759283 = path.getOrDefault("id")
  valid_759283 = validateParameter(valid_759283, JString, required = true,
                                 default = nil)
  if valid_759283 != nil:
    section.add "id", valid_759283
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_759284 = query.getOrDefault("per_page")
  valid_759284 = validateParameter(valid_759284, JInt, required = false, default = nil)
  if valid_759284 != nil:
    section.add "per_page", valid_759284
  var valid_759285 = query.getOrDefault("page")
  valid_759285 = validateParameter(valid_759285, JInt, required = false, default = nil)
  if valid_759285 != nil:
    section.add "page", valid_759285
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759286: Call_GetV3GroupsIdAccessRequests_759280; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_759286.validator(path, query, header, formData, body)
  let scheme = call_759286.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759286.url(scheme.get, call_759286.host, call_759286.base,
                         call_759286.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759286, url, valid)

proc call*(call_759287: Call_GetV3GroupsIdAccessRequests_759280; id: string;
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3GroupsIdAccessRequests
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The group ID
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_759288 = newJObject()
  var query_759289 = newJObject()
  add(path_759288, "id", newJString(id))
  add(query_759289, "per_page", newJInt(perPage))
  add(query_759289, "page", newJInt(page))
  result = call_759287.call(path_759288, query_759289, nil, nil, nil)

var getV3GroupsIdAccessRequests* = Call_GetV3GroupsIdAccessRequests_759280(
    name: "getV3GroupsIdAccessRequests", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/groups/{id}/access_requests",
    validator: validate_GetV3GroupsIdAccessRequests_759281, base: "/api",
    url: url_GetV3GroupsIdAccessRequests_759282, schemes: {Scheme.Https})
type
  Call_DeleteV3GroupsIdAccessRequestsUserId_759297 = ref object of OpenApiRestCall_758573
proc url_DeleteV3GroupsIdAccessRequestsUserId_759299(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/access_requests/"),
               (kind: VariableSegment, value: "user_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3GroupsIdAccessRequestsUserId_759298(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID
  ##   user_id: JInt (required)
  ##          : The user ID of the access requester
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759300 = path.getOrDefault("id")
  valid_759300 = validateParameter(valid_759300, JString, required = true,
                                 default = nil)
  if valid_759300 != nil:
    section.add "id", valid_759300
  var valid_759301 = path.getOrDefault("user_id")
  valid_759301 = validateParameter(valid_759301, JInt, required = true, default = nil)
  if valid_759301 != nil:
    section.add "user_id", valid_759301
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759302: Call_DeleteV3GroupsIdAccessRequestsUserId_759297;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_759302.validator(path, query, header, formData, body)
  let scheme = call_759302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759302.url(scheme.get, call_759302.host, call_759302.base,
                         call_759302.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759302, url, valid)

proc call*(call_759303: Call_DeleteV3GroupsIdAccessRequestsUserId_759297;
          id: string; userId: int): Recallable =
  ## deleteV3GroupsIdAccessRequestsUserId
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The group ID
  ##   userId: int (required)
  ##         : The user ID of the access requester
  var path_759304 = newJObject()
  add(path_759304, "id", newJString(id))
  add(path_759304, "user_id", newJInt(userId))
  result = call_759303.call(path_759304, nil, nil, nil, nil)

var deleteV3GroupsIdAccessRequestsUserId* = Call_DeleteV3GroupsIdAccessRequestsUserId_759297(
    name: "deleteV3GroupsIdAccessRequestsUserId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/groups/{id}/access_requests/{user_id}",
    validator: validate_DeleteV3GroupsIdAccessRequestsUserId_759298, base: "/api",
    url: url_DeleteV3GroupsIdAccessRequestsUserId_759299, schemes: {Scheme.Https})
type
  Call_PutV3GroupsIdAccessRequestsUserIdApprove_759305 = ref object of OpenApiRestCall_758573
proc url_PutV3GroupsIdAccessRequestsUserIdApprove_759307(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/access_requests/"),
               (kind: VariableSegment, value: "user_id"),
               (kind: ConstantSegment, value: "/approve")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3GroupsIdAccessRequestsUserIdApprove_759306(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID
  ##   user_id: JInt (required)
  ##          : The user ID of the access requester
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759308 = path.getOrDefault("id")
  valid_759308 = validateParameter(valid_759308, JString, required = true,
                                 default = nil)
  if valid_759308 != nil:
    section.add "id", valid_759308
  var valid_759309 = path.getOrDefault("user_id")
  valid_759309 = validateParameter(valid_759309, JInt, required = true, default = nil)
  if valid_759309 != nil:
    section.add "user_id", valid_759309
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   access_level: JInt
  ##               : A valid access level (defaults: `30`, developer access level)
  section = newJObject()
  var valid_759310 = formData.getOrDefault("access_level")
  valid_759310 = validateParameter(valid_759310, JInt, required = false, default = nil)
  if valid_759310 != nil:
    section.add "access_level", valid_759310
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759311: Call_PutV3GroupsIdAccessRequestsUserIdApprove_759305;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_759311.validator(path, query, header, formData, body)
  let scheme = call_759311.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759311.url(scheme.get, call_759311.host, call_759311.base,
                         call_759311.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759311, url, valid)

proc call*(call_759312: Call_PutV3GroupsIdAccessRequestsUserIdApprove_759305;
          id: string; userId: int; accessLevel: int = 0): Recallable =
  ## putV3GroupsIdAccessRequestsUserIdApprove
  ## This feature was introduced in GitLab 8.11.
  ##   accessLevel: int
  ##              : A valid access level (defaults: `30`, developer access level)
  ##   id: string (required)
  ##     : The group ID
  ##   userId: int (required)
  ##         : The user ID of the access requester
  var path_759313 = newJObject()
  var formData_759314 = newJObject()
  add(formData_759314, "access_level", newJInt(accessLevel))
  add(path_759313, "id", newJString(id))
  add(path_759313, "user_id", newJInt(userId))
  result = call_759312.call(path_759313, nil, nil, formData_759314, nil)

var putV3GroupsIdAccessRequestsUserIdApprove* = Call_PutV3GroupsIdAccessRequestsUserIdApprove_759305(
    name: "putV3GroupsIdAccessRequestsUserIdApprove", meth: HttpMethod.HttpPut,
    host: "gitlab.com",
    route: "/v3/groups/{id}/access_requests/{user_id}/approve",
    validator: validate_PutV3GroupsIdAccessRequestsUserIdApprove_759306,
    base: "/api", url: url_PutV3GroupsIdAccessRequestsUserIdApprove_759307,
    schemes: {Scheme.Https})
type
  Call_GetV3GroupsIdIssues_759315 = ref object of OpenApiRestCall_758573
proc url_GetV3GroupsIdIssues_759317(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3GroupsIdIssues_759316(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Get a list of group issues
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a group
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759318 = path.getOrDefault("id")
  valid_759318 = validateParameter(valid_759318, JString, required = true,
                                 default = nil)
  if valid_759318 != nil:
    section.add "id", valid_759318
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString
  ##         : Comma-separated list of label names
  ##   state: JString
  ##        : Return opened, closed, or all issues
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   milestone: JString
  ##            : Return issues for a specific milestone
  ##   order_by: JString
  ##           : Return issues ordered by `created_at` or `updated_at` fields.
  ##   sort: JString
  ##       : Return issues sorted in `asc` or `desc` order.
  section = newJObject()
  var valid_759319 = query.getOrDefault("labels")
  valid_759319 = validateParameter(valid_759319, JString, required = false,
                                 default = nil)
  if valid_759319 != nil:
    section.add "labels", valid_759319
  var valid_759320 = query.getOrDefault("state")
  valid_759320 = validateParameter(valid_759320, JString, required = false,
                                 default = newJString("opened"))
  if valid_759320 != nil:
    section.add "state", valid_759320
  var valid_759321 = query.getOrDefault("per_page")
  valid_759321 = validateParameter(valid_759321, JInt, required = false, default = nil)
  if valid_759321 != nil:
    section.add "per_page", valid_759321
  var valid_759322 = query.getOrDefault("page")
  valid_759322 = validateParameter(valid_759322, JInt, required = false, default = nil)
  if valid_759322 != nil:
    section.add "page", valid_759322
  var valid_759323 = query.getOrDefault("milestone")
  valid_759323 = validateParameter(valid_759323, JString, required = false,
                                 default = nil)
  if valid_759323 != nil:
    section.add "milestone", valid_759323
  var valid_759324 = query.getOrDefault("order_by")
  valid_759324 = validateParameter(valid_759324, JString, required = false,
                                 default = newJString("created_at"))
  if valid_759324 != nil:
    section.add "order_by", valid_759324
  var valid_759325 = query.getOrDefault("sort")
  valid_759325 = validateParameter(valid_759325, JString, required = false,
                                 default = newJString("desc"))
  if valid_759325 != nil:
    section.add "sort", valid_759325
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759326: Call_GetV3GroupsIdIssues_759315; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a list of group issues
  ## 
  let valid = call_759326.validator(path, query, header, formData, body)
  let scheme = call_759326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759326.url(scheme.get, call_759326.host, call_759326.base,
                         call_759326.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759326, url, valid)

proc call*(call_759327: Call_GetV3GroupsIdIssues_759315; id: string;
          labels: string = ""; state: string = "opened"; perPage: int = 0; page: int = 0;
          milestone: string = ""; orderBy: string = "created_at"; sort: string = "desc"): Recallable =
  ## getV3GroupsIdIssues
  ## Get a list of group issues
  ##   labels: string
  ##         : Comma-separated list of label names
  ##   id: string (required)
  ##     : The ID of a group
  ##   state: string
  ##        : Return opened, closed, or all issues
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   milestone: string
  ##            : Return issues for a specific milestone
  ##   orderBy: string
  ##          : Return issues ordered by `created_at` or `updated_at` fields.
  ##   sort: string
  ##       : Return issues sorted in `asc` or `desc` order.
  var path_759328 = newJObject()
  var query_759329 = newJObject()
  add(query_759329, "labels", newJString(labels))
  add(path_759328, "id", newJString(id))
  add(query_759329, "state", newJString(state))
  add(query_759329, "per_page", newJInt(perPage))
  add(query_759329, "page", newJInt(page))
  add(query_759329, "milestone", newJString(milestone))
  add(query_759329, "order_by", newJString(orderBy))
  add(query_759329, "sort", newJString(sort))
  result = call_759327.call(path_759328, query_759329, nil, nil, nil)

var getV3GroupsIdIssues* = Call_GetV3GroupsIdIssues_759315(
    name: "getV3GroupsIdIssues", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/groups/{id}/issues", validator: validate_GetV3GroupsIdIssues_759316,
    base: "/api", url: url_GetV3GroupsIdIssues_759317, schemes: {Scheme.Https})
type
  Call_PostV3GroupsIdMembers_759341 = ref object of OpenApiRestCall_758573
proc url_PostV3GroupsIdMembers_759343(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3GroupsIdMembers_759342(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a member to a group or project.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759344 = path.getOrDefault("id")
  valid_759344 = validateParameter(valid_759344, JString, required = true,
                                 default = nil)
  if valid_759344 != nil:
    section.add "id", valid_759344
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   access_level: JInt (required)
  ##               : A valid access level (defaults: `30`, developer access level)
  ##   expires_at: JString
  ##             : Date string in the format YEAR-MONTH-DAY
  ##   user_id: JInt (required)
  ##          : The user ID of the new member
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `access_level` field"
  var valid_759345 = formData.getOrDefault("access_level")
  valid_759345 = validateParameter(valid_759345, JInt, required = true, default = nil)
  if valid_759345 != nil:
    section.add "access_level", valid_759345
  var valid_759346 = formData.getOrDefault("expires_at")
  valid_759346 = validateParameter(valid_759346, JString, required = false,
                                 default = nil)
  if valid_759346 != nil:
    section.add "expires_at", valid_759346
  var valid_759347 = formData.getOrDefault("user_id")
  valid_759347 = validateParameter(valid_759347, JInt, required = true, default = nil)
  if valid_759347 != nil:
    section.add "user_id", valid_759347
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759348: Call_PostV3GroupsIdMembers_759341; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a member to a group or project.
  ## 
  let valid = call_759348.validator(path, query, header, formData, body)
  let scheme = call_759348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759348.url(scheme.get, call_759348.host, call_759348.base,
                         call_759348.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759348, url, valid)

proc call*(call_759349: Call_PostV3GroupsIdMembers_759341; accessLevel: int;
          id: string; userId: int; expiresAt: string = ""): Recallable =
  ## postV3GroupsIdMembers
  ## Adds a member to a group or project.
  ##   accessLevel: int (required)
  ##              : A valid access level (defaults: `30`, developer access level)
  ##   id: string (required)
  ##     : The group ID
  ##   expiresAt: string
  ##            : Date string in the format YEAR-MONTH-DAY
  ##   userId: int (required)
  ##         : The user ID of the new member
  var path_759350 = newJObject()
  var formData_759351 = newJObject()
  add(formData_759351, "access_level", newJInt(accessLevel))
  add(path_759350, "id", newJString(id))
  add(formData_759351, "expires_at", newJString(expiresAt))
  add(formData_759351, "user_id", newJInt(userId))
  result = call_759349.call(path_759350, nil, nil, formData_759351, nil)

var postV3GroupsIdMembers* = Call_PostV3GroupsIdMembers_759341(
    name: "postV3GroupsIdMembers", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/groups/{id}/members", validator: validate_PostV3GroupsIdMembers_759342,
    base: "/api", url: url_PostV3GroupsIdMembers_759343, schemes: {Scheme.Https})
type
  Call_GetV3GroupsIdMembers_759330 = ref object of OpenApiRestCall_758573
proc url_GetV3GroupsIdMembers_759332(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3GroupsIdMembers_759331(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of group or project members viewable by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759333 = path.getOrDefault("id")
  valid_759333 = validateParameter(valid_759333, JString, required = true,
                                 default = nil)
  if valid_759333 != nil:
    section.add "id", valid_759333
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   query: JString
  ##        : A query string to search for members
  section = newJObject()
  var valid_759334 = query.getOrDefault("per_page")
  valid_759334 = validateParameter(valid_759334, JInt, required = false, default = nil)
  if valid_759334 != nil:
    section.add "per_page", valid_759334
  var valid_759335 = query.getOrDefault("page")
  valid_759335 = validateParameter(valid_759335, JInt, required = false, default = nil)
  if valid_759335 != nil:
    section.add "page", valid_759335
  var valid_759336 = query.getOrDefault("query")
  valid_759336 = validateParameter(valid_759336, JString, required = false,
                                 default = nil)
  if valid_759336 != nil:
    section.add "query", valid_759336
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759337: Call_GetV3GroupsIdMembers_759330; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of group or project members viewable by the authenticated user.
  ## 
  let valid = call_759337.validator(path, query, header, formData, body)
  let scheme = call_759337.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759337.url(scheme.get, call_759337.host, call_759337.base,
                         call_759337.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759337, url, valid)

proc call*(call_759338: Call_GetV3GroupsIdMembers_759330; id: string;
          perPage: int = 0; page: int = 0; query: string = ""): Recallable =
  ## getV3GroupsIdMembers
  ## Gets a list of group or project members viewable by the authenticated user.
  ##   id: string (required)
  ##     : The group ID
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   query: string
  ##        : A query string to search for members
  var path_759339 = newJObject()
  var query_759340 = newJObject()
  add(path_759339, "id", newJString(id))
  add(query_759340, "per_page", newJInt(perPage))
  add(query_759340, "page", newJInt(page))
  add(query_759340, "query", newJString(query))
  result = call_759338.call(path_759339, query_759340, nil, nil, nil)

var getV3GroupsIdMembers* = Call_GetV3GroupsIdMembers_759330(
    name: "getV3GroupsIdMembers", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/groups/{id}/members", validator: validate_GetV3GroupsIdMembers_759331,
    base: "/api", url: url_GetV3GroupsIdMembers_759332, schemes: {Scheme.Https})
type
  Call_PutV3GroupsIdMembersUserId_759360 = ref object of OpenApiRestCall_758573
proc url_PutV3GroupsIdMembersUserId_759362(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "user_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3GroupsIdMembersUserId_759361(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a member of a group or project.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID
  ##   user_id: JInt (required)
  ##          : The user ID of the new member
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759363 = path.getOrDefault("id")
  valid_759363 = validateParameter(valid_759363, JString, required = true,
                                 default = nil)
  if valid_759363 != nil:
    section.add "id", valid_759363
  var valid_759364 = path.getOrDefault("user_id")
  valid_759364 = validateParameter(valid_759364, JInt, required = true, default = nil)
  if valid_759364 != nil:
    section.add "user_id", valid_759364
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   access_level: JInt (required)
  ##               : A valid access level
  ##   expires_at: JString
  ##             : Date string in the format YEAR-MONTH-DAY
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `access_level` field"
  var valid_759365 = formData.getOrDefault("access_level")
  valid_759365 = validateParameter(valid_759365, JInt, required = true, default = nil)
  if valid_759365 != nil:
    section.add "access_level", valid_759365
  var valid_759366 = formData.getOrDefault("expires_at")
  valid_759366 = validateParameter(valid_759366, JString, required = false,
                                 default = nil)
  if valid_759366 != nil:
    section.add "expires_at", valid_759366
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759367: Call_PutV3GroupsIdMembersUserId_759360; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a member of a group or project.
  ## 
  let valid = call_759367.validator(path, query, header, formData, body)
  let scheme = call_759367.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759367.url(scheme.get, call_759367.host, call_759367.base,
                         call_759367.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759367, url, valid)

proc call*(call_759368: Call_PutV3GroupsIdMembersUserId_759360; accessLevel: int;
          id: string; userId: int; expiresAt: string = ""): Recallable =
  ## putV3GroupsIdMembersUserId
  ## Updates a member of a group or project.
  ##   accessLevel: int (required)
  ##              : A valid access level
  ##   id: string (required)
  ##     : The group ID
  ##   expiresAt: string
  ##            : Date string in the format YEAR-MONTH-DAY
  ##   userId: int (required)
  ##         : The user ID of the new member
  var path_759369 = newJObject()
  var formData_759370 = newJObject()
  add(formData_759370, "access_level", newJInt(accessLevel))
  add(path_759369, "id", newJString(id))
  add(formData_759370, "expires_at", newJString(expiresAt))
  add(path_759369, "user_id", newJInt(userId))
  result = call_759368.call(path_759369, nil, nil, formData_759370, nil)

var putV3GroupsIdMembersUserId* = Call_PutV3GroupsIdMembersUserId_759360(
    name: "putV3GroupsIdMembersUserId", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/groups/{id}/members/{user_id}",
    validator: validate_PutV3GroupsIdMembersUserId_759361, base: "/api",
    url: url_PutV3GroupsIdMembersUserId_759362, schemes: {Scheme.Https})
type
  Call_GetV3GroupsIdMembersUserId_759352 = ref object of OpenApiRestCall_758573
proc url_GetV3GroupsIdMembersUserId_759354(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "user_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3GroupsIdMembersUserId_759353(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a member of a group or project.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID
  ##   user_id: JInt (required)
  ##          : The user ID of the member
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759355 = path.getOrDefault("id")
  valid_759355 = validateParameter(valid_759355, JString, required = true,
                                 default = nil)
  if valid_759355 != nil:
    section.add "id", valid_759355
  var valid_759356 = path.getOrDefault("user_id")
  valid_759356 = validateParameter(valid_759356, JInt, required = true, default = nil)
  if valid_759356 != nil:
    section.add "user_id", valid_759356
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759357: Call_GetV3GroupsIdMembersUserId_759352; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a member of a group or project.
  ## 
  let valid = call_759357.validator(path, query, header, formData, body)
  let scheme = call_759357.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759357.url(scheme.get, call_759357.host, call_759357.base,
                         call_759357.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759357, url, valid)

proc call*(call_759358: Call_GetV3GroupsIdMembersUserId_759352; id: string;
          userId: int): Recallable =
  ## getV3GroupsIdMembersUserId
  ## Gets a member of a group or project.
  ##   id: string (required)
  ##     : The group ID
  ##   userId: int (required)
  ##         : The user ID of the member
  var path_759359 = newJObject()
  add(path_759359, "id", newJString(id))
  add(path_759359, "user_id", newJInt(userId))
  result = call_759358.call(path_759359, nil, nil, nil, nil)

var getV3GroupsIdMembersUserId* = Call_GetV3GroupsIdMembersUserId_759352(
    name: "getV3GroupsIdMembersUserId", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/groups/{id}/members/{user_id}",
    validator: validate_GetV3GroupsIdMembersUserId_759353, base: "/api",
    url: url_GetV3GroupsIdMembersUserId_759354, schemes: {Scheme.Https})
type
  Call_DeleteV3GroupsIdMembersUserId_759371 = ref object of OpenApiRestCall_758573
proc url_DeleteV3GroupsIdMembersUserId_759373(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "user_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3GroupsIdMembersUserId_759372(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes a user from a group or project.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID
  ##   user_id: JInt (required)
  ##          : The user ID of the member
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759374 = path.getOrDefault("id")
  valid_759374 = validateParameter(valid_759374, JString, required = true,
                                 default = nil)
  if valid_759374 != nil:
    section.add "id", valid_759374
  var valid_759375 = path.getOrDefault("user_id")
  valid_759375 = validateParameter(valid_759375, JInt, required = true, default = nil)
  if valid_759375 != nil:
    section.add "user_id", valid_759375
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759376: Call_DeleteV3GroupsIdMembersUserId_759371; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes a user from a group or project.
  ## 
  let valid = call_759376.validator(path, query, header, formData, body)
  let scheme = call_759376.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759376.url(scheme.get, call_759376.host, call_759376.base,
                         call_759376.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759376, url, valid)

proc call*(call_759377: Call_DeleteV3GroupsIdMembersUserId_759371; id: string;
          userId: int): Recallable =
  ## deleteV3GroupsIdMembersUserId
  ## Removes a user from a group or project.
  ##   id: string (required)
  ##     : The group ID
  ##   userId: int (required)
  ##         : The user ID of the member
  var path_759378 = newJObject()
  add(path_759378, "id", newJString(id))
  add(path_759378, "user_id", newJInt(userId))
  result = call_759377.call(path_759378, nil, nil, nil, nil)

var deleteV3GroupsIdMembersUserId* = Call_DeleteV3GroupsIdMembersUserId_759371(
    name: "deleteV3GroupsIdMembersUserId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/groups/{id}/members/{user_id}",
    validator: validate_DeleteV3GroupsIdMembersUserId_759372, base: "/api",
    url: url_DeleteV3GroupsIdMembersUserId_759373, schemes: {Scheme.Https})
type
  Call_PutV3GroupsIdNotificationSettings_759386 = ref object of OpenApiRestCall_758573
proc url_PutV3GroupsIdNotificationSettings_759388(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/notification_settings")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3GroupsIdNotificationSettings_759387(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.12
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID or project ID or project NAMESPACE/PROJECT_NAME
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759389 = path.getOrDefault("id")
  valid_759389 = validateParameter(valid_759389, JString, required = true,
                                 default = nil)
  if valid_759389 != nil:
    section.add "id", valid_759389
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   failed_pipeline: JBool
  ##                  : Enable/disable this notification
  ##   reopen_issue: JBool
  ##               : Enable/disable this notification
  ##   reassign_issue: JBool
  ##                 : Enable/disable this notification
  ##   reopen_merge_request: JBool
  ##                       : Enable/disable this notification
  ##   new_note: JBool
  ##           : Enable/disable this notification
  ##   success_pipeline: JBool
  ##                   : Enable/disable this notification
  ##   new_issue: JBool
  ##            : Enable/disable this notification
  ##   new_merge_request: JBool
  ##                    : Enable/disable this notification
  ##   level: JString
  ##        : The group notification level
  ##   close_issue: JBool
  ##              : Enable/disable this notification
  ##   reassign_merge_request: JBool
  ##                         : Enable/disable this notification
  ##   close_merge_request: JBool
  ##                      : Enable/disable this notification
  ##   merge_merge_request: JBool
  ##                      : Enable/disable this notification
  section = newJObject()
  var valid_759390 = formData.getOrDefault("failed_pipeline")
  valid_759390 = validateParameter(valid_759390, JBool, required = false, default = nil)
  if valid_759390 != nil:
    section.add "failed_pipeline", valid_759390
  var valid_759391 = formData.getOrDefault("reopen_issue")
  valid_759391 = validateParameter(valid_759391, JBool, required = false, default = nil)
  if valid_759391 != nil:
    section.add "reopen_issue", valid_759391
  var valid_759392 = formData.getOrDefault("reassign_issue")
  valid_759392 = validateParameter(valid_759392, JBool, required = false, default = nil)
  if valid_759392 != nil:
    section.add "reassign_issue", valid_759392
  var valid_759393 = formData.getOrDefault("reopen_merge_request")
  valid_759393 = validateParameter(valid_759393, JBool, required = false, default = nil)
  if valid_759393 != nil:
    section.add "reopen_merge_request", valid_759393
  var valid_759394 = formData.getOrDefault("new_note")
  valid_759394 = validateParameter(valid_759394, JBool, required = false, default = nil)
  if valid_759394 != nil:
    section.add "new_note", valid_759394
  var valid_759395 = formData.getOrDefault("success_pipeline")
  valid_759395 = validateParameter(valid_759395, JBool, required = false, default = nil)
  if valid_759395 != nil:
    section.add "success_pipeline", valid_759395
  var valid_759396 = formData.getOrDefault("new_issue")
  valid_759396 = validateParameter(valid_759396, JBool, required = false, default = nil)
  if valid_759396 != nil:
    section.add "new_issue", valid_759396
  var valid_759397 = formData.getOrDefault("new_merge_request")
  valid_759397 = validateParameter(valid_759397, JBool, required = false, default = nil)
  if valid_759397 != nil:
    section.add "new_merge_request", valid_759397
  var valid_759398 = formData.getOrDefault("level")
  valid_759398 = validateParameter(valid_759398, JString, required = false,
                                 default = nil)
  if valid_759398 != nil:
    section.add "level", valid_759398
  var valid_759399 = formData.getOrDefault("close_issue")
  valid_759399 = validateParameter(valid_759399, JBool, required = false, default = nil)
  if valid_759399 != nil:
    section.add "close_issue", valid_759399
  var valid_759400 = formData.getOrDefault("reassign_merge_request")
  valid_759400 = validateParameter(valid_759400, JBool, required = false, default = nil)
  if valid_759400 != nil:
    section.add "reassign_merge_request", valid_759400
  var valid_759401 = formData.getOrDefault("close_merge_request")
  valid_759401 = validateParameter(valid_759401, JBool, required = false, default = nil)
  if valid_759401 != nil:
    section.add "close_merge_request", valid_759401
  var valid_759402 = formData.getOrDefault("merge_merge_request")
  valid_759402 = validateParameter(valid_759402, JBool, required = false, default = nil)
  if valid_759402 != nil:
    section.add "merge_merge_request", valid_759402
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759403: Call_PutV3GroupsIdNotificationSettings_759386;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.12
  ## 
  let valid = call_759403.validator(path, query, header, formData, body)
  let scheme = call_759403.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759403.url(scheme.get, call_759403.host, call_759403.base,
                         call_759403.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759403, url, valid)

proc call*(call_759404: Call_PutV3GroupsIdNotificationSettings_759386; id: string;
          failedPipeline: bool = false; reopenIssue: bool = false;
          reassignIssue: bool = false; reopenMergeRequest: bool = false;
          newNote: bool = false; successPipeline: bool = false; newIssue: bool = false;
          newMergeRequest: bool = false; level: string = ""; closeIssue: bool = false;
          reassignMergeRequest: bool = false; closeMergeRequest: bool = false;
          mergeMergeRequest: bool = false): Recallable =
  ## putV3GroupsIdNotificationSettings
  ## This feature was introduced in GitLab 8.12
  ##   failedPipeline: bool
  ##                 : Enable/disable this notification
  ##   id: string (required)
  ##     : The group ID or project ID or project NAMESPACE/PROJECT_NAME
  ##   reopenIssue: bool
  ##              : Enable/disable this notification
  ##   reassignIssue: bool
  ##                : Enable/disable this notification
  ##   reopenMergeRequest: bool
  ##                     : Enable/disable this notification
  ##   newNote: bool
  ##          : Enable/disable this notification
  ##   successPipeline: bool
  ##                  : Enable/disable this notification
  ##   newIssue: bool
  ##           : Enable/disable this notification
  ##   newMergeRequest: bool
  ##                  : Enable/disable this notification
  ##   level: string
  ##        : The group notification level
  ##   closeIssue: bool
  ##             : Enable/disable this notification
  ##   reassignMergeRequest: bool
  ##                       : Enable/disable this notification
  ##   closeMergeRequest: bool
  ##                    : Enable/disable this notification
  ##   mergeMergeRequest: bool
  ##                    : Enable/disable this notification
  var path_759405 = newJObject()
  var formData_759406 = newJObject()
  add(formData_759406, "failed_pipeline", newJBool(failedPipeline))
  add(path_759405, "id", newJString(id))
  add(formData_759406, "reopen_issue", newJBool(reopenIssue))
  add(formData_759406, "reassign_issue", newJBool(reassignIssue))
  add(formData_759406, "reopen_merge_request", newJBool(reopenMergeRequest))
  add(formData_759406, "new_note", newJBool(newNote))
  add(formData_759406, "success_pipeline", newJBool(successPipeline))
  add(formData_759406, "new_issue", newJBool(newIssue))
  add(formData_759406, "new_merge_request", newJBool(newMergeRequest))
  add(formData_759406, "level", newJString(level))
  add(formData_759406, "close_issue", newJBool(closeIssue))
  add(formData_759406, "reassign_merge_request", newJBool(reassignMergeRequest))
  add(formData_759406, "close_merge_request", newJBool(closeMergeRequest))
  add(formData_759406, "merge_merge_request", newJBool(mergeMergeRequest))
  result = call_759404.call(path_759405, nil, nil, formData_759406, nil)

var putV3GroupsIdNotificationSettings* = Call_PutV3GroupsIdNotificationSettings_759386(
    name: "putV3GroupsIdNotificationSettings", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/groups/{id}/notification_settings",
    validator: validate_PutV3GroupsIdNotificationSettings_759387, base: "/api",
    url: url_PutV3GroupsIdNotificationSettings_759388, schemes: {Scheme.Https})
type
  Call_GetV3GroupsIdNotificationSettings_759379 = ref object of OpenApiRestCall_758573
proc url_GetV3GroupsIdNotificationSettings_759381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/notification_settings")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3GroupsIdNotificationSettings_759380(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.12
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID or project ID or project NAMESPACE/PROJECT_NAME
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759382 = path.getOrDefault("id")
  valid_759382 = validateParameter(valid_759382, JString, required = true,
                                 default = nil)
  if valid_759382 != nil:
    section.add "id", valid_759382
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759383: Call_GetV3GroupsIdNotificationSettings_759379;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.12
  ## 
  let valid = call_759383.validator(path, query, header, formData, body)
  let scheme = call_759383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759383.url(scheme.get, call_759383.host, call_759383.base,
                         call_759383.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759383, url, valid)

proc call*(call_759384: Call_GetV3GroupsIdNotificationSettings_759379; id: string): Recallable =
  ## getV3GroupsIdNotificationSettings
  ## This feature was introduced in GitLab 8.12
  ##   id: string (required)
  ##     : The group ID or project ID or project NAMESPACE/PROJECT_NAME
  var path_759385 = newJObject()
  add(path_759385, "id", newJString(id))
  result = call_759384.call(path_759385, nil, nil, nil, nil)

var getV3GroupsIdNotificationSettings* = Call_GetV3GroupsIdNotificationSettings_759379(
    name: "getV3GroupsIdNotificationSettings", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/groups/{id}/notification_settings",
    validator: validate_GetV3GroupsIdNotificationSettings_759380, base: "/api",
    url: url_GetV3GroupsIdNotificationSettings_759381, schemes: {Scheme.Https})
type
  Call_GetV3GroupsIdProjects_759407 = ref object of OpenApiRestCall_758573
proc url_GetV3GroupsIdProjects_759409(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/projects")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3GroupsIdProjects_759408(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a list of projects in this group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a group
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759410 = path.getOrDefault("id")
  valid_759410 = validateParameter(valid_759410, JString, required = true,
                                 default = nil)
  if valid_759410 != nil:
    section.add "id", valid_759410
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   archived: JBool
  ##           : Limit by archived status
  ##   page: JInt
  ##       : Current page number
  ##   simple: JBool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: JString
  ##             : Limit by visibility
  ##   search: JString
  ##         : Return list of authorized projects matching the search criteria
  ##   order_by: JString
  ##           : Return projects ordered by field
  ##   sort: JString
  ##       : Return projects sorted in ascending and descending order
  section = newJObject()
  var valid_759411 = query.getOrDefault("per_page")
  valid_759411 = validateParameter(valid_759411, JInt, required = false, default = nil)
  if valid_759411 != nil:
    section.add "per_page", valid_759411
  var valid_759412 = query.getOrDefault("archived")
  valid_759412 = validateParameter(valid_759412, JBool, required = false, default = nil)
  if valid_759412 != nil:
    section.add "archived", valid_759412
  var valid_759413 = query.getOrDefault("page")
  valid_759413 = validateParameter(valid_759413, JInt, required = false, default = nil)
  if valid_759413 != nil:
    section.add "page", valid_759413
  var valid_759414 = query.getOrDefault("simple")
  valid_759414 = validateParameter(valid_759414, JBool, required = false, default = nil)
  if valid_759414 != nil:
    section.add "simple", valid_759414
  var valid_759415 = query.getOrDefault("visibility")
  valid_759415 = validateParameter(valid_759415, JString, required = false,
                                 default = newJString("public"))
  if valid_759415 != nil:
    section.add "visibility", valid_759415
  var valid_759416 = query.getOrDefault("search")
  valid_759416 = validateParameter(valid_759416, JString, required = false,
                                 default = nil)
  if valid_759416 != nil:
    section.add "search", valid_759416
  var valid_759417 = query.getOrDefault("order_by")
  valid_759417 = validateParameter(valid_759417, JString, required = false,
                                 default = newJString("created_at"))
  if valid_759417 != nil:
    section.add "order_by", valid_759417
  var valid_759418 = query.getOrDefault("sort")
  valid_759418 = validateParameter(valid_759418, JString, required = false,
                                 default = newJString("desc"))
  if valid_759418 != nil:
    section.add "sort", valid_759418
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759419: Call_GetV3GroupsIdProjects_759407; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a list of projects in this group.
  ## 
  let valid = call_759419.validator(path, query, header, formData, body)
  let scheme = call_759419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759419.url(scheme.get, call_759419.host, call_759419.base,
                         call_759419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759419, url, valid)

proc call*(call_759420: Call_GetV3GroupsIdProjects_759407; id: string;
          perPage: int = 0; archived: bool = false; page: int = 0; simple: bool = false;
          visibility: string = "public"; search: string = "";
          orderBy: string = "created_at"; sort: string = "desc"): Recallable =
  ## getV3GroupsIdProjects
  ## Get a list of projects in this group.
  ##   id: string (required)
  ##     : The ID of a group
  ##   perPage: int
  ##          : Number of items per page
  ##   archived: bool
  ##           : Limit by archived status
  ##   page: int
  ##       : Current page number
  ##   simple: bool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: string
  ##             : Limit by visibility
  ##   search: string
  ##         : Return list of authorized projects matching the search criteria
  ##   orderBy: string
  ##          : Return projects ordered by field
  ##   sort: string
  ##       : Return projects sorted in ascending and descending order
  var path_759421 = newJObject()
  var query_759422 = newJObject()
  add(path_759421, "id", newJString(id))
  add(query_759422, "per_page", newJInt(perPage))
  add(query_759422, "archived", newJBool(archived))
  add(query_759422, "page", newJInt(page))
  add(query_759422, "simple", newJBool(simple))
  add(query_759422, "visibility", newJString(visibility))
  add(query_759422, "search", newJString(search))
  add(query_759422, "order_by", newJString(orderBy))
  add(query_759422, "sort", newJString(sort))
  result = call_759420.call(path_759421, query_759422, nil, nil, nil)

var getV3GroupsIdProjects* = Call_GetV3GroupsIdProjects_759407(
    name: "getV3GroupsIdProjects", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/groups/{id}/projects", validator: validate_GetV3GroupsIdProjects_759408,
    base: "/api", url: url_GetV3GroupsIdProjects_759409, schemes: {Scheme.Https})
type
  Call_PostV3GroupsIdProjectsProjectId_759423 = ref object of OpenApiRestCall_758573
proc url_PostV3GroupsIdProjectsProjectId_759425(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "project_id" in path, "`project_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/groups/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/projects/"),
               (kind: VariableSegment, value: "project_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3GroupsIdProjectsProjectId_759424(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Transfer a project to the group namespace. Available only for admin.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a group
  ##   project_id: JString (required)
  ##             : The ID or path of the project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759426 = path.getOrDefault("id")
  valid_759426 = validateParameter(valid_759426, JString, required = true,
                                 default = nil)
  if valid_759426 != nil:
    section.add "id", valid_759426
  var valid_759427 = path.getOrDefault("project_id")
  valid_759427 = validateParameter(valid_759427, JString, required = true,
                                 default = nil)
  if valid_759427 != nil:
    section.add "project_id", valid_759427
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759428: Call_PostV3GroupsIdProjectsProjectId_759423;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Transfer a project to the group namespace. Available only for admin.
  ## 
  let valid = call_759428.validator(path, query, header, formData, body)
  let scheme = call_759428.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759428.url(scheme.get, call_759428.host, call_759428.base,
                         call_759428.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759428, url, valid)

proc call*(call_759429: Call_PostV3GroupsIdProjectsProjectId_759423; id: string;
          projectId: string): Recallable =
  ## postV3GroupsIdProjectsProjectId
  ## Transfer a project to the group namespace. Available only for admin.
  ##   id: string (required)
  ##     : The ID of a group
  ##   projectId: string (required)
  ##            : The ID or path of the project
  var path_759430 = newJObject()
  add(path_759430, "id", newJString(id))
  add(path_759430, "project_id", newJString(projectId))
  result = call_759429.call(path_759430, nil, nil, nil, nil)

var postV3GroupsIdProjectsProjectId* = Call_PostV3GroupsIdProjectsProjectId_759423(
    name: "postV3GroupsIdProjectsProjectId", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/groups/{id}/projects/{project_id}",
    validator: validate_PostV3GroupsIdProjectsProjectId_759424, base: "/api",
    url: url_PostV3GroupsIdProjectsProjectId_759425, schemes: {Scheme.Https})
type
  Call_PostV3Hooks_759436 = ref object of OpenApiRestCall_758573
proc url_PostV3Hooks_759438(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3Hooks_759437(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new system hook
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   enable_ssl_verification: JBool
  ##                          : Do SSL verification when triggering the hook
  ##   url: JString (required)
  ##      : The URL to send the request to
  ##   token: JString
  ##        : The token used to validate payloads
  ##   push_events: JBool
  ##              : Trigger hook on push events
  ##   tag_push_events: JBool
  ##                  : Trigger hook on tag push events
  section = newJObject()
  var valid_759439 = formData.getOrDefault("enable_ssl_verification")
  valid_759439 = validateParameter(valid_759439, JBool, required = false, default = nil)
  if valid_759439 != nil:
    section.add "enable_ssl_verification", valid_759439
  assert formData != nil,
        "formData argument is necessary due to required `url` field"
  var valid_759440 = formData.getOrDefault("url")
  valid_759440 = validateParameter(valid_759440, JString, required = true,
                                 default = nil)
  if valid_759440 != nil:
    section.add "url", valid_759440
  var valid_759441 = formData.getOrDefault("token")
  valid_759441 = validateParameter(valid_759441, JString, required = false,
                                 default = nil)
  if valid_759441 != nil:
    section.add "token", valid_759441
  var valid_759442 = formData.getOrDefault("push_events")
  valid_759442 = validateParameter(valid_759442, JBool, required = false, default = nil)
  if valid_759442 != nil:
    section.add "push_events", valid_759442
  var valid_759443 = formData.getOrDefault("tag_push_events")
  valid_759443 = validateParameter(valid_759443, JBool, required = false, default = nil)
  if valid_759443 != nil:
    section.add "tag_push_events", valid_759443
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759444: Call_PostV3Hooks_759436; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new system hook
  ## 
  let valid = call_759444.validator(path, query, header, formData, body)
  let scheme = call_759444.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759444.url(scheme.get, call_759444.host, call_759444.base,
                         call_759444.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759444, url, valid)

proc call*(call_759445: Call_PostV3Hooks_759436; url: string;
          enableSslVerification: bool = false; token: string = "";
          pushEvents: bool = false; tagPushEvents: bool = false): Recallable =
  ## postV3Hooks
  ## Create a new system hook
  ##   enableSslVerification: bool
  ##                        : Do SSL verification when triggering the hook
  ##   url: string (required)
  ##      : The URL to send the request to
  ##   token: string
  ##        : The token used to validate payloads
  ##   pushEvents: bool
  ##             : Trigger hook on push events
  ##   tagPushEvents: bool
  ##                : Trigger hook on tag push events
  var formData_759446 = newJObject()
  add(formData_759446, "enable_ssl_verification", newJBool(enableSslVerification))
  add(formData_759446, "url", newJString(url))
  add(formData_759446, "token", newJString(token))
  add(formData_759446, "push_events", newJBool(pushEvents))
  add(formData_759446, "tag_push_events", newJBool(tagPushEvents))
  result = call_759445.call(nil, nil, nil, formData_759446, nil)

var postV3Hooks* = Call_PostV3Hooks_759436(name: "postV3Hooks",
                                        meth: HttpMethod.HttpPost,
                                        host: "gitlab.com", route: "/v3/hooks",
                                        validator: validate_PostV3Hooks_759437,
                                        base: "/api", url: url_PostV3Hooks_759438,
                                        schemes: {Scheme.Https})
type
  Call_GetV3Hooks_759431 = ref object of OpenApiRestCall_758573
proc url_GetV3Hooks_759433(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Hooks_759432(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the list of system hooks
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759434: Call_GetV3Hooks_759431; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the list of system hooks
  ## 
  let valid = call_759434.validator(path, query, header, formData, body)
  let scheme = call_759434.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759434.url(scheme.get, call_759434.host, call_759434.base,
                         call_759434.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759434, url, valid)

proc call*(call_759435: Call_GetV3Hooks_759431): Recallable =
  ## getV3Hooks
  ## Get the list of system hooks
  result = call_759435.call(nil, nil, nil, nil, nil)

var getV3Hooks* = Call_GetV3Hooks_759431(name: "getV3Hooks",
                                      meth: HttpMethod.HttpGet,
                                      host: "gitlab.com", route: "/v3/hooks",
                                      validator: validate_GetV3Hooks_759432,
                                      base: "/api", url: url_GetV3Hooks_759433,
                                      schemes: {Scheme.Https})
type
  Call_GetV3HooksId_759447 = ref object of OpenApiRestCall_758573
proc url_GetV3HooksId_759449(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/hooks/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3HooksId_759448(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Test a hook
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the system hook
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759450 = path.getOrDefault("id")
  valid_759450 = validateParameter(valid_759450, JInt, required = true, default = nil)
  if valid_759450 != nil:
    section.add "id", valid_759450
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759451: Call_GetV3HooksId_759447; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Test a hook
  ## 
  let valid = call_759451.validator(path, query, header, formData, body)
  let scheme = call_759451.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759451.url(scheme.get, call_759451.host, call_759451.base,
                         call_759451.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759451, url, valid)

proc call*(call_759452: Call_GetV3HooksId_759447; id: int): Recallable =
  ## getV3HooksId
  ## Test a hook
  ##   id: int (required)
  ##     : The ID of the system hook
  var path_759453 = newJObject()
  add(path_759453, "id", newJInt(id))
  result = call_759452.call(path_759453, nil, nil, nil, nil)

var getV3HooksId* = Call_GetV3HooksId_759447(name: "getV3HooksId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/hooks/{id}",
    validator: validate_GetV3HooksId_759448, base: "/api", url: url_GetV3HooksId_759449,
    schemes: {Scheme.Https})
type
  Call_DeleteV3HooksId_759454 = ref object of OpenApiRestCall_758573
proc url_DeleteV3HooksId_759456(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/hooks/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3HooksId_759455(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete a hook
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the system hook
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759457 = path.getOrDefault("id")
  valid_759457 = validateParameter(valid_759457, JInt, required = true, default = nil)
  if valid_759457 != nil:
    section.add "id", valid_759457
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759458: Call_DeleteV3HooksId_759454; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a hook
  ## 
  let valid = call_759458.validator(path, query, header, formData, body)
  let scheme = call_759458.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759458.url(scheme.get, call_759458.host, call_759458.base,
                         call_759458.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759458, url, valid)

proc call*(call_759459: Call_DeleteV3HooksId_759454; id: int): Recallable =
  ## deleteV3HooksId
  ## Delete a hook
  ##   id: int (required)
  ##     : The ID of the system hook
  var path_759460 = newJObject()
  add(path_759460, "id", newJInt(id))
  result = call_759459.call(path_759460, nil, nil, nil, nil)

var deleteV3HooksId* = Call_DeleteV3HooksId_759454(name: "deleteV3HooksId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com", route: "/v3/hooks/{id}",
    validator: validate_DeleteV3HooksId_759455, base: "/api",
    url: url_DeleteV3HooksId_759456, schemes: {Scheme.Https})
type
  Call_PostV3InternalAllowed_759461 = ref object of OpenApiRestCall_758573
proc url_PostV3InternalAllowed_759463(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3InternalAllowed_759462(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759464: Call_PostV3InternalAllowed_759461; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  let valid = call_759464.validator(path, query, header, formData, body)
  let scheme = call_759464.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759464.url(scheme.get, call_759464.host, call_759464.base,
                         call_759464.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759464, url, valid)

proc call*(call_759465: Call_PostV3InternalAllowed_759461): Recallable =
  ## postV3InternalAllowed
  result = call_759465.call(nil, nil, nil, nil, nil)

var postV3InternalAllowed* = Call_PostV3InternalAllowed_759461(
    name: "postV3InternalAllowed", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/internal/allowed", validator: validate_PostV3InternalAllowed_759462,
    base: "/api", url: url_PostV3InternalAllowed_759463, schemes: {Scheme.Https})
type
  Call_GetV3InternalBroadcastMessage_759466 = ref object of OpenApiRestCall_758573
proc url_GetV3InternalBroadcastMessage_759468(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3InternalBroadcastMessage_759467(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759469: Call_GetV3InternalBroadcastMessage_759466; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  let valid = call_759469.validator(path, query, header, formData, body)
  let scheme = call_759469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759469.url(scheme.get, call_759469.host, call_759469.base,
                         call_759469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759469, url, valid)

proc call*(call_759470: Call_GetV3InternalBroadcastMessage_759466): Recallable =
  ## getV3InternalBroadcastMessage
  result = call_759470.call(nil, nil, nil, nil, nil)

var getV3InternalBroadcastMessage* = Call_GetV3InternalBroadcastMessage_759466(
    name: "getV3InternalBroadcastMessage", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/internal/broadcast_message",
    validator: validate_GetV3InternalBroadcastMessage_759467, base: "/api",
    url: url_GetV3InternalBroadcastMessage_759468, schemes: {Scheme.Https})
type
  Call_GetV3InternalCheck_759471 = ref object of OpenApiRestCall_758573
proc url_GetV3InternalCheck_759473(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3InternalCheck_759472(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759474: Call_GetV3InternalCheck_759471; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  let valid = call_759474.validator(path, query, header, formData, body)
  let scheme = call_759474.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759474.url(scheme.get, call_759474.host, call_759474.base,
                         call_759474.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759474, url, valid)

proc call*(call_759475: Call_GetV3InternalCheck_759471): Recallable =
  ## getV3InternalCheck
  result = call_759475.call(nil, nil, nil, nil, nil)

var getV3InternalCheck* = Call_GetV3InternalCheck_759471(
    name: "getV3InternalCheck", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/internal/check", validator: validate_GetV3InternalCheck_759472,
    base: "/api", url: url_GetV3InternalCheck_759473, schemes: {Scheme.Https})
type
  Call_GetV3InternalDiscover_759476 = ref object of OpenApiRestCall_758573
proc url_GetV3InternalDiscover_759478(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3InternalDiscover_759477(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759479: Call_GetV3InternalDiscover_759476; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  let valid = call_759479.validator(path, query, header, formData, body)
  let scheme = call_759479.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759479.url(scheme.get, call_759479.host, call_759479.base,
                         call_759479.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759479, url, valid)

proc call*(call_759480: Call_GetV3InternalDiscover_759476): Recallable =
  ## getV3InternalDiscover
  result = call_759480.call(nil, nil, nil, nil, nil)

var getV3InternalDiscover* = Call_GetV3InternalDiscover_759476(
    name: "getV3InternalDiscover", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/internal/discover", validator: validate_GetV3InternalDiscover_759477,
    base: "/api", url: url_GetV3InternalDiscover_759478, schemes: {Scheme.Https})
type
  Call_PostV3InternalLfsAuthenticate_759481 = ref object of OpenApiRestCall_758573
proc url_PostV3InternalLfsAuthenticate_759483(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3InternalLfsAuthenticate_759482(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759484: Call_PostV3InternalLfsAuthenticate_759481; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  let valid = call_759484.validator(path, query, header, formData, body)
  let scheme = call_759484.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759484.url(scheme.get, call_759484.host, call_759484.base,
                         call_759484.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759484, url, valid)

proc call*(call_759485: Call_PostV3InternalLfsAuthenticate_759481): Recallable =
  ## postV3InternalLfsAuthenticate
  result = call_759485.call(nil, nil, nil, nil, nil)

var postV3InternalLfsAuthenticate* = Call_PostV3InternalLfsAuthenticate_759481(
    name: "postV3InternalLfsAuthenticate", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/internal/lfs_authenticate",
    validator: validate_PostV3InternalLfsAuthenticate_759482, base: "/api",
    url: url_PostV3InternalLfsAuthenticate_759483, schemes: {Scheme.Https})
type
  Call_GetV3InternalMergeRequestUrls_759486 = ref object of OpenApiRestCall_758573
proc url_GetV3InternalMergeRequestUrls_759488(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3InternalMergeRequestUrls_759487(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759489: Call_GetV3InternalMergeRequestUrls_759486; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  let valid = call_759489.validator(path, query, header, formData, body)
  let scheme = call_759489.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759489.url(scheme.get, call_759489.host, call_759489.base,
                         call_759489.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759489, url, valid)

proc call*(call_759490: Call_GetV3InternalMergeRequestUrls_759486): Recallable =
  ## getV3InternalMergeRequestUrls
  result = call_759490.call(nil, nil, nil, nil, nil)

var getV3InternalMergeRequestUrls* = Call_GetV3InternalMergeRequestUrls_759486(
    name: "getV3InternalMergeRequestUrls", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/internal/merge_request_urls",
    validator: validate_GetV3InternalMergeRequestUrls_759487, base: "/api",
    url: url_GetV3InternalMergeRequestUrls_759488, schemes: {Scheme.Https})
type
  Call_PostV3InternalTwoFactorRecoveryCodes_759491 = ref object of OpenApiRestCall_758573
proc url_PostV3InternalTwoFactorRecoveryCodes_759493(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3InternalTwoFactorRecoveryCodes_759492(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759494: Call_PostV3InternalTwoFactorRecoveryCodes_759491;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  let valid = call_759494.validator(path, query, header, formData, body)
  let scheme = call_759494.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759494.url(scheme.get, call_759494.host, call_759494.base,
                         call_759494.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759494, url, valid)

proc call*(call_759495: Call_PostV3InternalTwoFactorRecoveryCodes_759491): Recallable =
  ## postV3InternalTwoFactorRecoveryCodes
  result = call_759495.call(nil, nil, nil, nil, nil)

var postV3InternalTwoFactorRecoveryCodes* = Call_PostV3InternalTwoFactorRecoveryCodes_759491(
    name: "postV3InternalTwoFactorRecoveryCodes", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/internal/two_factor_recovery_codes",
    validator: validate_PostV3InternalTwoFactorRecoveryCodes_759492, base: "/api",
    url: url_PostV3InternalTwoFactorRecoveryCodes_759493, schemes: {Scheme.Https})
type
  Call_GetV3Issues_759496 = ref object of OpenApiRestCall_758573
proc url_GetV3Issues_759498(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Issues_759497(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Get currently authenticated user's issues
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString
  ##         : Comma-separated list of label names
  ##   state: JString
  ##        : Return opened, closed, or all issues
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   milestone: JString
  ##            : Return issues for a specific milestone
  ##   order_by: JString
  ##           : Return issues ordered by `created_at` or `updated_at` fields.
  ##   sort: JString
  ##       : Return issues sorted in `asc` or `desc` order.
  section = newJObject()
  var valid_759499 = query.getOrDefault("labels")
  valid_759499 = validateParameter(valid_759499, JString, required = false,
                                 default = nil)
  if valid_759499 != nil:
    section.add "labels", valid_759499
  var valid_759500 = query.getOrDefault("state")
  valid_759500 = validateParameter(valid_759500, JString, required = false,
                                 default = newJString("all"))
  if valid_759500 != nil:
    section.add "state", valid_759500
  var valid_759501 = query.getOrDefault("per_page")
  valid_759501 = validateParameter(valid_759501, JInt, required = false, default = nil)
  if valid_759501 != nil:
    section.add "per_page", valid_759501
  var valid_759502 = query.getOrDefault("page")
  valid_759502 = validateParameter(valid_759502, JInt, required = false, default = nil)
  if valid_759502 != nil:
    section.add "page", valid_759502
  var valid_759503 = query.getOrDefault("milestone")
  valid_759503 = validateParameter(valid_759503, JString, required = false,
                                 default = nil)
  if valid_759503 != nil:
    section.add "milestone", valid_759503
  var valid_759504 = query.getOrDefault("order_by")
  valid_759504 = validateParameter(valid_759504, JString, required = false,
                                 default = newJString("created_at"))
  if valid_759504 != nil:
    section.add "order_by", valid_759504
  var valid_759505 = query.getOrDefault("sort")
  valid_759505 = validateParameter(valid_759505, JString, required = false,
                                 default = newJString("desc"))
  if valid_759505 != nil:
    section.add "sort", valid_759505
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759506: Call_GetV3Issues_759496; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get currently authenticated user's issues
  ## 
  let valid = call_759506.validator(path, query, header, formData, body)
  let scheme = call_759506.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759506.url(scheme.get, call_759506.host, call_759506.base,
                         call_759506.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759506, url, valid)

proc call*(call_759507: Call_GetV3Issues_759496; labels: string = "";
          state: string = "all"; perPage: int = 0; page: int = 0; milestone: string = "";
          orderBy: string = "created_at"; sort: string = "desc"): Recallable =
  ## getV3Issues
  ## Get currently authenticated user's issues
  ##   labels: string
  ##         : Comma-separated list of label names
  ##   state: string
  ##        : Return opened, closed, or all issues
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   milestone: string
  ##            : Return issues for a specific milestone
  ##   orderBy: string
  ##          : Return issues ordered by `created_at` or `updated_at` fields.
  ##   sort: string
  ##       : Return issues sorted in `asc` or `desc` order.
  var query_759508 = newJObject()
  add(query_759508, "labels", newJString(labels))
  add(query_759508, "state", newJString(state))
  add(query_759508, "per_page", newJInt(perPage))
  add(query_759508, "page", newJInt(page))
  add(query_759508, "milestone", newJString(milestone))
  add(query_759508, "order_by", newJString(orderBy))
  add(query_759508, "sort", newJString(sort))
  result = call_759507.call(nil, query_759508, nil, nil, nil)

var getV3Issues* = Call_GetV3Issues_759496(name: "getV3Issues",
                                        meth: HttpMethod.HttpGet,
                                        host: "gitlab.com", route: "/v3/issues",
                                        validator: validate_GetV3Issues_759497,
                                        base: "/api", url: url_GetV3Issues_759498,
                                        schemes: {Scheme.Https})
type
  Call_GetV3KeysId_759509 = ref object of OpenApiRestCall_758573
proc url_GetV3KeysId_759511(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/keys/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3KeysId_759510(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Get single ssh key by id. Only available to admin users
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759512 = path.getOrDefault("id")
  valid_759512 = validateParameter(valid_759512, JInt, required = true, default = nil)
  if valid_759512 != nil:
    section.add "id", valid_759512
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759513: Call_GetV3KeysId_759509; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get single ssh key by id. Only available to admin users
  ## 
  let valid = call_759513.validator(path, query, header, formData, body)
  let scheme = call_759513.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759513.url(scheme.get, call_759513.host, call_759513.base,
                         call_759513.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759513, url, valid)

proc call*(call_759514: Call_GetV3KeysId_759509; id: int): Recallable =
  ## getV3KeysId
  ## Get single ssh key by id. Only available to admin users
  ##   id: int (required)
  var path_759515 = newJObject()
  add(path_759515, "id", newJInt(id))
  result = call_759514.call(path_759515, nil, nil, nil, nil)

var getV3KeysId* = Call_GetV3KeysId_759509(name: "getV3KeysId",
                                        meth: HttpMethod.HttpGet,
                                        host: "gitlab.com",
                                        route: "/v3/keys/{id}",
                                        validator: validate_GetV3KeysId_759510,
                                        base: "/api", url: url_GetV3KeysId_759511,
                                        schemes: {Scheme.Https})
type
  Call_GetV3Licenses_759516 = ref object of OpenApiRestCall_758573
proc url_GetV3Licenses_759518(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Licenses_759517(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.7. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   popular: JBool
  ##          : If passed, returns only popular licenses
  section = newJObject()
  var valid_759519 = query.getOrDefault("popular")
  valid_759519 = validateParameter(valid_759519, JBool, required = false, default = nil)
  if valid_759519 != nil:
    section.add "popular", valid_759519
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759520: Call_GetV3Licenses_759516; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.7. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  let valid = call_759520.validator(path, query, header, formData, body)
  let scheme = call_759520.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759520.url(scheme.get, call_759520.host, call_759520.base,
                         call_759520.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759520, url, valid)

proc call*(call_759521: Call_GetV3Licenses_759516; popular: bool = false): Recallable =
  ## getV3Licenses
  ## This feature was introduced in GitLab 8.7. This endpoint is deprecated and will be removed in GitLab 9.0.
  ##   popular: bool
  ##          : If passed, returns only popular licenses
  var query_759522 = newJObject()
  add(query_759522, "popular", newJBool(popular))
  result = call_759521.call(nil, query_759522, nil, nil, nil)

var getV3Licenses* = Call_GetV3Licenses_759516(name: "getV3Licenses",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/licenses",
    validator: validate_GetV3Licenses_759517, base: "/api", url: url_GetV3Licenses_759518,
    schemes: {Scheme.Https})
type
  Call_GetV3LicensesName_759523 = ref object of OpenApiRestCall_758573
proc url_GetV3LicensesName_759525(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/licenses/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3LicensesName_759524(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.7. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : The name of the template
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_759526 = path.getOrDefault("name")
  valid_759526 = validateParameter(valid_759526, JString, required = true,
                                 default = nil)
  if valid_759526 != nil:
    section.add "name", valid_759526
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759527: Call_GetV3LicensesName_759523; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.7. This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  let valid = call_759527.validator(path, query, header, formData, body)
  let scheme = call_759527.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759527.url(scheme.get, call_759527.host, call_759527.base,
                         call_759527.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759527, url, valid)

proc call*(call_759528: Call_GetV3LicensesName_759523; name: string): Recallable =
  ## getV3LicensesName
  ## This feature was introduced in GitLab 8.7. This endpoint is deprecated and will be removed in GitLab 9.0.
  ##   name: string (required)
  ##       : The name of the template
  var path_759529 = newJObject()
  add(path_759529, "name", newJString(name))
  result = call_759528.call(path_759529, nil, nil, nil, nil)

var getV3LicensesName* = Call_GetV3LicensesName_759523(name: "getV3LicensesName",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/licenses/{name}",
    validator: validate_GetV3LicensesName_759524, base: "/api",
    url: url_GetV3LicensesName_759525, schemes: {Scheme.Https})
type
  Call_GetV3Namespaces_759530 = ref object of OpenApiRestCall_758573
proc url_GetV3Namespaces_759532(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Namespaces_759531(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Get a namespaces list
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   search: JString
  ##         : Search query for namespaces
  section = newJObject()
  var valid_759533 = query.getOrDefault("per_page")
  valid_759533 = validateParameter(valid_759533, JInt, required = false, default = nil)
  if valid_759533 != nil:
    section.add "per_page", valid_759533
  var valid_759534 = query.getOrDefault("page")
  valid_759534 = validateParameter(valid_759534, JInt, required = false, default = nil)
  if valid_759534 != nil:
    section.add "page", valid_759534
  var valid_759535 = query.getOrDefault("search")
  valid_759535 = validateParameter(valid_759535, JString, required = false,
                                 default = nil)
  if valid_759535 != nil:
    section.add "search", valid_759535
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759536: Call_GetV3Namespaces_759530; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a namespaces list
  ## 
  let valid = call_759536.validator(path, query, header, formData, body)
  let scheme = call_759536.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759536.url(scheme.get, call_759536.host, call_759536.base,
                         call_759536.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759536, url, valid)

proc call*(call_759537: Call_GetV3Namespaces_759530; perPage: int = 0; page: int = 0;
          search: string = ""): Recallable =
  ## getV3Namespaces
  ## Get a namespaces list
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   search: string
  ##         : Search query for namespaces
  var query_759538 = newJObject()
  add(query_759538, "per_page", newJInt(perPage))
  add(query_759538, "page", newJInt(page))
  add(query_759538, "search", newJString(search))
  result = call_759537.call(nil, query_759538, nil, nil, nil)

var getV3Namespaces* = Call_GetV3Namespaces_759530(name: "getV3Namespaces",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/namespaces",
    validator: validate_GetV3Namespaces_759531, base: "/api",
    url: url_GetV3Namespaces_759532, schemes: {Scheme.Https})
type
  Call_PutV3NotificationSettings_759544 = ref object of OpenApiRestCall_758573
proc url_PutV3NotificationSettings_759546(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PutV3NotificationSettings_759545(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.12
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   failed_pipeline: JBool
  ##                  : Enable/disable this notification
  ##   reopen_issue: JBool
  ##               : Enable/disable this notification
  ##   notification_email: JString
  ##                     : The email address to send notifications
  ##   reassign_issue: JBool
  ##                 : Enable/disable this notification
  ##   reopen_merge_request: JBool
  ##                       : Enable/disable this notification
  ##   new_note: JBool
  ##           : Enable/disable this notification
  ##   success_pipeline: JBool
  ##                   : Enable/disable this notification
  ##   new_issue: JBool
  ##            : Enable/disable this notification
  ##   new_merge_request: JBool
  ##                    : Enable/disable this notification
  ##   level: JString
  ##        : The global notification level
  ##   close_issue: JBool
  ##              : Enable/disable this notification
  ##   reassign_merge_request: JBool
  ##                         : Enable/disable this notification
  ##   close_merge_request: JBool
  ##                      : Enable/disable this notification
  ##   merge_merge_request: JBool
  ##                      : Enable/disable this notification
  section = newJObject()
  var valid_759547 = formData.getOrDefault("failed_pipeline")
  valid_759547 = validateParameter(valid_759547, JBool, required = false, default = nil)
  if valid_759547 != nil:
    section.add "failed_pipeline", valid_759547
  var valid_759548 = formData.getOrDefault("reopen_issue")
  valid_759548 = validateParameter(valid_759548, JBool, required = false, default = nil)
  if valid_759548 != nil:
    section.add "reopen_issue", valid_759548
  var valid_759549 = formData.getOrDefault("notification_email")
  valid_759549 = validateParameter(valid_759549, JString, required = false,
                                 default = nil)
  if valid_759549 != nil:
    section.add "notification_email", valid_759549
  var valid_759550 = formData.getOrDefault("reassign_issue")
  valid_759550 = validateParameter(valid_759550, JBool, required = false, default = nil)
  if valid_759550 != nil:
    section.add "reassign_issue", valid_759550
  var valid_759551 = formData.getOrDefault("reopen_merge_request")
  valid_759551 = validateParameter(valid_759551, JBool, required = false, default = nil)
  if valid_759551 != nil:
    section.add "reopen_merge_request", valid_759551
  var valid_759552 = formData.getOrDefault("new_note")
  valid_759552 = validateParameter(valid_759552, JBool, required = false, default = nil)
  if valid_759552 != nil:
    section.add "new_note", valid_759552
  var valid_759553 = formData.getOrDefault("success_pipeline")
  valid_759553 = validateParameter(valid_759553, JBool, required = false, default = nil)
  if valid_759553 != nil:
    section.add "success_pipeline", valid_759553
  var valid_759554 = formData.getOrDefault("new_issue")
  valid_759554 = validateParameter(valid_759554, JBool, required = false, default = nil)
  if valid_759554 != nil:
    section.add "new_issue", valid_759554
  var valid_759555 = formData.getOrDefault("new_merge_request")
  valid_759555 = validateParameter(valid_759555, JBool, required = false, default = nil)
  if valid_759555 != nil:
    section.add "new_merge_request", valid_759555
  var valid_759556 = formData.getOrDefault("level")
  valid_759556 = validateParameter(valid_759556, JString, required = false,
                                 default = nil)
  if valid_759556 != nil:
    section.add "level", valid_759556
  var valid_759557 = formData.getOrDefault("close_issue")
  valid_759557 = validateParameter(valid_759557, JBool, required = false, default = nil)
  if valid_759557 != nil:
    section.add "close_issue", valid_759557
  var valid_759558 = formData.getOrDefault("reassign_merge_request")
  valid_759558 = validateParameter(valid_759558, JBool, required = false, default = nil)
  if valid_759558 != nil:
    section.add "reassign_merge_request", valid_759558
  var valid_759559 = formData.getOrDefault("close_merge_request")
  valid_759559 = validateParameter(valid_759559, JBool, required = false, default = nil)
  if valid_759559 != nil:
    section.add "close_merge_request", valid_759559
  var valid_759560 = formData.getOrDefault("merge_merge_request")
  valid_759560 = validateParameter(valid_759560, JBool, required = false, default = nil)
  if valid_759560 != nil:
    section.add "merge_merge_request", valid_759560
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759561: Call_PutV3NotificationSettings_759544; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.12
  ## 
  let valid = call_759561.validator(path, query, header, formData, body)
  let scheme = call_759561.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759561.url(scheme.get, call_759561.host, call_759561.base,
                         call_759561.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759561, url, valid)

proc call*(call_759562: Call_PutV3NotificationSettings_759544;
          failedPipeline: bool = false; reopenIssue: bool = false;
          notificationEmail: string = ""; reassignIssue: bool = false;
          reopenMergeRequest: bool = false; newNote: bool = false;
          successPipeline: bool = false; newIssue: bool = false;
          newMergeRequest: bool = false; level: string = ""; closeIssue: bool = false;
          reassignMergeRequest: bool = false; closeMergeRequest: bool = false;
          mergeMergeRequest: bool = false): Recallable =
  ## putV3NotificationSettings
  ## This feature was introduced in GitLab 8.12
  ##   failedPipeline: bool
  ##                 : Enable/disable this notification
  ##   reopenIssue: bool
  ##              : Enable/disable this notification
  ##   notificationEmail: string
  ##                    : The email address to send notifications
  ##   reassignIssue: bool
  ##                : Enable/disable this notification
  ##   reopenMergeRequest: bool
  ##                     : Enable/disable this notification
  ##   newNote: bool
  ##          : Enable/disable this notification
  ##   successPipeline: bool
  ##                  : Enable/disable this notification
  ##   newIssue: bool
  ##           : Enable/disable this notification
  ##   newMergeRequest: bool
  ##                  : Enable/disable this notification
  ##   level: string
  ##        : The global notification level
  ##   closeIssue: bool
  ##             : Enable/disable this notification
  ##   reassignMergeRequest: bool
  ##                       : Enable/disable this notification
  ##   closeMergeRequest: bool
  ##                    : Enable/disable this notification
  ##   mergeMergeRequest: bool
  ##                    : Enable/disable this notification
  var formData_759563 = newJObject()
  add(formData_759563, "failed_pipeline", newJBool(failedPipeline))
  add(formData_759563, "reopen_issue", newJBool(reopenIssue))
  add(formData_759563, "notification_email", newJString(notificationEmail))
  add(formData_759563, "reassign_issue", newJBool(reassignIssue))
  add(formData_759563, "reopen_merge_request", newJBool(reopenMergeRequest))
  add(formData_759563, "new_note", newJBool(newNote))
  add(formData_759563, "success_pipeline", newJBool(successPipeline))
  add(formData_759563, "new_issue", newJBool(newIssue))
  add(formData_759563, "new_merge_request", newJBool(newMergeRequest))
  add(formData_759563, "level", newJString(level))
  add(formData_759563, "close_issue", newJBool(closeIssue))
  add(formData_759563, "reassign_merge_request", newJBool(reassignMergeRequest))
  add(formData_759563, "close_merge_request", newJBool(closeMergeRequest))
  add(formData_759563, "merge_merge_request", newJBool(mergeMergeRequest))
  result = call_759562.call(nil, nil, nil, formData_759563, nil)

var putV3NotificationSettings* = Call_PutV3NotificationSettings_759544(
    name: "putV3NotificationSettings", meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/notification_settings",
    validator: validate_PutV3NotificationSettings_759545, base: "/api",
    url: url_PutV3NotificationSettings_759546, schemes: {Scheme.Https})
type
  Call_GetV3NotificationSettings_759539 = ref object of OpenApiRestCall_758573
proc url_GetV3NotificationSettings_759541(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3NotificationSettings_759540(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.12
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759542: Call_GetV3NotificationSettings_759539; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.12
  ## 
  let valid = call_759542.validator(path, query, header, formData, body)
  let scheme = call_759542.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759542.url(scheme.get, call_759542.host, call_759542.base,
                         call_759542.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759542, url, valid)

proc call*(call_759543: Call_GetV3NotificationSettings_759539): Recallable =
  ## getV3NotificationSettings
  ## This feature was introduced in GitLab 8.12
  result = call_759543.call(nil, nil, nil, nil, nil)

var getV3NotificationSettings* = Call_GetV3NotificationSettings_759539(
    name: "getV3NotificationSettings", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/notification_settings",
    validator: validate_GetV3NotificationSettings_759540, base: "/api",
    url: url_GetV3NotificationSettings_759541, schemes: {Scheme.Https})
type
  Call_PostV3Projects_759578 = ref object of OpenApiRestCall_758573
proc url_PostV3Projects_759580(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3Projects_759579(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Create new project
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   only_allow_merge_if_build_succeeds: JBool
  ##                                     : Only allow to merge if builds succeed
  ##   namespace_id: JInt
  ##               : Namespace ID for the new project. Default to the user namespace.
  ##   builds_enabled: JBool
  ##                 : Flag indication if builds are enabled
  ##   merge_requests_enabled: JBool
  ##                         : Flag indication if merge requests are enabled
  ##   public_builds: JBool
  ##                : Perform public builds
  ##   path: JString
  ##       : The path of the repository
  ##   wiki_enabled: JBool
  ##               : Flag indication if the wiki is enabled
  ##   import_url: JString
  ##             : URL from which the project is imported
  ##   shared_runners_enabled: JBool
  ##                         : Flag indication if shared runners are enabled for that project
  ##   issues_enabled: JBool
  ##                 : Flag indication if the issue tracker is enabled
  ##   only_allow_merge_if_all_discussions_are_resolved: JBool
  ##                                                   : Only allow to merge if all discussions are resolved
  ##   public: JBool
  ##         : Create a public project. The same as visibility_level = 20.
  ##   lfs_enabled: JBool
  ##              : Flag indication if Git LFS is enabled for that project
  ##   description: JString
  ##              : The description of the project
  ##   container_registry_enabled: JBool
  ##                             : Flag indication if the container registry is enabled for that project
  ##   request_access_enabled: JBool
  ##                         : Allow users to request member access
  ##   snippets_enabled: JBool
  ##                   : Flag indication if snippets are enabled
  ##   visibility_level: JInt
  ##                   : Create a public project. The same as visibility_level = 20.
  ##   name: JString (required)
  ##       : The name of the project
  section = newJObject()
  var valid_759581 = formData.getOrDefault("only_allow_merge_if_build_succeeds")
  valid_759581 = validateParameter(valid_759581, JBool, required = false, default = nil)
  if valid_759581 != nil:
    section.add "only_allow_merge_if_build_succeeds", valid_759581
  var valid_759582 = formData.getOrDefault("namespace_id")
  valid_759582 = validateParameter(valid_759582, JInt, required = false, default = nil)
  if valid_759582 != nil:
    section.add "namespace_id", valid_759582
  var valid_759583 = formData.getOrDefault("builds_enabled")
  valid_759583 = validateParameter(valid_759583, JBool, required = false, default = nil)
  if valid_759583 != nil:
    section.add "builds_enabled", valid_759583
  var valid_759584 = formData.getOrDefault("merge_requests_enabled")
  valid_759584 = validateParameter(valid_759584, JBool, required = false, default = nil)
  if valid_759584 != nil:
    section.add "merge_requests_enabled", valid_759584
  var valid_759585 = formData.getOrDefault("public_builds")
  valid_759585 = validateParameter(valid_759585, JBool, required = false, default = nil)
  if valid_759585 != nil:
    section.add "public_builds", valid_759585
  var valid_759586 = formData.getOrDefault("path")
  valid_759586 = validateParameter(valid_759586, JString, required = false,
                                 default = nil)
  if valid_759586 != nil:
    section.add "path", valid_759586
  var valid_759587 = formData.getOrDefault("wiki_enabled")
  valid_759587 = validateParameter(valid_759587, JBool, required = false, default = nil)
  if valid_759587 != nil:
    section.add "wiki_enabled", valid_759587
  var valid_759588 = formData.getOrDefault("import_url")
  valid_759588 = validateParameter(valid_759588, JString, required = false,
                                 default = nil)
  if valid_759588 != nil:
    section.add "import_url", valid_759588
  var valid_759589 = formData.getOrDefault("shared_runners_enabled")
  valid_759589 = validateParameter(valid_759589, JBool, required = false, default = nil)
  if valid_759589 != nil:
    section.add "shared_runners_enabled", valid_759589
  var valid_759590 = formData.getOrDefault("issues_enabled")
  valid_759590 = validateParameter(valid_759590, JBool, required = false, default = nil)
  if valid_759590 != nil:
    section.add "issues_enabled", valid_759590
  var valid_759591 = formData.getOrDefault("only_allow_merge_if_all_discussions_are_resolved")
  valid_759591 = validateParameter(valid_759591, JBool, required = false, default = nil)
  if valid_759591 != nil:
    section.add "only_allow_merge_if_all_discussions_are_resolved", valid_759591
  var valid_759592 = formData.getOrDefault("public")
  valid_759592 = validateParameter(valid_759592, JBool, required = false, default = nil)
  if valid_759592 != nil:
    section.add "public", valid_759592
  var valid_759593 = formData.getOrDefault("lfs_enabled")
  valid_759593 = validateParameter(valid_759593, JBool, required = false, default = nil)
  if valid_759593 != nil:
    section.add "lfs_enabled", valid_759593
  var valid_759594 = formData.getOrDefault("description")
  valid_759594 = validateParameter(valid_759594, JString, required = false,
                                 default = nil)
  if valid_759594 != nil:
    section.add "description", valid_759594
  var valid_759595 = formData.getOrDefault("container_registry_enabled")
  valid_759595 = validateParameter(valid_759595, JBool, required = false, default = nil)
  if valid_759595 != nil:
    section.add "container_registry_enabled", valid_759595
  var valid_759596 = formData.getOrDefault("request_access_enabled")
  valid_759596 = validateParameter(valid_759596, JBool, required = false, default = nil)
  if valid_759596 != nil:
    section.add "request_access_enabled", valid_759596
  var valid_759597 = formData.getOrDefault("snippets_enabled")
  valid_759597 = validateParameter(valid_759597, JBool, required = false, default = nil)
  if valid_759597 != nil:
    section.add "snippets_enabled", valid_759597
  var valid_759598 = formData.getOrDefault("visibility_level")
  valid_759598 = validateParameter(valid_759598, JInt, required = false, default = nil)
  if valid_759598 != nil:
    section.add "visibility_level", valid_759598
  assert formData != nil,
        "formData argument is necessary due to required `name` field"
  var valid_759599 = formData.getOrDefault("name")
  valid_759599 = validateParameter(valid_759599, JString, required = true,
                                 default = nil)
  if valid_759599 != nil:
    section.add "name", valid_759599
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759600: Call_PostV3Projects_759578; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create new project
  ## 
  let valid = call_759600.validator(path, query, header, formData, body)
  let scheme = call_759600.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759600.url(scheme.get, call_759600.host, call_759600.base,
                         call_759600.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759600, url, valid)

proc call*(call_759601: Call_PostV3Projects_759578; name: string;
          onlyAllowMergeIfBuildSucceeds: bool = false; namespaceId: int = 0;
          buildsEnabled: bool = false; mergeRequestsEnabled: bool = false;
          publicBuilds: bool = false; path: string = ""; wikiEnabled: bool = false;
          importUrl: string = ""; sharedRunnersEnabled: bool = false;
          issuesEnabled: bool = false;
          onlyAllowMergeIfAllDiscussionsAreResolved: bool = false;
          public: bool = false; lfsEnabled: bool = false; description: string = "";
          containerRegistryEnabled: bool = false;
          requestAccessEnabled: bool = false; snippetsEnabled: bool = false;
          visibilityLevel: int = 0): Recallable =
  ## postV3Projects
  ## Create new project
  ##   onlyAllowMergeIfBuildSucceeds: bool
  ##                                : Only allow to merge if builds succeed
  ##   namespaceId: int
  ##              : Namespace ID for the new project. Default to the user namespace.
  ##   buildsEnabled: bool
  ##                : Flag indication if builds are enabled
  ##   mergeRequestsEnabled: bool
  ##                       : Flag indication if merge requests are enabled
  ##   publicBuilds: bool
  ##               : Perform public builds
  ##   path: string
  ##       : The path of the repository
  ##   wikiEnabled: bool
  ##              : Flag indication if the wiki is enabled
  ##   importUrl: string
  ##            : URL from which the project is imported
  ##   sharedRunnersEnabled: bool
  ##                       : Flag indication if shared runners are enabled for that project
  ##   issuesEnabled: bool
  ##                : Flag indication if the issue tracker is enabled
  ##   onlyAllowMergeIfAllDiscussionsAreResolved: bool
  ##                                            : Only allow to merge if all discussions are resolved
  ##   public: bool
  ##         : Create a public project. The same as visibility_level = 20.
  ##   lfsEnabled: bool
  ##             : Flag indication if Git LFS is enabled for that project
  ##   description: string
  ##              : The description of the project
  ##   containerRegistryEnabled: bool
  ##                           : Flag indication if the container registry is enabled for that project
  ##   requestAccessEnabled: bool
  ##                       : Allow users to request member access
  ##   snippetsEnabled: bool
  ##                  : Flag indication if snippets are enabled
  ##   visibilityLevel: int
  ##                  : Create a public project. The same as visibility_level = 20.
  ##   name: string (required)
  ##       : The name of the project
  var formData_759602 = newJObject()
  add(formData_759602, "only_allow_merge_if_build_succeeds",
      newJBool(onlyAllowMergeIfBuildSucceeds))
  add(formData_759602, "namespace_id", newJInt(namespaceId))
  add(formData_759602, "builds_enabled", newJBool(buildsEnabled))
  add(formData_759602, "merge_requests_enabled", newJBool(mergeRequestsEnabled))
  add(formData_759602, "public_builds", newJBool(publicBuilds))
  add(formData_759602, "path", newJString(path))
  add(formData_759602, "wiki_enabled", newJBool(wikiEnabled))
  add(formData_759602, "import_url", newJString(importUrl))
  add(formData_759602, "shared_runners_enabled", newJBool(sharedRunnersEnabled))
  add(formData_759602, "issues_enabled", newJBool(issuesEnabled))
  add(formData_759602, "only_allow_merge_if_all_discussions_are_resolved",
      newJBool(onlyAllowMergeIfAllDiscussionsAreResolved))
  add(formData_759602, "public", newJBool(public))
  add(formData_759602, "lfs_enabled", newJBool(lfsEnabled))
  add(formData_759602, "description", newJString(description))
  add(formData_759602, "container_registry_enabled",
      newJBool(containerRegistryEnabled))
  add(formData_759602, "request_access_enabled", newJBool(requestAccessEnabled))
  add(formData_759602, "snippets_enabled", newJBool(snippetsEnabled))
  add(formData_759602, "visibility_level", newJInt(visibilityLevel))
  add(formData_759602, "name", newJString(name))
  result = call_759601.call(nil, nil, nil, formData_759602, nil)

var postV3Projects* = Call_PostV3Projects_759578(name: "postV3Projects",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/projects",
    validator: validate_PostV3Projects_759579, base: "/api",
    url: url_PostV3Projects_759580, schemes: {Scheme.Https})
type
  Call_GetV3Projects_759564 = ref object of OpenApiRestCall_758573
proc url_GetV3Projects_759566(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Projects_759565(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a projects list for authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   archived: JBool
  ##           : Limit by archived status
  ##   page: JInt
  ##       : Current page number
  ##   simple: JBool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: JString
  ##             : Limit by visibility
  ##   search: JString
  ##         : Return list of authorized projects matching the search criteria
  ##   order_by: JString
  ##           : Return projects ordered by field
  ##   sort: JString
  ##       : Return projects sorted in ascending and descending order
  section = newJObject()
  var valid_759567 = query.getOrDefault("per_page")
  valid_759567 = validateParameter(valid_759567, JInt, required = false, default = nil)
  if valid_759567 != nil:
    section.add "per_page", valid_759567
  var valid_759568 = query.getOrDefault("archived")
  valid_759568 = validateParameter(valid_759568, JBool, required = false, default = nil)
  if valid_759568 != nil:
    section.add "archived", valid_759568
  var valid_759569 = query.getOrDefault("page")
  valid_759569 = validateParameter(valid_759569, JInt, required = false, default = nil)
  if valid_759569 != nil:
    section.add "page", valid_759569
  var valid_759570 = query.getOrDefault("simple")
  valid_759570 = validateParameter(valid_759570, JBool, required = false, default = nil)
  if valid_759570 != nil:
    section.add "simple", valid_759570
  var valid_759571 = query.getOrDefault("visibility")
  valid_759571 = validateParameter(valid_759571, JString, required = false,
                                 default = newJString("public"))
  if valid_759571 != nil:
    section.add "visibility", valid_759571
  var valid_759572 = query.getOrDefault("search")
  valid_759572 = validateParameter(valid_759572, JString, required = false,
                                 default = nil)
  if valid_759572 != nil:
    section.add "search", valid_759572
  var valid_759573 = query.getOrDefault("order_by")
  valid_759573 = validateParameter(valid_759573, JString, required = false,
                                 default = newJString("created_at"))
  if valid_759573 != nil:
    section.add "order_by", valid_759573
  var valid_759574 = query.getOrDefault("sort")
  valid_759574 = validateParameter(valid_759574, JString, required = false,
                                 default = newJString("desc"))
  if valid_759574 != nil:
    section.add "sort", valid_759574
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759575: Call_GetV3Projects_759564; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a projects list for authenticated user
  ## 
  let valid = call_759575.validator(path, query, header, formData, body)
  let scheme = call_759575.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759575.url(scheme.get, call_759575.host, call_759575.base,
                         call_759575.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759575, url, valid)

proc call*(call_759576: Call_GetV3Projects_759564; perPage: int = 0;
          archived: bool = false; page: int = 0; simple: bool = false;
          visibility: string = "public"; search: string = "";
          orderBy: string = "created_at"; sort: string = "desc"): Recallable =
  ## getV3Projects
  ## Get a projects list for authenticated user
  ##   perPage: int
  ##          : Number of items per page
  ##   archived: bool
  ##           : Limit by archived status
  ##   page: int
  ##       : Current page number
  ##   simple: bool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: string
  ##             : Limit by visibility
  ##   search: string
  ##         : Return list of authorized projects matching the search criteria
  ##   orderBy: string
  ##          : Return projects ordered by field
  ##   sort: string
  ##       : Return projects sorted in ascending and descending order
  var query_759577 = newJObject()
  add(query_759577, "per_page", newJInt(perPage))
  add(query_759577, "archived", newJBool(archived))
  add(query_759577, "page", newJInt(page))
  add(query_759577, "simple", newJBool(simple))
  add(query_759577, "visibility", newJString(visibility))
  add(query_759577, "search", newJString(search))
  add(query_759577, "order_by", newJString(orderBy))
  add(query_759577, "sort", newJString(sort))
  result = call_759576.call(nil, query_759577, nil, nil, nil)

var getV3Projects* = Call_GetV3Projects_759564(name: "getV3Projects",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/projects",
    validator: validate_GetV3Projects_759565, base: "/api", url: url_GetV3Projects_759566,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsAll_759603 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsAll_759605(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3ProjectsAll_759604(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Get all projects for admin user
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   statistics: JBool
  ##             : Include project statistics
  ##   per_page: JInt
  ##           : Number of items per page
  ##   archived: JBool
  ##           : Limit by archived status
  ##   page: JInt
  ##       : Current page number
  ##   simple: JBool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: JString
  ##             : Limit by visibility
  ##   search: JString
  ##         : Return list of authorized projects matching the search criteria
  ##   order_by: JString
  ##           : Return projects ordered by field
  ##   sort: JString
  ##       : Return projects sorted in ascending and descending order
  section = newJObject()
  var valid_759606 = query.getOrDefault("statistics")
  valid_759606 = validateParameter(valid_759606, JBool, required = false, default = nil)
  if valid_759606 != nil:
    section.add "statistics", valid_759606
  var valid_759607 = query.getOrDefault("per_page")
  valid_759607 = validateParameter(valid_759607, JInt, required = false, default = nil)
  if valid_759607 != nil:
    section.add "per_page", valid_759607
  var valid_759608 = query.getOrDefault("archived")
  valid_759608 = validateParameter(valid_759608, JBool, required = false, default = nil)
  if valid_759608 != nil:
    section.add "archived", valid_759608
  var valid_759609 = query.getOrDefault("page")
  valid_759609 = validateParameter(valid_759609, JInt, required = false, default = nil)
  if valid_759609 != nil:
    section.add "page", valid_759609
  var valid_759610 = query.getOrDefault("simple")
  valid_759610 = validateParameter(valid_759610, JBool, required = false, default = nil)
  if valid_759610 != nil:
    section.add "simple", valid_759610
  var valid_759611 = query.getOrDefault("visibility")
  valid_759611 = validateParameter(valid_759611, JString, required = false,
                                 default = newJString("public"))
  if valid_759611 != nil:
    section.add "visibility", valid_759611
  var valid_759612 = query.getOrDefault("search")
  valid_759612 = validateParameter(valid_759612, JString, required = false,
                                 default = nil)
  if valid_759612 != nil:
    section.add "search", valid_759612
  var valid_759613 = query.getOrDefault("order_by")
  valid_759613 = validateParameter(valid_759613, JString, required = false,
                                 default = newJString("created_at"))
  if valid_759613 != nil:
    section.add "order_by", valid_759613
  var valid_759614 = query.getOrDefault("sort")
  valid_759614 = validateParameter(valid_759614, JString, required = false,
                                 default = newJString("desc"))
  if valid_759614 != nil:
    section.add "sort", valid_759614
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759615: Call_GetV3ProjectsAll_759603; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get all projects for admin user
  ## 
  let valid = call_759615.validator(path, query, header, formData, body)
  let scheme = call_759615.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759615.url(scheme.get, call_759615.host, call_759615.base,
                         call_759615.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759615, url, valid)

proc call*(call_759616: Call_GetV3ProjectsAll_759603; statistics: bool = false;
          perPage: int = 0; archived: bool = false; page: int = 0; simple: bool = false;
          visibility: string = "public"; search: string = "";
          orderBy: string = "created_at"; sort: string = "desc"): Recallable =
  ## getV3ProjectsAll
  ## Get all projects for admin user
  ##   statistics: bool
  ##             : Include project statistics
  ##   perPage: int
  ##          : Number of items per page
  ##   archived: bool
  ##           : Limit by archived status
  ##   page: int
  ##       : Current page number
  ##   simple: bool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: string
  ##             : Limit by visibility
  ##   search: string
  ##         : Return list of authorized projects matching the search criteria
  ##   orderBy: string
  ##          : Return projects ordered by field
  ##   sort: string
  ##       : Return projects sorted in ascending and descending order
  var query_759617 = newJObject()
  add(query_759617, "statistics", newJBool(statistics))
  add(query_759617, "per_page", newJInt(perPage))
  add(query_759617, "archived", newJBool(archived))
  add(query_759617, "page", newJInt(page))
  add(query_759617, "simple", newJBool(simple))
  add(query_759617, "visibility", newJString(visibility))
  add(query_759617, "search", newJString(search))
  add(query_759617, "order_by", newJString(orderBy))
  add(query_759617, "sort", newJString(sort))
  result = call_759616.call(nil, query_759617, nil, nil, nil)

var getV3ProjectsAll* = Call_GetV3ProjectsAll_759603(name: "getV3ProjectsAll",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/projects/all",
    validator: validate_GetV3ProjectsAll_759604, base: "/api",
    url: url_GetV3ProjectsAll_759605, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsForkId_759618 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsForkId_759620(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/fork/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsForkId_759619(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Fork new project for the current user or provided namespace.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759621 = path.getOrDefault("id")
  valid_759621 = validateParameter(valid_759621, JString, required = true,
                                 default = nil)
  if valid_759621 != nil:
    section.add "id", valid_759621
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   namespace: JString
  ##            : The ID or name of the namespace that the project will be forked into
  section = newJObject()
  var valid_759622 = formData.getOrDefault("namespace")
  valid_759622 = validateParameter(valid_759622, JString, required = false,
                                 default = nil)
  if valid_759622 != nil:
    section.add "namespace", valid_759622
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759623: Call_PostV3ProjectsForkId_759618; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Fork new project for the current user or provided namespace.
  ## 
  let valid = call_759623.validator(path, query, header, formData, body)
  let scheme = call_759623.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759623.url(scheme.get, call_759623.host, call_759623.base,
                         call_759623.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759623, url, valid)

proc call*(call_759624: Call_PostV3ProjectsForkId_759618; id: string;
          namespace: string = ""): Recallable =
  ## postV3ProjectsForkId
  ## Fork new project for the current user or provided namespace.
  ##   id: string (required)
  ##     : The ID of a project
  ##   namespace: string
  ##            : The ID or name of the namespace that the project will be forked into
  var path_759625 = newJObject()
  var formData_759626 = newJObject()
  add(path_759625, "id", newJString(id))
  add(formData_759626, "namespace", newJString(namespace))
  result = call_759624.call(path_759625, nil, nil, formData_759626, nil)

var postV3ProjectsForkId* = Call_PostV3ProjectsForkId_759618(
    name: "postV3ProjectsForkId", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/fork/{id}", validator: validate_PostV3ProjectsForkId_759619,
    base: "/api", url: url_PostV3ProjectsForkId_759620, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsOwned_759627 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsOwned_759629(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3ProjectsOwned_759628(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Get an owned projects list for authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   statistics: JBool
  ##             : Include project statistics
  ##   per_page: JInt
  ##           : Number of items per page
  ##   archived: JBool
  ##           : Limit by archived status
  ##   page: JInt
  ##       : Current page number
  ##   simple: JBool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: JString
  ##             : Limit by visibility
  ##   search: JString
  ##         : Return list of authorized projects matching the search criteria
  ##   order_by: JString
  ##           : Return projects ordered by field
  ##   sort: JString
  ##       : Return projects sorted in ascending and descending order
  section = newJObject()
  var valid_759630 = query.getOrDefault("statistics")
  valid_759630 = validateParameter(valid_759630, JBool, required = false, default = nil)
  if valid_759630 != nil:
    section.add "statistics", valid_759630
  var valid_759631 = query.getOrDefault("per_page")
  valid_759631 = validateParameter(valid_759631, JInt, required = false, default = nil)
  if valid_759631 != nil:
    section.add "per_page", valid_759631
  var valid_759632 = query.getOrDefault("archived")
  valid_759632 = validateParameter(valid_759632, JBool, required = false, default = nil)
  if valid_759632 != nil:
    section.add "archived", valid_759632
  var valid_759633 = query.getOrDefault("page")
  valid_759633 = validateParameter(valid_759633, JInt, required = false, default = nil)
  if valid_759633 != nil:
    section.add "page", valid_759633
  var valid_759634 = query.getOrDefault("simple")
  valid_759634 = validateParameter(valid_759634, JBool, required = false, default = nil)
  if valid_759634 != nil:
    section.add "simple", valid_759634
  var valid_759635 = query.getOrDefault("visibility")
  valid_759635 = validateParameter(valid_759635, JString, required = false,
                                 default = newJString("public"))
  if valid_759635 != nil:
    section.add "visibility", valid_759635
  var valid_759636 = query.getOrDefault("search")
  valid_759636 = validateParameter(valid_759636, JString, required = false,
                                 default = nil)
  if valid_759636 != nil:
    section.add "search", valid_759636
  var valid_759637 = query.getOrDefault("order_by")
  valid_759637 = validateParameter(valid_759637, JString, required = false,
                                 default = newJString("created_at"))
  if valid_759637 != nil:
    section.add "order_by", valid_759637
  var valid_759638 = query.getOrDefault("sort")
  valid_759638 = validateParameter(valid_759638, JString, required = false,
                                 default = newJString("desc"))
  if valid_759638 != nil:
    section.add "sort", valid_759638
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759639: Call_GetV3ProjectsOwned_759627; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get an owned projects list for authenticated user
  ## 
  let valid = call_759639.validator(path, query, header, formData, body)
  let scheme = call_759639.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759639.url(scheme.get, call_759639.host, call_759639.base,
                         call_759639.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759639, url, valid)

proc call*(call_759640: Call_GetV3ProjectsOwned_759627; statistics: bool = false;
          perPage: int = 0; archived: bool = false; page: int = 0; simple: bool = false;
          visibility: string = "public"; search: string = "";
          orderBy: string = "created_at"; sort: string = "desc"): Recallable =
  ## getV3ProjectsOwned
  ## Get an owned projects list for authenticated user
  ##   statistics: bool
  ##             : Include project statistics
  ##   perPage: int
  ##          : Number of items per page
  ##   archived: bool
  ##           : Limit by archived status
  ##   page: int
  ##       : Current page number
  ##   simple: bool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: string
  ##             : Limit by visibility
  ##   search: string
  ##         : Return list of authorized projects matching the search criteria
  ##   orderBy: string
  ##          : Return projects ordered by field
  ##   sort: string
  ##       : Return projects sorted in ascending and descending order
  var query_759641 = newJObject()
  add(query_759641, "statistics", newJBool(statistics))
  add(query_759641, "per_page", newJInt(perPage))
  add(query_759641, "archived", newJBool(archived))
  add(query_759641, "page", newJInt(page))
  add(query_759641, "simple", newJBool(simple))
  add(query_759641, "visibility", newJString(visibility))
  add(query_759641, "search", newJString(search))
  add(query_759641, "order_by", newJString(orderBy))
  add(query_759641, "sort", newJString(sort))
  result = call_759640.call(nil, query_759641, nil, nil, nil)

var getV3ProjectsOwned* = Call_GetV3ProjectsOwned_759627(
    name: "getV3ProjectsOwned", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/owned", validator: validate_GetV3ProjectsOwned_759628,
    base: "/api", url: url_GetV3ProjectsOwned_759629, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsSearchQuery_759642 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsSearchQuery_759644(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "query" in path, "`query` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/search/"),
               (kind: VariableSegment, value: "query")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsSearchQuery_759643(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Search for projects the current user has access to
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   query: JString (required)
  ##        : The project name to be searched
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `query` field"
  var valid_759645 = path.getOrDefault("query")
  valid_759645 = validateParameter(valid_759645, JString, required = true,
                                 default = nil)
  if valid_759645 != nil:
    section.add "query", valid_759645
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   order_by: JString
  ##           : Return projects ordered by field
  ##   sort: JString
  ##       : Return projects sorted in ascending and descending order
  section = newJObject()
  var valid_759646 = query.getOrDefault("per_page")
  valid_759646 = validateParameter(valid_759646, JInt, required = false, default = nil)
  if valid_759646 != nil:
    section.add "per_page", valid_759646
  var valid_759647 = query.getOrDefault("page")
  valid_759647 = validateParameter(valid_759647, JInt, required = false, default = nil)
  if valid_759647 != nil:
    section.add "page", valid_759647
  var valid_759648 = query.getOrDefault("order_by")
  valid_759648 = validateParameter(valid_759648, JString, required = false,
                                 default = newJString("created_at"))
  if valid_759648 != nil:
    section.add "order_by", valid_759648
  var valid_759649 = query.getOrDefault("sort")
  valid_759649 = validateParameter(valid_759649, JString, required = false,
                                 default = newJString("desc"))
  if valid_759649 != nil:
    section.add "sort", valid_759649
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759650: Call_GetV3ProjectsSearchQuery_759642; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Search for projects the current user has access to
  ## 
  let valid = call_759650.validator(path, query, header, formData, body)
  let scheme = call_759650.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759650.url(scheme.get, call_759650.host, call_759650.base,
                         call_759650.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759650, url, valid)

proc call*(call_759651: Call_GetV3ProjectsSearchQuery_759642; query: string;
          perPage: int = 0; page: int = 0; orderBy: string = "created_at";
          sort: string = "desc"): Recallable =
  ## getV3ProjectsSearchQuery
  ## Search for projects the current user has access to
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   query: string (required)
  ##        : The project name to be searched
  ##   orderBy: string
  ##          : Return projects ordered by field
  ##   sort: string
  ##       : Return projects sorted in ascending and descending order
  var path_759652 = newJObject()
  var query_759653 = newJObject()
  add(query_759653, "per_page", newJInt(perPage))
  add(query_759653, "page", newJInt(page))
  add(path_759652, "query", newJString(query))
  add(query_759653, "order_by", newJString(orderBy))
  add(query_759653, "sort", newJString(sort))
  result = call_759651.call(path_759652, query_759653, nil, nil, nil)

var getV3ProjectsSearchQuery* = Call_GetV3ProjectsSearchQuery_759642(
    name: "getV3ProjectsSearchQuery", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/search/{query}",
    validator: validate_GetV3ProjectsSearchQuery_759643, base: "/api",
    url: url_GetV3ProjectsSearchQuery_759644, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsStarred_759654 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsStarred_759656(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3ProjectsStarred_759655(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets starred project for the authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   archived: JBool
  ##           : Limit by archived status
  ##   page: JInt
  ##       : Current page number
  ##   simple: JBool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: JString
  ##             : Limit by visibility
  ##   search: JString
  ##         : Return list of authorized projects matching the search criteria
  ##   order_by: JString
  ##           : Return projects ordered by field
  ##   sort: JString
  ##       : Return projects sorted in ascending and descending order
  section = newJObject()
  var valid_759657 = query.getOrDefault("per_page")
  valid_759657 = validateParameter(valid_759657, JInt, required = false, default = nil)
  if valid_759657 != nil:
    section.add "per_page", valid_759657
  var valid_759658 = query.getOrDefault("archived")
  valid_759658 = validateParameter(valid_759658, JBool, required = false, default = nil)
  if valid_759658 != nil:
    section.add "archived", valid_759658
  var valid_759659 = query.getOrDefault("page")
  valid_759659 = validateParameter(valid_759659, JInt, required = false, default = nil)
  if valid_759659 != nil:
    section.add "page", valid_759659
  var valid_759660 = query.getOrDefault("simple")
  valid_759660 = validateParameter(valid_759660, JBool, required = false, default = nil)
  if valid_759660 != nil:
    section.add "simple", valid_759660
  var valid_759661 = query.getOrDefault("visibility")
  valid_759661 = validateParameter(valid_759661, JString, required = false,
                                 default = newJString("public"))
  if valid_759661 != nil:
    section.add "visibility", valid_759661
  var valid_759662 = query.getOrDefault("search")
  valid_759662 = validateParameter(valid_759662, JString, required = false,
                                 default = nil)
  if valid_759662 != nil:
    section.add "search", valid_759662
  var valid_759663 = query.getOrDefault("order_by")
  valid_759663 = validateParameter(valid_759663, JString, required = false,
                                 default = newJString("created_at"))
  if valid_759663 != nil:
    section.add "order_by", valid_759663
  var valid_759664 = query.getOrDefault("sort")
  valid_759664 = validateParameter(valid_759664, JString, required = false,
                                 default = newJString("desc"))
  if valid_759664 != nil:
    section.add "sort", valid_759664
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759665: Call_GetV3ProjectsStarred_759654; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets starred project for the authenticated user
  ## 
  let valid = call_759665.validator(path, query, header, formData, body)
  let scheme = call_759665.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759665.url(scheme.get, call_759665.host, call_759665.base,
                         call_759665.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759665, url, valid)

proc call*(call_759666: Call_GetV3ProjectsStarred_759654; perPage: int = 0;
          archived: bool = false; page: int = 0; simple: bool = false;
          visibility: string = "public"; search: string = "";
          orderBy: string = "created_at"; sort: string = "desc"): Recallable =
  ## getV3ProjectsStarred
  ## Gets starred project for the authenticated user
  ##   perPage: int
  ##          : Number of items per page
  ##   archived: bool
  ##           : Limit by archived status
  ##   page: int
  ##       : Current page number
  ##   simple: bool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: string
  ##             : Limit by visibility
  ##   search: string
  ##         : Return list of authorized projects matching the search criteria
  ##   orderBy: string
  ##          : Return projects ordered by field
  ##   sort: string
  ##       : Return projects sorted in ascending and descending order
  var query_759667 = newJObject()
  add(query_759667, "per_page", newJInt(perPage))
  add(query_759667, "archived", newJBool(archived))
  add(query_759667, "page", newJInt(page))
  add(query_759667, "simple", newJBool(simple))
  add(query_759667, "visibility", newJString(visibility))
  add(query_759667, "search", newJString(search))
  add(query_759667, "order_by", newJString(orderBy))
  add(query_759667, "sort", newJString(sort))
  result = call_759666.call(nil, query_759667, nil, nil, nil)

var getV3ProjectsStarred* = Call_GetV3ProjectsStarred_759654(
    name: "getV3ProjectsStarred", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/starred", validator: validate_GetV3ProjectsStarred_759655,
    base: "/api", url: url_GetV3ProjectsStarred_759656, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsUserUserId_759668 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsUserUserId_759670(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/user/"),
               (kind: VariableSegment, value: "user_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsUserUserId_759669(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create new project for a specified user. Only available to admin users.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   user_id: JInt (required)
  ##          : The ID of a user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `user_id` field"
  var valid_759671 = path.getOrDefault("user_id")
  valid_759671 = validateParameter(valid_759671, JInt, required = true, default = nil)
  if valid_759671 != nil:
    section.add "user_id", valid_759671
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   only_allow_merge_if_build_succeeds: JBool
  ##                                     : Only allow to merge if builds succeed
  ##   namespace_id: JInt
  ##               : Namespace ID for the new project. Default to the user namespace.
  ##   default_branch: JString
  ##                 : The default branch of the project
  ##   builds_enabled: JBool
  ##                 : Flag indication if builds are enabled
  ##   merge_requests_enabled: JBool
  ##                         : Flag indication if merge requests are enabled
  ##   public_builds: JBool
  ##                : Perform public builds
  ##   wiki_enabled: JBool
  ##               : Flag indication if the wiki is enabled
  ##   import_url: JString
  ##             : URL from which the project is imported
  ##   shared_runners_enabled: JBool
  ##                         : Flag indication if shared runners are enabled for that project
  ##   issues_enabled: JBool
  ##                 : Flag indication if the issue tracker is enabled
  ##   only_allow_merge_if_all_discussions_are_resolved: JBool
  ##                                                   : Only allow to merge if all discussions are resolved
  ##   public: JBool
  ##         : Create a public project. The same as visibility_level = 20.
  ##   lfs_enabled: JBool
  ##              : Flag indication if Git LFS is enabled for that project
  ##   description: JString
  ##              : The description of the project
  ##   container_registry_enabled: JBool
  ##                             : Flag indication if the container registry is enabled for that project
  ##   request_access_enabled: JBool
  ##                         : Allow users to request member access
  ##   snippets_enabled: JBool
  ##                   : Flag indication if snippets are enabled
  ##   visibility_level: JInt
  ##                   : Create a public project. The same as visibility_level = 20.
  ##   name: JString (required)
  ##       : The name of the project
  section = newJObject()
  var valid_759672 = formData.getOrDefault("only_allow_merge_if_build_succeeds")
  valid_759672 = validateParameter(valid_759672, JBool, required = false, default = nil)
  if valid_759672 != nil:
    section.add "only_allow_merge_if_build_succeeds", valid_759672
  var valid_759673 = formData.getOrDefault("namespace_id")
  valid_759673 = validateParameter(valid_759673, JInt, required = false, default = nil)
  if valid_759673 != nil:
    section.add "namespace_id", valid_759673
  var valid_759674 = formData.getOrDefault("default_branch")
  valid_759674 = validateParameter(valid_759674, JString, required = false,
                                 default = nil)
  if valid_759674 != nil:
    section.add "default_branch", valid_759674
  var valid_759675 = formData.getOrDefault("builds_enabled")
  valid_759675 = validateParameter(valid_759675, JBool, required = false, default = nil)
  if valid_759675 != nil:
    section.add "builds_enabled", valid_759675
  var valid_759676 = formData.getOrDefault("merge_requests_enabled")
  valid_759676 = validateParameter(valid_759676, JBool, required = false, default = nil)
  if valid_759676 != nil:
    section.add "merge_requests_enabled", valid_759676
  var valid_759677 = formData.getOrDefault("public_builds")
  valid_759677 = validateParameter(valid_759677, JBool, required = false, default = nil)
  if valid_759677 != nil:
    section.add "public_builds", valid_759677
  var valid_759678 = formData.getOrDefault("wiki_enabled")
  valid_759678 = validateParameter(valid_759678, JBool, required = false, default = nil)
  if valid_759678 != nil:
    section.add "wiki_enabled", valid_759678
  var valid_759679 = formData.getOrDefault("import_url")
  valid_759679 = validateParameter(valid_759679, JString, required = false,
                                 default = nil)
  if valid_759679 != nil:
    section.add "import_url", valid_759679
  var valid_759680 = formData.getOrDefault("shared_runners_enabled")
  valid_759680 = validateParameter(valid_759680, JBool, required = false, default = nil)
  if valid_759680 != nil:
    section.add "shared_runners_enabled", valid_759680
  var valid_759681 = formData.getOrDefault("issues_enabled")
  valid_759681 = validateParameter(valid_759681, JBool, required = false, default = nil)
  if valid_759681 != nil:
    section.add "issues_enabled", valid_759681
  var valid_759682 = formData.getOrDefault("only_allow_merge_if_all_discussions_are_resolved")
  valid_759682 = validateParameter(valid_759682, JBool, required = false, default = nil)
  if valid_759682 != nil:
    section.add "only_allow_merge_if_all_discussions_are_resolved", valid_759682
  var valid_759683 = formData.getOrDefault("public")
  valid_759683 = validateParameter(valid_759683, JBool, required = false, default = nil)
  if valid_759683 != nil:
    section.add "public", valid_759683
  var valid_759684 = formData.getOrDefault("lfs_enabled")
  valid_759684 = validateParameter(valid_759684, JBool, required = false, default = nil)
  if valid_759684 != nil:
    section.add "lfs_enabled", valid_759684
  var valid_759685 = formData.getOrDefault("description")
  valid_759685 = validateParameter(valid_759685, JString, required = false,
                                 default = nil)
  if valid_759685 != nil:
    section.add "description", valid_759685
  var valid_759686 = formData.getOrDefault("container_registry_enabled")
  valid_759686 = validateParameter(valid_759686, JBool, required = false, default = nil)
  if valid_759686 != nil:
    section.add "container_registry_enabled", valid_759686
  var valid_759687 = formData.getOrDefault("request_access_enabled")
  valid_759687 = validateParameter(valid_759687, JBool, required = false, default = nil)
  if valid_759687 != nil:
    section.add "request_access_enabled", valid_759687
  var valid_759688 = formData.getOrDefault("snippets_enabled")
  valid_759688 = validateParameter(valid_759688, JBool, required = false, default = nil)
  if valid_759688 != nil:
    section.add "snippets_enabled", valid_759688
  var valid_759689 = formData.getOrDefault("visibility_level")
  valid_759689 = validateParameter(valid_759689, JInt, required = false, default = nil)
  if valid_759689 != nil:
    section.add "visibility_level", valid_759689
  assert formData != nil,
        "formData argument is necessary due to required `name` field"
  var valid_759690 = formData.getOrDefault("name")
  valid_759690 = validateParameter(valid_759690, JString, required = true,
                                 default = nil)
  if valid_759690 != nil:
    section.add "name", valid_759690
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759691: Call_PostV3ProjectsUserUserId_759668; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create new project for a specified user. Only available to admin users.
  ## 
  let valid = call_759691.validator(path, query, header, formData, body)
  let scheme = call_759691.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759691.url(scheme.get, call_759691.host, call_759691.base,
                         call_759691.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759691, url, valid)

proc call*(call_759692: Call_PostV3ProjectsUserUserId_759668; userId: int;
          name: string; onlyAllowMergeIfBuildSucceeds: bool = false;
          namespaceId: int = 0; defaultBranch: string = ""; buildsEnabled: bool = false;
          mergeRequestsEnabled: bool = false; publicBuilds: bool = false;
          wikiEnabled: bool = false; importUrl: string = "";
          sharedRunnersEnabled: bool = false; issuesEnabled: bool = false;
          onlyAllowMergeIfAllDiscussionsAreResolved: bool = false;
          public: bool = false; lfsEnabled: bool = false; description: string = "";
          containerRegistryEnabled: bool = false;
          requestAccessEnabled: bool = false; snippetsEnabled: bool = false;
          visibilityLevel: int = 0): Recallable =
  ## postV3ProjectsUserUserId
  ## Create new project for a specified user. Only available to admin users.
  ##   onlyAllowMergeIfBuildSucceeds: bool
  ##                                : Only allow to merge if builds succeed
  ##   namespaceId: int
  ##              : Namespace ID for the new project. Default to the user namespace.
  ##   defaultBranch: string
  ##                : The default branch of the project
  ##   buildsEnabled: bool
  ##                : Flag indication if builds are enabled
  ##   mergeRequestsEnabled: bool
  ##                       : Flag indication if merge requests are enabled
  ##   publicBuilds: bool
  ##               : Perform public builds
  ##   wikiEnabled: bool
  ##              : Flag indication if the wiki is enabled
  ##   importUrl: string
  ##            : URL from which the project is imported
  ##   sharedRunnersEnabled: bool
  ##                       : Flag indication if shared runners are enabled for that project
  ##   issuesEnabled: bool
  ##                : Flag indication if the issue tracker is enabled
  ##   onlyAllowMergeIfAllDiscussionsAreResolved: bool
  ##                                            : Only allow to merge if all discussions are resolved
  ##   public: bool
  ##         : Create a public project. The same as visibility_level = 20.
  ##   lfsEnabled: bool
  ##             : Flag indication if Git LFS is enabled for that project
  ##   description: string
  ##              : The description of the project
  ##   containerRegistryEnabled: bool
  ##                           : Flag indication if the container registry is enabled for that project
  ##   requestAccessEnabled: bool
  ##                       : Allow users to request member access
  ##   userId: int (required)
  ##         : The ID of a user
  ##   snippetsEnabled: bool
  ##                  : Flag indication if snippets are enabled
  ##   visibilityLevel: int
  ##                  : Create a public project. The same as visibility_level = 20.
  ##   name: string (required)
  ##       : The name of the project
  var path_759693 = newJObject()
  var formData_759694 = newJObject()
  add(formData_759694, "only_allow_merge_if_build_succeeds",
      newJBool(onlyAllowMergeIfBuildSucceeds))
  add(formData_759694, "namespace_id", newJInt(namespaceId))
  add(formData_759694, "default_branch", newJString(defaultBranch))
  add(formData_759694, "builds_enabled", newJBool(buildsEnabled))
  add(formData_759694, "merge_requests_enabled", newJBool(mergeRequestsEnabled))
  add(formData_759694, "public_builds", newJBool(publicBuilds))
  add(formData_759694, "wiki_enabled", newJBool(wikiEnabled))
  add(formData_759694, "import_url", newJString(importUrl))
  add(formData_759694, "shared_runners_enabled", newJBool(sharedRunnersEnabled))
  add(formData_759694, "issues_enabled", newJBool(issuesEnabled))
  add(formData_759694, "only_allow_merge_if_all_discussions_are_resolved",
      newJBool(onlyAllowMergeIfAllDiscussionsAreResolved))
  add(formData_759694, "public", newJBool(public))
  add(formData_759694, "lfs_enabled", newJBool(lfsEnabled))
  add(formData_759694, "description", newJString(description))
  add(formData_759694, "container_registry_enabled",
      newJBool(containerRegistryEnabled))
  add(formData_759694, "request_access_enabled", newJBool(requestAccessEnabled))
  add(path_759693, "user_id", newJInt(userId))
  add(formData_759694, "snippets_enabled", newJBool(snippetsEnabled))
  add(formData_759694, "visibility_level", newJInt(visibilityLevel))
  add(formData_759694, "name", newJString(name))
  result = call_759692.call(path_759693, nil, nil, formData_759694, nil)

var postV3ProjectsUserUserId* = Call_PostV3ProjectsUserUserId_759668(
    name: "postV3ProjectsUserUserId", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/user/{user_id}",
    validator: validate_PostV3ProjectsUserUserId_759669, base: "/api",
    url: url_PostV3ProjectsUserUserId_759670, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsVisible_759695 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsVisible_759697(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3ProjectsVisible_759696(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a list of visible projects for authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   archived: JBool
  ##           : Limit by archived status
  ##   page: JInt
  ##       : Current page number
  ##   simple: JBool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: JString
  ##             : Limit by visibility
  ##   search: JString
  ##         : Return list of authorized projects matching the search criteria
  ##   order_by: JString
  ##           : Return projects ordered by field
  ##   sort: JString
  ##       : Return projects sorted in ascending and descending order
  section = newJObject()
  var valid_759698 = query.getOrDefault("per_page")
  valid_759698 = validateParameter(valid_759698, JInt, required = false, default = nil)
  if valid_759698 != nil:
    section.add "per_page", valid_759698
  var valid_759699 = query.getOrDefault("archived")
  valid_759699 = validateParameter(valid_759699, JBool, required = false, default = nil)
  if valid_759699 != nil:
    section.add "archived", valid_759699
  var valid_759700 = query.getOrDefault("page")
  valid_759700 = validateParameter(valid_759700, JInt, required = false, default = nil)
  if valid_759700 != nil:
    section.add "page", valid_759700
  var valid_759701 = query.getOrDefault("simple")
  valid_759701 = validateParameter(valid_759701, JBool, required = false, default = nil)
  if valid_759701 != nil:
    section.add "simple", valid_759701
  var valid_759702 = query.getOrDefault("visibility")
  valid_759702 = validateParameter(valid_759702, JString, required = false,
                                 default = newJString("public"))
  if valid_759702 != nil:
    section.add "visibility", valid_759702
  var valid_759703 = query.getOrDefault("search")
  valid_759703 = validateParameter(valid_759703, JString, required = false,
                                 default = nil)
  if valid_759703 != nil:
    section.add "search", valid_759703
  var valid_759704 = query.getOrDefault("order_by")
  valid_759704 = validateParameter(valid_759704, JString, required = false,
                                 default = newJString("created_at"))
  if valid_759704 != nil:
    section.add "order_by", valid_759704
  var valid_759705 = query.getOrDefault("sort")
  valid_759705 = validateParameter(valid_759705, JString, required = false,
                                 default = newJString("desc"))
  if valid_759705 != nil:
    section.add "sort", valid_759705
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759706: Call_GetV3ProjectsVisible_759695; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a list of visible projects for authenticated user
  ## 
  let valid = call_759706.validator(path, query, header, formData, body)
  let scheme = call_759706.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759706.url(scheme.get, call_759706.host, call_759706.base,
                         call_759706.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759706, url, valid)

proc call*(call_759707: Call_GetV3ProjectsVisible_759695; perPage: int = 0;
          archived: bool = false; page: int = 0; simple: bool = false;
          visibility: string = "public"; search: string = "";
          orderBy: string = "created_at"; sort: string = "desc"): Recallable =
  ## getV3ProjectsVisible
  ## Get a list of visible projects for authenticated user
  ##   perPage: int
  ##          : Number of items per page
  ##   archived: bool
  ##           : Limit by archived status
  ##   page: int
  ##       : Current page number
  ##   simple: bool
  ##         : Return only the ID, URL, name, and path of each project
  ##   visibility: string
  ##             : Limit by visibility
  ##   search: string
  ##         : Return list of authorized projects matching the search criteria
  ##   orderBy: string
  ##          : Return projects ordered by field
  ##   sort: string
  ##       : Return projects sorted in ascending and descending order
  var query_759708 = newJObject()
  add(query_759708, "per_page", newJInt(perPage))
  add(query_759708, "archived", newJBool(archived))
  add(query_759708, "page", newJInt(page))
  add(query_759708, "simple", newJBool(simple))
  add(query_759708, "visibility", newJString(visibility))
  add(query_759708, "search", newJString(search))
  add(query_759708, "order_by", newJString(orderBy))
  add(query_759708, "sort", newJString(sort))
  result = call_759707.call(nil, query_759708, nil, nil, nil)

var getV3ProjectsVisible* = Call_GetV3ProjectsVisible_759695(
    name: "getV3ProjectsVisible", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/visible", validator: validate_GetV3ProjectsVisible_759696,
    base: "/api", url: url_GetV3ProjectsVisible_759697, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsId_759716 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsId_759718(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsId_759717(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Update an existing project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759719 = path.getOrDefault("id")
  valid_759719 = validateParameter(valid_759719, JString, required = true,
                                 default = nil)
  if valid_759719 != nil:
    section.add "id", valid_759719
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   only_allow_merge_if_build_succeeds: JBool
  ##                                     : Only allow to merge if builds succeed
  ##   default_branch: JString
  ##                 : The default branch of the project
  ##   builds_enabled: JBool
  ##                 : Flag indication if builds are enabled
  ##   merge_requests_enabled: JBool
  ##                         : Flag indication if merge requests are enabled
  ##   public_builds: JBool
  ##                : Perform public builds
  ##   path: JString
  ##       : The path of the repository
  ##   wiki_enabled: JBool
  ##               : Flag indication if the wiki is enabled
  ##   shared_runners_enabled: JBool
  ##                         : Flag indication if shared runners are enabled for that project
  ##   issues_enabled: JBool
  ##                 : Flag indication if the issue tracker is enabled
  ##   only_allow_merge_if_all_discussions_are_resolved: JBool
  ##                                                   : Only allow to merge if all discussions are resolved
  ##   public: JBool
  ##         : Create a public project. The same as visibility_level = 20.
  ##   lfs_enabled: JBool
  ##              : Flag indication if Git LFS is enabled for that project
  ##   description: JString
  ##              : The description of the project
  ##   container_registry_enabled: JBool
  ##                             : Flag indication if the container registry is enabled for that project
  ##   request_access_enabled: JBool
  ##                         : Allow users to request member access
  ##   snippets_enabled: JBool
  ##                   : Flag indication if snippets are enabled
  ##   visibility_level: JInt
  ##                   : Create a public project. The same as visibility_level = 20.
  ##   name: JString
  ##       : The name of the project
  section = newJObject()
  var valid_759720 = formData.getOrDefault("only_allow_merge_if_build_succeeds")
  valid_759720 = validateParameter(valid_759720, JBool, required = false, default = nil)
  if valid_759720 != nil:
    section.add "only_allow_merge_if_build_succeeds", valid_759720
  var valid_759721 = formData.getOrDefault("default_branch")
  valid_759721 = validateParameter(valid_759721, JString, required = false,
                                 default = nil)
  if valid_759721 != nil:
    section.add "default_branch", valid_759721
  var valid_759722 = formData.getOrDefault("builds_enabled")
  valid_759722 = validateParameter(valid_759722, JBool, required = false, default = nil)
  if valid_759722 != nil:
    section.add "builds_enabled", valid_759722
  var valid_759723 = formData.getOrDefault("merge_requests_enabled")
  valid_759723 = validateParameter(valid_759723, JBool, required = false, default = nil)
  if valid_759723 != nil:
    section.add "merge_requests_enabled", valid_759723
  var valid_759724 = formData.getOrDefault("public_builds")
  valid_759724 = validateParameter(valid_759724, JBool, required = false, default = nil)
  if valid_759724 != nil:
    section.add "public_builds", valid_759724
  var valid_759725 = formData.getOrDefault("path")
  valid_759725 = validateParameter(valid_759725, JString, required = false,
                                 default = nil)
  if valid_759725 != nil:
    section.add "path", valid_759725
  var valid_759726 = formData.getOrDefault("wiki_enabled")
  valid_759726 = validateParameter(valid_759726, JBool, required = false, default = nil)
  if valid_759726 != nil:
    section.add "wiki_enabled", valid_759726
  var valid_759727 = formData.getOrDefault("shared_runners_enabled")
  valid_759727 = validateParameter(valid_759727, JBool, required = false, default = nil)
  if valid_759727 != nil:
    section.add "shared_runners_enabled", valid_759727
  var valid_759728 = formData.getOrDefault("issues_enabled")
  valid_759728 = validateParameter(valid_759728, JBool, required = false, default = nil)
  if valid_759728 != nil:
    section.add "issues_enabled", valid_759728
  var valid_759729 = formData.getOrDefault("only_allow_merge_if_all_discussions_are_resolved")
  valid_759729 = validateParameter(valid_759729, JBool, required = false, default = nil)
  if valid_759729 != nil:
    section.add "only_allow_merge_if_all_discussions_are_resolved", valid_759729
  var valid_759730 = formData.getOrDefault("public")
  valid_759730 = validateParameter(valid_759730, JBool, required = false, default = nil)
  if valid_759730 != nil:
    section.add "public", valid_759730
  var valid_759731 = formData.getOrDefault("lfs_enabled")
  valid_759731 = validateParameter(valid_759731, JBool, required = false, default = nil)
  if valid_759731 != nil:
    section.add "lfs_enabled", valid_759731
  var valid_759732 = formData.getOrDefault("description")
  valid_759732 = validateParameter(valid_759732, JString, required = false,
                                 default = nil)
  if valid_759732 != nil:
    section.add "description", valid_759732
  var valid_759733 = formData.getOrDefault("container_registry_enabled")
  valid_759733 = validateParameter(valid_759733, JBool, required = false, default = nil)
  if valid_759733 != nil:
    section.add "container_registry_enabled", valid_759733
  var valid_759734 = formData.getOrDefault("request_access_enabled")
  valid_759734 = validateParameter(valid_759734, JBool, required = false, default = nil)
  if valid_759734 != nil:
    section.add "request_access_enabled", valid_759734
  var valid_759735 = formData.getOrDefault("snippets_enabled")
  valid_759735 = validateParameter(valid_759735, JBool, required = false, default = nil)
  if valid_759735 != nil:
    section.add "snippets_enabled", valid_759735
  var valid_759736 = formData.getOrDefault("visibility_level")
  valid_759736 = validateParameter(valid_759736, JInt, required = false, default = nil)
  if valid_759736 != nil:
    section.add "visibility_level", valid_759736
  var valid_759737 = formData.getOrDefault("name")
  valid_759737 = validateParameter(valid_759737, JString, required = false,
                                 default = nil)
  if valid_759737 != nil:
    section.add "name", valid_759737
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759738: Call_PutV3ProjectsId_759716; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update an existing project
  ## 
  let valid = call_759738.validator(path, query, header, formData, body)
  let scheme = call_759738.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759738.url(scheme.get, call_759738.host, call_759738.base,
                         call_759738.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759738, url, valid)

proc call*(call_759739: Call_PutV3ProjectsId_759716; id: string;
          onlyAllowMergeIfBuildSucceeds: bool = false; defaultBranch: string = "";
          buildsEnabled: bool = false; mergeRequestsEnabled: bool = false;
          publicBuilds: bool = false; path: string = ""; wikiEnabled: bool = false;
          sharedRunnersEnabled: bool = false; issuesEnabled: bool = false;
          onlyAllowMergeIfAllDiscussionsAreResolved: bool = false;
          public: bool = false; lfsEnabled: bool = false; description: string = "";
          containerRegistryEnabled: bool = false;
          requestAccessEnabled: bool = false; snippetsEnabled: bool = false;
          visibilityLevel: int = 0; name: string = ""): Recallable =
  ## putV3ProjectsId
  ## Update an existing project
  ##   onlyAllowMergeIfBuildSucceeds: bool
  ##                                : Only allow to merge if builds succeed
  ##   defaultBranch: string
  ##                : The default branch of the project
  ##   buildsEnabled: bool
  ##                : Flag indication if builds are enabled
  ##   mergeRequestsEnabled: bool
  ##                       : Flag indication if merge requests are enabled
  ##   publicBuilds: bool
  ##               : Perform public builds
  ##   id: string (required)
  ##     : The ID of a project
  ##   path: string
  ##       : The path of the repository
  ##   wikiEnabled: bool
  ##              : Flag indication if the wiki is enabled
  ##   sharedRunnersEnabled: bool
  ##                       : Flag indication if shared runners are enabled for that project
  ##   issuesEnabled: bool
  ##                : Flag indication if the issue tracker is enabled
  ##   onlyAllowMergeIfAllDiscussionsAreResolved: bool
  ##                                            : Only allow to merge if all discussions are resolved
  ##   public: bool
  ##         : Create a public project. The same as visibility_level = 20.
  ##   lfsEnabled: bool
  ##             : Flag indication if Git LFS is enabled for that project
  ##   description: string
  ##              : The description of the project
  ##   containerRegistryEnabled: bool
  ##                           : Flag indication if the container registry is enabled for that project
  ##   requestAccessEnabled: bool
  ##                       : Allow users to request member access
  ##   snippetsEnabled: bool
  ##                  : Flag indication if snippets are enabled
  ##   visibilityLevel: int
  ##                  : Create a public project. The same as visibility_level = 20.
  ##   name: string
  ##       : The name of the project
  var path_759740 = newJObject()
  var formData_759741 = newJObject()
  add(formData_759741, "only_allow_merge_if_build_succeeds",
      newJBool(onlyAllowMergeIfBuildSucceeds))
  add(formData_759741, "default_branch", newJString(defaultBranch))
  add(formData_759741, "builds_enabled", newJBool(buildsEnabled))
  add(formData_759741, "merge_requests_enabled", newJBool(mergeRequestsEnabled))
  add(formData_759741, "public_builds", newJBool(publicBuilds))
  add(path_759740, "id", newJString(id))
  add(formData_759741, "path", newJString(path))
  add(formData_759741, "wiki_enabled", newJBool(wikiEnabled))
  add(formData_759741, "shared_runners_enabled", newJBool(sharedRunnersEnabled))
  add(formData_759741, "issues_enabled", newJBool(issuesEnabled))
  add(formData_759741, "only_allow_merge_if_all_discussions_are_resolved",
      newJBool(onlyAllowMergeIfAllDiscussionsAreResolved))
  add(formData_759741, "public", newJBool(public))
  add(formData_759741, "lfs_enabled", newJBool(lfsEnabled))
  add(formData_759741, "description", newJString(description))
  add(formData_759741, "container_registry_enabled",
      newJBool(containerRegistryEnabled))
  add(formData_759741, "request_access_enabled", newJBool(requestAccessEnabled))
  add(formData_759741, "snippets_enabled", newJBool(snippetsEnabled))
  add(formData_759741, "visibility_level", newJInt(visibilityLevel))
  add(formData_759741, "name", newJString(name))
  result = call_759739.call(path_759740, nil, nil, formData_759741, nil)

var putV3ProjectsId* = Call_PutV3ProjectsId_759716(name: "putV3ProjectsId",
    meth: HttpMethod.HttpPut, host: "gitlab.com", route: "/v3/projects/{id}",
    validator: validate_PutV3ProjectsId_759717, base: "/api",
    url: url_PutV3ProjectsId_759718, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsId_759709 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsId_759711(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsId_759710(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Get a single project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759712 = path.getOrDefault("id")
  valid_759712 = validateParameter(valid_759712, JString, required = true,
                                 default = nil)
  if valid_759712 != nil:
    section.add "id", valid_759712
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759713: Call_GetV3ProjectsId_759709; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single project
  ## 
  let valid = call_759713.validator(path, query, header, formData, body)
  let scheme = call_759713.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759713.url(scheme.get, call_759713.host, call_759713.base,
                         call_759713.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759713, url, valid)

proc call*(call_759714: Call_GetV3ProjectsId_759709; id: string): Recallable =
  ## getV3ProjectsId
  ## Get a single project
  ##   id: string (required)
  ##     : The ID of a project
  var path_759715 = newJObject()
  add(path_759715, "id", newJString(id))
  result = call_759714.call(path_759715, nil, nil, nil, nil)

var getV3ProjectsId* = Call_GetV3ProjectsId_759709(name: "getV3ProjectsId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/projects/{id}",
    validator: validate_GetV3ProjectsId_759710, base: "/api",
    url: url_GetV3ProjectsId_759711, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsId_759742 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsId_759744(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsId_759743(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Remove a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759745 = path.getOrDefault("id")
  valid_759745 = validateParameter(valid_759745, JString, required = true,
                                 default = nil)
  if valid_759745 != nil:
    section.add "id", valid_759745
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759746: Call_DeleteV3ProjectsId_759742; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove a project
  ## 
  let valid = call_759746.validator(path, query, header, formData, body)
  let scheme = call_759746.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759746.url(scheme.get, call_759746.host, call_759746.base,
                         call_759746.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759746, url, valid)

proc call*(call_759747: Call_DeleteV3ProjectsId_759742; id: string): Recallable =
  ## deleteV3ProjectsId
  ## Remove a project
  ##   id: string (required)
  ##     : The ID of a project
  var path_759748 = newJObject()
  add(path_759748, "id", newJString(id))
  result = call_759747.call(path_759748, nil, nil, nil, nil)

var deleteV3ProjectsId* = Call_DeleteV3ProjectsId_759742(
    name: "deleteV3ProjectsId", meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}", validator: validate_DeleteV3ProjectsId_759743,
    base: "/api", url: url_DeleteV3ProjectsId_759744, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdRefRefTriggerBuilds_759749 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdRefRefTriggerBuilds_759751(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/(ref/"),
               (kind: VariableSegment, value: "ref"),
               (kind: ConstantSegment, value: "/)trigger/builds")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdRefRefTriggerBuilds_759750(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Trigger a GitLab project build
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ref: JString (required)
  ##      : The commit sha or name of a branch or tag
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ref` field"
  var valid_759752 = path.getOrDefault("ref")
  valid_759752 = validateParameter(valid_759752, JString, required = true,
                                 default = nil)
  if valid_759752 != nil:
    section.add "ref", valid_759752
  var valid_759753 = path.getOrDefault("id")
  valid_759753 = validateParameter(valid_759753, JString, required = true,
                                 default = nil)
  if valid_759753 != nil:
    section.add "id", valid_759753
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   token: JString (required)
  ##        : The unique token of trigger
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_759754 = formData.getOrDefault("token")
  valid_759754 = validateParameter(valid_759754, JString, required = true,
                                 default = nil)
  if valid_759754 != nil:
    section.add "token", valid_759754
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759755: Call_PostV3ProjectsIdRefRefTriggerBuilds_759749;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Trigger a GitLab project build
  ## 
  let valid = call_759755.validator(path, query, header, formData, body)
  let scheme = call_759755.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759755.url(scheme.get, call_759755.host, call_759755.base,
                         call_759755.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759755, url, valid)

proc call*(call_759756: Call_PostV3ProjectsIdRefRefTriggerBuilds_759749;
          `ref`: string; id: string; token: string): Recallable =
  ## postV3ProjectsIdRefRefTriggerBuilds
  ## Trigger a GitLab project build
  ##   ref: string (required)
  ##      : The commit sha or name of a branch or tag
  ##   id: string (required)
  ##     : The ID of a project
  ##   token: string (required)
  ##        : The unique token of trigger
  var path_759757 = newJObject()
  var formData_759758 = newJObject()
  add(path_759757, "ref", newJString(`ref`))
  add(path_759757, "id", newJString(id))
  add(formData_759758, "token", newJString(token))
  result = call_759756.call(path_759757, nil, nil, formData_759758, nil)

var postV3ProjectsIdRefRefTriggerBuilds* = Call_PostV3ProjectsIdRefRefTriggerBuilds_759749(
    name: "postV3ProjectsIdRefRefTriggerBuilds", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/(ref/{ref}/)trigger/builds",
    validator: validate_PostV3ProjectsIdRefRefTriggerBuilds_759750, base: "/api",
    url: url_PostV3ProjectsIdRefRefTriggerBuilds_759751, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdAccessRequests_759769 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdAccessRequests_759771(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/access_requests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdAccessRequests_759770(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759772 = path.getOrDefault("id")
  valid_759772 = validateParameter(valid_759772, JString, required = true,
                                 default = nil)
  if valid_759772 != nil:
    section.add "id", valid_759772
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759773: Call_PostV3ProjectsIdAccessRequests_759769; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_759773.validator(path, query, header, formData, body)
  let scheme = call_759773.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759773.url(scheme.get, call_759773.host, call_759773.base,
                         call_759773.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759773, url, valid)

proc call*(call_759774: Call_PostV3ProjectsIdAccessRequests_759769; id: string): Recallable =
  ## postV3ProjectsIdAccessRequests
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The project ID
  var path_759775 = newJObject()
  add(path_759775, "id", newJString(id))
  result = call_759774.call(path_759775, nil, nil, nil, nil)

var postV3ProjectsIdAccessRequests* = Call_PostV3ProjectsIdAccessRequests_759769(
    name: "postV3ProjectsIdAccessRequests", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/access_requests",
    validator: validate_PostV3ProjectsIdAccessRequests_759770, base: "/api",
    url: url_PostV3ProjectsIdAccessRequests_759771, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdAccessRequests_759759 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdAccessRequests_759761(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/access_requests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdAccessRequests_759760(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759762 = path.getOrDefault("id")
  valid_759762 = validateParameter(valid_759762, JString, required = true,
                                 default = nil)
  if valid_759762 != nil:
    section.add "id", valid_759762
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_759763 = query.getOrDefault("per_page")
  valid_759763 = validateParameter(valid_759763, JInt, required = false, default = nil)
  if valid_759763 != nil:
    section.add "per_page", valid_759763
  var valid_759764 = query.getOrDefault("page")
  valid_759764 = validateParameter(valid_759764, JInt, required = false, default = nil)
  if valid_759764 != nil:
    section.add "page", valid_759764
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759765: Call_GetV3ProjectsIdAccessRequests_759759; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_759765.validator(path, query, header, formData, body)
  let scheme = call_759765.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759765.url(scheme.get, call_759765.host, call_759765.base,
                         call_759765.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759765, url, valid)

proc call*(call_759766: Call_GetV3ProjectsIdAccessRequests_759759; id: string;
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdAccessRequests
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The project ID
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_759767 = newJObject()
  var query_759768 = newJObject()
  add(path_759767, "id", newJString(id))
  add(query_759768, "per_page", newJInt(perPage))
  add(query_759768, "page", newJInt(page))
  result = call_759766.call(path_759767, query_759768, nil, nil, nil)

var getV3ProjectsIdAccessRequests* = Call_GetV3ProjectsIdAccessRequests_759759(
    name: "getV3ProjectsIdAccessRequests", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/access_requests",
    validator: validate_GetV3ProjectsIdAccessRequests_759760, base: "/api",
    url: url_GetV3ProjectsIdAccessRequests_759761, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdAccessRequestsUserId_759776 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdAccessRequestsUserId_759778(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/access_requests/"),
               (kind: VariableSegment, value: "user_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdAccessRequestsUserId_759777(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   user_id: JInt (required)
  ##          : The user ID of the access requester
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759779 = path.getOrDefault("id")
  valid_759779 = validateParameter(valid_759779, JString, required = true,
                                 default = nil)
  if valid_759779 != nil:
    section.add "id", valid_759779
  var valid_759780 = path.getOrDefault("user_id")
  valid_759780 = validateParameter(valid_759780, JInt, required = true, default = nil)
  if valid_759780 != nil:
    section.add "user_id", valid_759780
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759781: Call_DeleteV3ProjectsIdAccessRequestsUserId_759776;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_759781.validator(path, query, header, formData, body)
  let scheme = call_759781.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759781.url(scheme.get, call_759781.host, call_759781.base,
                         call_759781.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759781, url, valid)

proc call*(call_759782: Call_DeleteV3ProjectsIdAccessRequestsUserId_759776;
          id: string; userId: int): Recallable =
  ## deleteV3ProjectsIdAccessRequestsUserId
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The project ID
  ##   userId: int (required)
  ##         : The user ID of the access requester
  var path_759783 = newJObject()
  add(path_759783, "id", newJString(id))
  add(path_759783, "user_id", newJInt(userId))
  result = call_759782.call(path_759783, nil, nil, nil, nil)

var deleteV3ProjectsIdAccessRequestsUserId* = Call_DeleteV3ProjectsIdAccessRequestsUserId_759776(
    name: "deleteV3ProjectsIdAccessRequestsUserId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/access_requests/{user_id}",
    validator: validate_DeleteV3ProjectsIdAccessRequestsUserId_759777,
    base: "/api", url: url_DeleteV3ProjectsIdAccessRequestsUserId_759778,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdAccessRequestsUserIdApprove_759784 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdAccessRequestsUserIdApprove_759786(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/access_requests/"),
               (kind: VariableSegment, value: "user_id"),
               (kind: ConstantSegment, value: "/approve")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdAccessRequestsUserIdApprove_759785(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   user_id: JInt (required)
  ##          : The user ID of the access requester
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759787 = path.getOrDefault("id")
  valid_759787 = validateParameter(valid_759787, JString, required = true,
                                 default = nil)
  if valid_759787 != nil:
    section.add "id", valid_759787
  var valid_759788 = path.getOrDefault("user_id")
  valid_759788 = validateParameter(valid_759788, JInt, required = true, default = nil)
  if valid_759788 != nil:
    section.add "user_id", valid_759788
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   access_level: JInt
  ##               : A valid access level (defaults: `30`, developer access level)
  section = newJObject()
  var valid_759789 = formData.getOrDefault("access_level")
  valid_759789 = validateParameter(valid_759789, JInt, required = false, default = nil)
  if valid_759789 != nil:
    section.add "access_level", valid_759789
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759790: Call_PutV3ProjectsIdAccessRequestsUserIdApprove_759784;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_759790.validator(path, query, header, formData, body)
  let scheme = call_759790.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759790.url(scheme.get, call_759790.host, call_759790.base,
                         call_759790.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759790, url, valid)

proc call*(call_759791: Call_PutV3ProjectsIdAccessRequestsUserIdApprove_759784;
          id: string; userId: int; accessLevel: int = 0): Recallable =
  ## putV3ProjectsIdAccessRequestsUserIdApprove
  ## This feature was introduced in GitLab 8.11.
  ##   accessLevel: int
  ##              : A valid access level (defaults: `30`, developer access level)
  ##   id: string (required)
  ##     : The project ID
  ##   userId: int (required)
  ##         : The user ID of the access requester
  var path_759792 = newJObject()
  var formData_759793 = newJObject()
  add(formData_759793, "access_level", newJInt(accessLevel))
  add(path_759792, "id", newJString(id))
  add(path_759792, "user_id", newJInt(userId))
  result = call_759791.call(path_759792, nil, nil, formData_759793, nil)

var putV3ProjectsIdAccessRequestsUserIdApprove* = Call_PutV3ProjectsIdAccessRequestsUserIdApprove_759784(
    name: "putV3ProjectsIdAccessRequestsUserIdApprove", meth: HttpMethod.HttpPut,
    host: "gitlab.com",
    route: "/v3/projects/{id}/access_requests/{user_id}/approve",
    validator: validate_PutV3ProjectsIdAccessRequestsUserIdApprove_759785,
    base: "/api", url: url_PutV3ProjectsIdAccessRequestsUserIdApprove_759786,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdArchive_759794 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdArchive_759796(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/archive")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdArchive_759795(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Archive a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759797 = path.getOrDefault("id")
  valid_759797 = validateParameter(valid_759797, JString, required = true,
                                 default = nil)
  if valid_759797 != nil:
    section.add "id", valid_759797
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759798: Call_PostV3ProjectsIdArchive_759794; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Archive a project
  ## 
  let valid = call_759798.validator(path, query, header, formData, body)
  let scheme = call_759798.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759798.url(scheme.get, call_759798.host, call_759798.base,
                         call_759798.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759798, url, valid)

proc call*(call_759799: Call_PostV3ProjectsIdArchive_759794; id: string): Recallable =
  ## postV3ProjectsIdArchive
  ## Archive a project
  ##   id: string (required)
  ##     : The ID of a project
  var path_759800 = newJObject()
  add(path_759800, "id", newJString(id))
  result = call_759799.call(path_759800, nil, nil, nil, nil)

var postV3ProjectsIdArchive* = Call_PostV3ProjectsIdArchive_759794(
    name: "postV3ProjectsIdArchive", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/archive",
    validator: validate_PostV3ProjectsIdArchive_759795, base: "/api",
    url: url_PostV3ProjectsIdArchive_759796, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdBoards_759801 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdBoards_759803(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/boards")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdBoards_759802(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in 8.13
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759804 = path.getOrDefault("id")
  valid_759804 = validateParameter(valid_759804, JString, required = true,
                                 default = nil)
  if valid_759804 != nil:
    section.add "id", valid_759804
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759805: Call_GetV3ProjectsIdBoards_759801; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in 8.13
  ## 
  let valid = call_759805.validator(path, query, header, formData, body)
  let scheme = call_759805.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759805.url(scheme.get, call_759805.host, call_759805.base,
                         call_759805.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759805, url, valid)

proc call*(call_759806: Call_GetV3ProjectsIdBoards_759801; id: string): Recallable =
  ## getV3ProjectsIdBoards
  ## This feature was introduced in 8.13
  ##   id: string (required)
  ##     : The ID of a project
  var path_759807 = newJObject()
  add(path_759807, "id", newJString(id))
  result = call_759806.call(path_759807, nil, nil, nil, nil)

var getV3ProjectsIdBoards* = Call_GetV3ProjectsIdBoards_759801(
    name: "getV3ProjectsIdBoards", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/boards", validator: validate_GetV3ProjectsIdBoards_759802,
    base: "/api", url: url_GetV3ProjectsIdBoards_759803, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdBoardsBoardIdLists_759816 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdBoardsBoardIdLists_759818(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "board_id" in path, "`board_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/boards/"),
               (kind: VariableSegment, value: "board_id"),
               (kind: ConstantSegment, value: "/lists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdBoardsBoardIdLists_759817(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in 8.13
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   board_id: JInt (required)
  ##           : The ID of a board
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759819 = path.getOrDefault("id")
  valid_759819 = validateParameter(valid_759819, JString, required = true,
                                 default = nil)
  if valid_759819 != nil:
    section.add "id", valid_759819
  var valid_759820 = path.getOrDefault("board_id")
  valid_759820 = validateParameter(valid_759820, JInt, required = true, default = nil)
  if valid_759820 != nil:
    section.add "board_id", valid_759820
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   label_id: JInt (required)
  ##           : The ID of an existing label
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `label_id` field"
  var valid_759821 = formData.getOrDefault("label_id")
  valid_759821 = validateParameter(valid_759821, JInt, required = true, default = nil)
  if valid_759821 != nil:
    section.add "label_id", valid_759821
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759822: Call_PostV3ProjectsIdBoardsBoardIdLists_759816;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.13
  ## 
  let valid = call_759822.validator(path, query, header, formData, body)
  let scheme = call_759822.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759822.url(scheme.get, call_759822.host, call_759822.base,
                         call_759822.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759822, url, valid)

proc call*(call_759823: Call_PostV3ProjectsIdBoardsBoardIdLists_759816;
          labelId: int; id: string; boardId: int): Recallable =
  ## postV3ProjectsIdBoardsBoardIdLists
  ## This feature was introduced in 8.13
  ##   labelId: int (required)
  ##          : The ID of an existing label
  ##   id: string (required)
  ##     : The ID of a project
  ##   boardId: int (required)
  ##          : The ID of a board
  var path_759824 = newJObject()
  var formData_759825 = newJObject()
  add(formData_759825, "label_id", newJInt(labelId))
  add(path_759824, "id", newJString(id))
  add(path_759824, "board_id", newJInt(boardId))
  result = call_759823.call(path_759824, nil, nil, formData_759825, nil)

var postV3ProjectsIdBoardsBoardIdLists* = Call_PostV3ProjectsIdBoardsBoardIdLists_759816(
    name: "postV3ProjectsIdBoardsBoardIdLists", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/boards/{board_id}/lists",
    validator: validate_PostV3ProjectsIdBoardsBoardIdLists_759817, base: "/api",
    url: url_PostV3ProjectsIdBoardsBoardIdLists_759818, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdBoardsBoardIdLists_759808 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdBoardsBoardIdLists_759810(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "board_id" in path, "`board_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/boards/"),
               (kind: VariableSegment, value: "board_id"),
               (kind: ConstantSegment, value: "/lists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdBoardsBoardIdLists_759809(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Does not include `backlog` and `done` lists. This feature was introduced in 8.13
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   board_id: JInt (required)
  ##           : The ID of a board
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759811 = path.getOrDefault("id")
  valid_759811 = validateParameter(valid_759811, JString, required = true,
                                 default = nil)
  if valid_759811 != nil:
    section.add "id", valid_759811
  var valid_759812 = path.getOrDefault("board_id")
  valid_759812 = validateParameter(valid_759812, JInt, required = true, default = nil)
  if valid_759812 != nil:
    section.add "board_id", valid_759812
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759813: Call_GetV3ProjectsIdBoardsBoardIdLists_759808;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Does not include `backlog` and `done` lists. This feature was introduced in 8.13
  ## 
  let valid = call_759813.validator(path, query, header, formData, body)
  let scheme = call_759813.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759813.url(scheme.get, call_759813.host, call_759813.base,
                         call_759813.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759813, url, valid)

proc call*(call_759814: Call_GetV3ProjectsIdBoardsBoardIdLists_759808; id: string;
          boardId: int): Recallable =
  ## getV3ProjectsIdBoardsBoardIdLists
  ## Does not include `backlog` and `done` lists. This feature was introduced in 8.13
  ##   id: string (required)
  ##     : The ID of a project
  ##   boardId: int (required)
  ##          : The ID of a board
  var path_759815 = newJObject()
  add(path_759815, "id", newJString(id))
  add(path_759815, "board_id", newJInt(boardId))
  result = call_759814.call(path_759815, nil, nil, nil, nil)

var getV3ProjectsIdBoardsBoardIdLists* = Call_GetV3ProjectsIdBoardsBoardIdLists_759808(
    name: "getV3ProjectsIdBoardsBoardIdLists", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/boards/{board_id}/lists",
    validator: validate_GetV3ProjectsIdBoardsBoardIdLists_759809, base: "/api",
    url: url_GetV3ProjectsIdBoardsBoardIdLists_759810, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdBoardsBoardIdListsListId_759835 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdBoardsBoardIdListsListId_759837(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "board_id" in path, "`board_id` is a required path parameter"
  assert "list_id" in path, "`list_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/boards/"),
               (kind: VariableSegment, value: "board_id"),
               (kind: ConstantSegment, value: "/lists/"),
               (kind: VariableSegment, value: "list_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdBoardsBoardIdListsListId_759836(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in 8.13
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   list_id: JInt (required)
  ##          : The ID of a list
  ##   board_id: JInt (required)
  ##           : The ID of a board
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759838 = path.getOrDefault("id")
  valid_759838 = validateParameter(valid_759838, JString, required = true,
                                 default = nil)
  if valid_759838 != nil:
    section.add "id", valid_759838
  var valid_759839 = path.getOrDefault("list_id")
  valid_759839 = validateParameter(valid_759839, JInt, required = true, default = nil)
  if valid_759839 != nil:
    section.add "list_id", valid_759839
  var valid_759840 = path.getOrDefault("board_id")
  valid_759840 = validateParameter(valid_759840, JInt, required = true, default = nil)
  if valid_759840 != nil:
    section.add "board_id", valid_759840
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   position: JInt (required)
  ##           : The position of the list
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `position` field"
  var valid_759841 = formData.getOrDefault("position")
  valid_759841 = validateParameter(valid_759841, JInt, required = true, default = nil)
  if valid_759841 != nil:
    section.add "position", valid_759841
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759842: Call_PutV3ProjectsIdBoardsBoardIdListsListId_759835;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.13
  ## 
  let valid = call_759842.validator(path, query, header, formData, body)
  let scheme = call_759842.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759842.url(scheme.get, call_759842.host, call_759842.base,
                         call_759842.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759842, url, valid)

proc call*(call_759843: Call_PutV3ProjectsIdBoardsBoardIdListsListId_759835;
          id: string; position: int; listId: int; boardId: int): Recallable =
  ## putV3ProjectsIdBoardsBoardIdListsListId
  ## This feature was introduced in 8.13
  ##   id: string (required)
  ##     : The ID of a project
  ##   position: int (required)
  ##           : The position of the list
  ##   listId: int (required)
  ##         : The ID of a list
  ##   boardId: int (required)
  ##          : The ID of a board
  var path_759844 = newJObject()
  var formData_759845 = newJObject()
  add(path_759844, "id", newJString(id))
  add(formData_759845, "position", newJInt(position))
  add(path_759844, "list_id", newJInt(listId))
  add(path_759844, "board_id", newJInt(boardId))
  result = call_759843.call(path_759844, nil, nil, formData_759845, nil)

var putV3ProjectsIdBoardsBoardIdListsListId* = Call_PutV3ProjectsIdBoardsBoardIdListsListId_759835(
    name: "putV3ProjectsIdBoardsBoardIdListsListId", meth: HttpMethod.HttpPut,
    host: "gitlab.com",
    route: "/v3/projects/{id}/boards/{board_id}/lists/{list_id}",
    validator: validate_PutV3ProjectsIdBoardsBoardIdListsListId_759836,
    base: "/api", url: url_PutV3ProjectsIdBoardsBoardIdListsListId_759837,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdBoardsBoardIdListsListId_759826 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdBoardsBoardIdListsListId_759828(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "board_id" in path, "`board_id` is a required path parameter"
  assert "list_id" in path, "`list_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/boards/"),
               (kind: VariableSegment, value: "board_id"),
               (kind: ConstantSegment, value: "/lists/"),
               (kind: VariableSegment, value: "list_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdBoardsBoardIdListsListId_759827(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in 8.13
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   list_id: JInt (required)
  ##          : The ID of a list
  ##   board_id: JInt (required)
  ##           : The ID of a board
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759829 = path.getOrDefault("id")
  valid_759829 = validateParameter(valid_759829, JString, required = true,
                                 default = nil)
  if valid_759829 != nil:
    section.add "id", valid_759829
  var valid_759830 = path.getOrDefault("list_id")
  valid_759830 = validateParameter(valid_759830, JInt, required = true, default = nil)
  if valid_759830 != nil:
    section.add "list_id", valid_759830
  var valid_759831 = path.getOrDefault("board_id")
  valid_759831 = validateParameter(valid_759831, JInt, required = true, default = nil)
  if valid_759831 != nil:
    section.add "board_id", valid_759831
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759832: Call_GetV3ProjectsIdBoardsBoardIdListsListId_759826;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.13
  ## 
  let valid = call_759832.validator(path, query, header, formData, body)
  let scheme = call_759832.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759832.url(scheme.get, call_759832.host, call_759832.base,
                         call_759832.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759832, url, valid)

proc call*(call_759833: Call_GetV3ProjectsIdBoardsBoardIdListsListId_759826;
          id: string; listId: int; boardId: int): Recallable =
  ## getV3ProjectsIdBoardsBoardIdListsListId
  ## This feature was introduced in 8.13
  ##   id: string (required)
  ##     : The ID of a project
  ##   listId: int (required)
  ##         : The ID of a list
  ##   boardId: int (required)
  ##          : The ID of a board
  var path_759834 = newJObject()
  add(path_759834, "id", newJString(id))
  add(path_759834, "list_id", newJInt(listId))
  add(path_759834, "board_id", newJInt(boardId))
  result = call_759833.call(path_759834, nil, nil, nil, nil)

var getV3ProjectsIdBoardsBoardIdListsListId* = Call_GetV3ProjectsIdBoardsBoardIdListsListId_759826(
    name: "getV3ProjectsIdBoardsBoardIdListsListId", meth: HttpMethod.HttpGet,
    host: "gitlab.com",
    route: "/v3/projects/{id}/boards/{board_id}/lists/{list_id}",
    validator: validate_GetV3ProjectsIdBoardsBoardIdListsListId_759827,
    base: "/api", url: url_GetV3ProjectsIdBoardsBoardIdListsListId_759828,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdBoardsBoardIdListsListId_759846 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdBoardsBoardIdListsListId_759848(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "board_id" in path, "`board_id` is a required path parameter"
  assert "list_id" in path, "`list_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/boards/"),
               (kind: VariableSegment, value: "board_id"),
               (kind: ConstantSegment, value: "/lists/"),
               (kind: VariableSegment, value: "list_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdBoardsBoardIdListsListId_759847(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in 8.13
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   list_id: JInt (required)
  ##          : The ID of a board list
  ##   board_id: JInt (required)
  ##           : The ID of a board
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759849 = path.getOrDefault("id")
  valid_759849 = validateParameter(valid_759849, JString, required = true,
                                 default = nil)
  if valid_759849 != nil:
    section.add "id", valid_759849
  var valid_759850 = path.getOrDefault("list_id")
  valid_759850 = validateParameter(valid_759850, JInt, required = true, default = nil)
  if valid_759850 != nil:
    section.add "list_id", valid_759850
  var valid_759851 = path.getOrDefault("board_id")
  valid_759851 = validateParameter(valid_759851, JInt, required = true, default = nil)
  if valid_759851 != nil:
    section.add "board_id", valid_759851
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759852: Call_DeleteV3ProjectsIdBoardsBoardIdListsListId_759846;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.13
  ## 
  let valid = call_759852.validator(path, query, header, formData, body)
  let scheme = call_759852.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759852.url(scheme.get, call_759852.host, call_759852.base,
                         call_759852.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759852, url, valid)

proc call*(call_759853: Call_DeleteV3ProjectsIdBoardsBoardIdListsListId_759846;
          id: string; listId: int; boardId: int): Recallable =
  ## deleteV3ProjectsIdBoardsBoardIdListsListId
  ## This feature was introduced in 8.13
  ##   id: string (required)
  ##     : The ID of a project
  ##   listId: int (required)
  ##         : The ID of a board list
  ##   boardId: int (required)
  ##          : The ID of a board
  var path_759854 = newJObject()
  add(path_759854, "id", newJString(id))
  add(path_759854, "list_id", newJInt(listId))
  add(path_759854, "board_id", newJInt(boardId))
  result = call_759853.call(path_759854, nil, nil, nil, nil)

var deleteV3ProjectsIdBoardsBoardIdListsListId* = Call_DeleteV3ProjectsIdBoardsBoardIdListsListId_759846(
    name: "deleteV3ProjectsIdBoardsBoardIdListsListId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/boards/{board_id}/lists/{list_id}",
    validator: validate_DeleteV3ProjectsIdBoardsBoardIdListsListId_759847,
    base: "/api", url: url_DeleteV3ProjectsIdBoardsBoardIdListsListId_759848,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdBuilds_759855 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdBuilds_759857(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/builds")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdBuilds_759856(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a project builds
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759858 = path.getOrDefault("id")
  valid_759858 = validateParameter(valid_759858, JString, required = true,
                                 default = nil)
  if valid_759858 != nil:
    section.add "id", valid_759858
  result.add "path", section
  ## parameters in `query` object:
  ##   scope: JString
  ##        : The scope of builds to show
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_759859 = query.getOrDefault("scope")
  valid_759859 = validateParameter(valid_759859, JString, required = false,
                                 default = newJString("pending"))
  if valid_759859 != nil:
    section.add "scope", valid_759859
  var valid_759860 = query.getOrDefault("per_page")
  valid_759860 = validateParameter(valid_759860, JInt, required = false, default = nil)
  if valid_759860 != nil:
    section.add "per_page", valid_759860
  var valid_759861 = query.getOrDefault("page")
  valid_759861 = validateParameter(valid_759861, JInt, required = false, default = nil)
  if valid_759861 != nil:
    section.add "page", valid_759861
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759862: Call_GetV3ProjectsIdBuilds_759855; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a project builds
  ## 
  let valid = call_759862.validator(path, query, header, formData, body)
  let scheme = call_759862.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759862.url(scheme.get, call_759862.host, call_759862.base,
                         call_759862.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759862, url, valid)

proc call*(call_759863: Call_GetV3ProjectsIdBuilds_759855; id: string;
          scope: string = "pending"; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdBuilds
  ## Get a project builds
  ##   scope: string
  ##        : The scope of builds to show
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_759864 = newJObject()
  var query_759865 = newJObject()
  add(query_759865, "scope", newJString(scope))
  add(path_759864, "id", newJString(id))
  add(query_759865, "per_page", newJInt(perPage))
  add(query_759865, "page", newJInt(page))
  result = call_759863.call(path_759864, query_759865, nil, nil, nil)

var getV3ProjectsIdBuilds* = Call_GetV3ProjectsIdBuilds_759855(
    name: "getV3ProjectsIdBuilds", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/builds", validator: validate_GetV3ProjectsIdBuilds_759856,
    base: "/api", url: url_GetV3ProjectsIdBuilds_759857, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdBuildsArtifactsRefNameDownload_759866 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdBuildsArtifactsRefNameDownload_759868(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "ref_name" in path, "`ref_name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/builds/artifacts/"),
               (kind: VariableSegment, value: "ref_name"),
               (kind: ConstantSegment, value: "/download")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdBuildsArtifactsRefNameDownload_759867(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.10
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   ref_name: JString (required)
  ##           : The ref from repository
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759869 = path.getOrDefault("id")
  valid_759869 = validateParameter(valid_759869, JString, required = true,
                                 default = nil)
  if valid_759869 != nil:
    section.add "id", valid_759869
  var valid_759870 = path.getOrDefault("ref_name")
  valid_759870 = validateParameter(valid_759870, JString, required = true,
                                 default = nil)
  if valid_759870 != nil:
    section.add "ref_name", valid_759870
  result.add "path", section
  ## parameters in `query` object:
  ##   job: JString (required)
  ##      : The name for the build
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `job` field"
  var valid_759871 = query.getOrDefault("job")
  valid_759871 = validateParameter(valid_759871, JString, required = true,
                                 default = nil)
  if valid_759871 != nil:
    section.add "job", valid_759871
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759872: Call_GetV3ProjectsIdBuildsArtifactsRefNameDownload_759866;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.10
  ## 
  let valid = call_759872.validator(path, query, header, formData, body)
  let scheme = call_759872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759872.url(scheme.get, call_759872.host, call_759872.base,
                         call_759872.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759872, url, valid)

proc call*(call_759873: Call_GetV3ProjectsIdBuildsArtifactsRefNameDownload_759866;
          id: string; job: string; refName: string): Recallable =
  ## getV3ProjectsIdBuildsArtifactsRefNameDownload
  ## This feature was introduced in GitLab 8.10
  ##   id: string (required)
  ##     : The ID of a project
  ##   job: string (required)
  ##      : The name for the build
  ##   refName: string (required)
  ##          : The ref from repository
  var path_759874 = newJObject()
  var query_759875 = newJObject()
  add(path_759874, "id", newJString(id))
  add(query_759875, "job", newJString(job))
  add(path_759874, "ref_name", newJString(refName))
  result = call_759873.call(path_759874, query_759875, nil, nil, nil)

var getV3ProjectsIdBuildsArtifactsRefNameDownload* = Call_GetV3ProjectsIdBuildsArtifactsRefNameDownload_759866(
    name: "getV3ProjectsIdBuildsArtifactsRefNameDownload",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/builds/artifacts/{ref_name}/download",
    validator: validate_GetV3ProjectsIdBuildsArtifactsRefNameDownload_759867,
    base: "/api", url: url_GetV3ProjectsIdBuildsArtifactsRefNameDownload_759868,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdBuildsBuildId_759876 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdBuildsBuildId_759878(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "build_id" in path, "`build_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/builds/"),
               (kind: VariableSegment, value: "build_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdBuildsBuildId_759877(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a specific build of a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   build_id: JInt (required)
  ##           : The ID of a build
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759879 = path.getOrDefault("id")
  valid_759879 = validateParameter(valid_759879, JString, required = true,
                                 default = nil)
  if valid_759879 != nil:
    section.add "id", valid_759879
  var valid_759880 = path.getOrDefault("build_id")
  valid_759880 = validateParameter(valid_759880, JInt, required = true, default = nil)
  if valid_759880 != nil:
    section.add "build_id", valid_759880
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759881: Call_GetV3ProjectsIdBuildsBuildId_759876; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a specific build of a project
  ## 
  let valid = call_759881.validator(path, query, header, formData, body)
  let scheme = call_759881.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759881.url(scheme.get, call_759881.host, call_759881.base,
                         call_759881.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759881, url, valid)

proc call*(call_759882: Call_GetV3ProjectsIdBuildsBuildId_759876; id: string;
          buildId: int): Recallable =
  ## getV3ProjectsIdBuildsBuildId
  ## Get a specific build of a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   buildId: int (required)
  ##          : The ID of a build
  var path_759883 = newJObject()
  add(path_759883, "id", newJString(id))
  add(path_759883, "build_id", newJInt(buildId))
  result = call_759882.call(path_759883, nil, nil, nil, nil)

var getV3ProjectsIdBuildsBuildId* = Call_GetV3ProjectsIdBuildsBuildId_759876(
    name: "getV3ProjectsIdBuildsBuildId", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/builds/{build_id}",
    validator: validate_GetV3ProjectsIdBuildsBuildId_759877, base: "/api",
    url: url_GetV3ProjectsIdBuildsBuildId_759878, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdBuildsBuildIdArtifacts_759884 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdBuildsBuildIdArtifacts_759886(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "build_id" in path, "`build_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/builds/"),
               (kind: VariableSegment, value: "build_id"),
               (kind: ConstantSegment, value: "/artifacts")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdBuildsBuildIdArtifacts_759885(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.5
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   build_id: JInt (required)
  ##           : The ID of a build
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759887 = path.getOrDefault("id")
  valid_759887 = validateParameter(valid_759887, JString, required = true,
                                 default = nil)
  if valid_759887 != nil:
    section.add "id", valid_759887
  var valid_759888 = path.getOrDefault("build_id")
  valid_759888 = validateParameter(valid_759888, JInt, required = true, default = nil)
  if valid_759888 != nil:
    section.add "build_id", valid_759888
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759889: Call_GetV3ProjectsIdBuildsBuildIdArtifacts_759884;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.5
  ## 
  let valid = call_759889.validator(path, query, header, formData, body)
  let scheme = call_759889.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759889.url(scheme.get, call_759889.host, call_759889.base,
                         call_759889.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759889, url, valid)

proc call*(call_759890: Call_GetV3ProjectsIdBuildsBuildIdArtifacts_759884;
          id: string; buildId: int): Recallable =
  ## getV3ProjectsIdBuildsBuildIdArtifacts
  ## This feature was introduced in GitLab 8.5
  ##   id: string (required)
  ##     : The ID of a project
  ##   buildId: int (required)
  ##          : The ID of a build
  var path_759891 = newJObject()
  add(path_759891, "id", newJString(id))
  add(path_759891, "build_id", newJInt(buildId))
  result = call_759890.call(path_759891, nil, nil, nil, nil)

var getV3ProjectsIdBuildsBuildIdArtifacts* = Call_GetV3ProjectsIdBuildsBuildIdArtifacts_759884(
    name: "getV3ProjectsIdBuildsBuildIdArtifacts", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/builds/{build_id}/artifacts",
    validator: validate_GetV3ProjectsIdBuildsBuildIdArtifacts_759885,
    base: "/api", url: url_GetV3ProjectsIdBuildsBuildIdArtifacts_759886,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdBuildsBuildIdArtifactsKeep_759892 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdBuildsBuildIdArtifactsKeep_759894(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "build_id" in path, "`build_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/builds/"),
               (kind: VariableSegment, value: "build_id"),
               (kind: ConstantSegment, value: "/artifacts/keep")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdBuildsBuildIdArtifactsKeep_759893(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Keep the artifacts to prevent them from being deleted
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   build_id: JInt (required)
  ##           : The ID of a build
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759895 = path.getOrDefault("id")
  valid_759895 = validateParameter(valid_759895, JString, required = true,
                                 default = nil)
  if valid_759895 != nil:
    section.add "id", valid_759895
  var valid_759896 = path.getOrDefault("build_id")
  valid_759896 = validateParameter(valid_759896, JInt, required = true, default = nil)
  if valid_759896 != nil:
    section.add "build_id", valid_759896
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759897: Call_PostV3ProjectsIdBuildsBuildIdArtifactsKeep_759892;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Keep the artifacts to prevent them from being deleted
  ## 
  let valid = call_759897.validator(path, query, header, formData, body)
  let scheme = call_759897.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759897.url(scheme.get, call_759897.host, call_759897.base,
                         call_759897.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759897, url, valid)

proc call*(call_759898: Call_PostV3ProjectsIdBuildsBuildIdArtifactsKeep_759892;
          id: string; buildId: int): Recallable =
  ## postV3ProjectsIdBuildsBuildIdArtifactsKeep
  ## Keep the artifacts to prevent them from being deleted
  ##   id: string (required)
  ##     : The ID of a project
  ##   buildId: int (required)
  ##          : The ID of a build
  var path_759899 = newJObject()
  add(path_759899, "id", newJString(id))
  add(path_759899, "build_id", newJInt(buildId))
  result = call_759898.call(path_759899, nil, nil, nil, nil)

var postV3ProjectsIdBuildsBuildIdArtifactsKeep* = Call_PostV3ProjectsIdBuildsBuildIdArtifactsKeep_759892(
    name: "postV3ProjectsIdBuildsBuildIdArtifactsKeep", meth: HttpMethod.HttpPost,
    host: "gitlab.com",
    route: "/v3/projects/{id}/builds/{build_id}/artifacts/keep",
    validator: validate_PostV3ProjectsIdBuildsBuildIdArtifactsKeep_759893,
    base: "/api", url: url_PostV3ProjectsIdBuildsBuildIdArtifactsKeep_759894,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdBuildsBuildIdCancel_759900 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdBuildsBuildIdCancel_759902(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "build_id" in path, "`build_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/builds/"),
               (kind: VariableSegment, value: "build_id"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdBuildsBuildIdCancel_759901(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancel a specific build of a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   build_id: JInt (required)
  ##           : The ID of a build
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759903 = path.getOrDefault("id")
  valid_759903 = validateParameter(valid_759903, JString, required = true,
                                 default = nil)
  if valid_759903 != nil:
    section.add "id", valid_759903
  var valid_759904 = path.getOrDefault("build_id")
  valid_759904 = validateParameter(valid_759904, JInt, required = true, default = nil)
  if valid_759904 != nil:
    section.add "build_id", valid_759904
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759905: Call_PostV3ProjectsIdBuildsBuildIdCancel_759900;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancel a specific build of a project
  ## 
  let valid = call_759905.validator(path, query, header, formData, body)
  let scheme = call_759905.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759905.url(scheme.get, call_759905.host, call_759905.base,
                         call_759905.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759905, url, valid)

proc call*(call_759906: Call_PostV3ProjectsIdBuildsBuildIdCancel_759900;
          id: string; buildId: int): Recallable =
  ## postV3ProjectsIdBuildsBuildIdCancel
  ## Cancel a specific build of a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   buildId: int (required)
  ##          : The ID of a build
  var path_759907 = newJObject()
  add(path_759907, "id", newJString(id))
  add(path_759907, "build_id", newJInt(buildId))
  result = call_759906.call(path_759907, nil, nil, nil, nil)

var postV3ProjectsIdBuildsBuildIdCancel* = Call_PostV3ProjectsIdBuildsBuildIdCancel_759900(
    name: "postV3ProjectsIdBuildsBuildIdCancel", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/builds/{build_id}/cancel",
    validator: validate_PostV3ProjectsIdBuildsBuildIdCancel_759901, base: "/api",
    url: url_PostV3ProjectsIdBuildsBuildIdCancel_759902, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdBuildsBuildIdErase_759908 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdBuildsBuildIdErase_759910(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "build_id" in path, "`build_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/builds/"),
               (kind: VariableSegment, value: "build_id"),
               (kind: ConstantSegment, value: "/erase")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdBuildsBuildIdErase_759909(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Erase build (remove artifacts and build trace)
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   build_id: JInt (required)
  ##           : The ID of a build
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759911 = path.getOrDefault("id")
  valid_759911 = validateParameter(valid_759911, JString, required = true,
                                 default = nil)
  if valid_759911 != nil:
    section.add "id", valid_759911
  var valid_759912 = path.getOrDefault("build_id")
  valid_759912 = validateParameter(valid_759912, JInt, required = true, default = nil)
  if valid_759912 != nil:
    section.add "build_id", valid_759912
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759913: Call_PostV3ProjectsIdBuildsBuildIdErase_759908;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Erase build (remove artifacts and build trace)
  ## 
  let valid = call_759913.validator(path, query, header, formData, body)
  let scheme = call_759913.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759913.url(scheme.get, call_759913.host, call_759913.base,
                         call_759913.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759913, url, valid)

proc call*(call_759914: Call_PostV3ProjectsIdBuildsBuildIdErase_759908; id: string;
          buildId: int): Recallable =
  ## postV3ProjectsIdBuildsBuildIdErase
  ## Erase build (remove artifacts and build trace)
  ##   id: string (required)
  ##     : The ID of a project
  ##   buildId: int (required)
  ##          : The ID of a build
  var path_759915 = newJObject()
  add(path_759915, "id", newJString(id))
  add(path_759915, "build_id", newJInt(buildId))
  result = call_759914.call(path_759915, nil, nil, nil, nil)

var postV3ProjectsIdBuildsBuildIdErase* = Call_PostV3ProjectsIdBuildsBuildIdErase_759908(
    name: "postV3ProjectsIdBuildsBuildIdErase", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/builds/{build_id}/erase",
    validator: validate_PostV3ProjectsIdBuildsBuildIdErase_759909, base: "/api",
    url: url_PostV3ProjectsIdBuildsBuildIdErase_759910, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdBuildsBuildIdPlay_759916 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdBuildsBuildIdPlay_759918(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "build_id" in path, "`build_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/builds/"),
               (kind: VariableSegment, value: "build_id"),
               (kind: ConstantSegment, value: "/play")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdBuildsBuildIdPlay_759917(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was added in GitLab 8.11
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   build_id: JInt (required)
  ##           : The ID of a Build
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759919 = path.getOrDefault("id")
  valid_759919 = validateParameter(valid_759919, JString, required = true,
                                 default = nil)
  if valid_759919 != nil:
    section.add "id", valid_759919
  var valid_759920 = path.getOrDefault("build_id")
  valid_759920 = validateParameter(valid_759920, JInt, required = true, default = nil)
  if valid_759920 != nil:
    section.add "build_id", valid_759920
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759921: Call_PostV3ProjectsIdBuildsBuildIdPlay_759916;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was added in GitLab 8.11
  ## 
  let valid = call_759921.validator(path, query, header, formData, body)
  let scheme = call_759921.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759921.url(scheme.get, call_759921.host, call_759921.base,
                         call_759921.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759921, url, valid)

proc call*(call_759922: Call_PostV3ProjectsIdBuildsBuildIdPlay_759916; id: string;
          buildId: int): Recallable =
  ## postV3ProjectsIdBuildsBuildIdPlay
  ## This feature was added in GitLab 8.11
  ##   id: string (required)
  ##     : The ID of a project
  ##   buildId: int (required)
  ##          : The ID of a Build
  var path_759923 = newJObject()
  add(path_759923, "id", newJString(id))
  add(path_759923, "build_id", newJInt(buildId))
  result = call_759922.call(path_759923, nil, nil, nil, nil)

var postV3ProjectsIdBuildsBuildIdPlay* = Call_PostV3ProjectsIdBuildsBuildIdPlay_759916(
    name: "postV3ProjectsIdBuildsBuildIdPlay", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/builds/{build_id}/play",
    validator: validate_PostV3ProjectsIdBuildsBuildIdPlay_759917, base: "/api",
    url: url_PostV3ProjectsIdBuildsBuildIdPlay_759918, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdBuildsBuildIdRetry_759924 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdBuildsBuildIdRetry_759926(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "build_id" in path, "`build_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/builds/"),
               (kind: VariableSegment, value: "build_id"),
               (kind: ConstantSegment, value: "/retry")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdBuildsBuildIdRetry_759925(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Retry a specific build of a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   build_id: JInt (required)
  ##           : The ID of a build
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759927 = path.getOrDefault("id")
  valid_759927 = validateParameter(valid_759927, JString, required = true,
                                 default = nil)
  if valid_759927 != nil:
    section.add "id", valid_759927
  var valid_759928 = path.getOrDefault("build_id")
  valid_759928 = validateParameter(valid_759928, JInt, required = true, default = nil)
  if valid_759928 != nil:
    section.add "build_id", valid_759928
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759929: Call_PostV3ProjectsIdBuildsBuildIdRetry_759924;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Retry a specific build of a project
  ## 
  let valid = call_759929.validator(path, query, header, formData, body)
  let scheme = call_759929.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759929.url(scheme.get, call_759929.host, call_759929.base,
                         call_759929.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759929, url, valid)

proc call*(call_759930: Call_PostV3ProjectsIdBuildsBuildIdRetry_759924; id: string;
          buildId: int): Recallable =
  ## postV3ProjectsIdBuildsBuildIdRetry
  ## Retry a specific build of a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   buildId: int (required)
  ##          : The ID of a build
  var path_759931 = newJObject()
  add(path_759931, "id", newJString(id))
  add(path_759931, "build_id", newJInt(buildId))
  result = call_759930.call(path_759931, nil, nil, nil, nil)

var postV3ProjectsIdBuildsBuildIdRetry* = Call_PostV3ProjectsIdBuildsBuildIdRetry_759924(
    name: "postV3ProjectsIdBuildsBuildIdRetry", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/builds/{build_id}/retry",
    validator: validate_PostV3ProjectsIdBuildsBuildIdRetry_759925, base: "/api",
    url: url_PostV3ProjectsIdBuildsBuildIdRetry_759926, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdBuildsBuildIdTrace_759932 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdBuildsBuildIdTrace_759934(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "build_id" in path, "`build_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/builds/"),
               (kind: VariableSegment, value: "build_id"),
               (kind: ConstantSegment, value: "/trace")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdBuildsBuildIdTrace_759933(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a trace of a specific build of a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   build_id: JInt (required)
  ##           : The ID of a build
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759935 = path.getOrDefault("id")
  valid_759935 = validateParameter(valid_759935, JString, required = true,
                                 default = nil)
  if valid_759935 != nil:
    section.add "id", valid_759935
  var valid_759936 = path.getOrDefault("build_id")
  valid_759936 = validateParameter(valid_759936, JInt, required = true, default = nil)
  if valid_759936 != nil:
    section.add "build_id", valid_759936
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759937: Call_GetV3ProjectsIdBuildsBuildIdTrace_759932;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a trace of a specific build of a project
  ## 
  let valid = call_759937.validator(path, query, header, formData, body)
  let scheme = call_759937.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759937.url(scheme.get, call_759937.host, call_759937.base,
                         call_759937.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759937, url, valid)

proc call*(call_759938: Call_GetV3ProjectsIdBuildsBuildIdTrace_759932; id: string;
          buildId: int): Recallable =
  ## getV3ProjectsIdBuildsBuildIdTrace
  ## Get a trace of a specific build of a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   buildId: int (required)
  ##          : The ID of a build
  var path_759939 = newJObject()
  add(path_759939, "id", newJString(id))
  add(path_759939, "build_id", newJInt(buildId))
  result = call_759938.call(path_759939, nil, nil, nil, nil)

var getV3ProjectsIdBuildsBuildIdTrace* = Call_GetV3ProjectsIdBuildsBuildIdTrace_759932(
    name: "getV3ProjectsIdBuildsBuildIdTrace", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/builds/{build_id}/trace",
    validator: validate_GetV3ProjectsIdBuildsBuildIdTrace_759933, base: "/api",
    url: url_GetV3ProjectsIdBuildsBuildIdTrace_759934, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdDeployKeys_759947 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdDeployKeys_759949(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/deploy_keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdDeployKeys_759948(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add new deploy key to currently authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759950 = path.getOrDefault("id")
  valid_759950 = validateParameter(valid_759950, JString, required = true,
                                 default = nil)
  if valid_759950 != nil:
    section.add "id", valid_759950
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   title: JString (required)
  ##        : The name of the deploy key
  ##   key: JString (required)
  ##      : The new deploy key
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `title` field"
  var valid_759951 = formData.getOrDefault("title")
  valid_759951 = validateParameter(valid_759951, JString, required = true,
                                 default = nil)
  if valid_759951 != nil:
    section.add "title", valid_759951
  var valid_759952 = formData.getOrDefault("key")
  valid_759952 = validateParameter(valid_759952, JString, required = true,
                                 default = nil)
  if valid_759952 != nil:
    section.add "key", valid_759952
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759953: Call_PostV3ProjectsIdDeployKeys_759947; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Add new deploy key to currently authenticated user
  ## 
  let valid = call_759953.validator(path, query, header, formData, body)
  let scheme = call_759953.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759953.url(scheme.get, call_759953.host, call_759953.base,
                         call_759953.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759953, url, valid)

proc call*(call_759954: Call_PostV3ProjectsIdDeployKeys_759947; title: string;
          id: string; key: string): Recallable =
  ## postV3ProjectsIdDeployKeys
  ## Add new deploy key to currently authenticated user
  ##   title: string (required)
  ##        : The name of the deploy key
  ##   id: string (required)
  ##     : The ID of the project
  ##   key: string (required)
  ##      : The new deploy key
  var path_759955 = newJObject()
  var formData_759956 = newJObject()
  add(formData_759956, "title", newJString(title))
  add(path_759955, "id", newJString(id))
  add(formData_759956, "key", newJString(key))
  result = call_759954.call(path_759955, nil, nil, formData_759956, nil)

var postV3ProjectsIdDeployKeys* = Call_PostV3ProjectsIdDeployKeys_759947(
    name: "postV3ProjectsIdDeployKeys", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/deploy_keys",
    validator: validate_PostV3ProjectsIdDeployKeys_759948, base: "/api",
    url: url_PostV3ProjectsIdDeployKeys_759949, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdDeployKeys_759940 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdDeployKeys_759942(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/deploy_keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdDeployKeys_759941(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a specific project's deploy keys
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759943 = path.getOrDefault("id")
  valid_759943 = validateParameter(valid_759943, JString, required = true,
                                 default = nil)
  if valid_759943 != nil:
    section.add "id", valid_759943
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759944: Call_GetV3ProjectsIdDeployKeys_759940; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a specific project's deploy keys
  ## 
  let valid = call_759944.validator(path, query, header, formData, body)
  let scheme = call_759944.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759944.url(scheme.get, call_759944.host, call_759944.base,
                         call_759944.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759944, url, valid)

proc call*(call_759945: Call_GetV3ProjectsIdDeployKeys_759940; id: string): Recallable =
  ## getV3ProjectsIdDeployKeys
  ## Get a specific project's deploy keys
  ##   id: string (required)
  ##     : The ID of the project
  var path_759946 = newJObject()
  add(path_759946, "id", newJString(id))
  result = call_759945.call(path_759946, nil, nil, nil, nil)

var getV3ProjectsIdDeployKeys* = Call_GetV3ProjectsIdDeployKeys_759940(
    name: "getV3ProjectsIdDeployKeys", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/deploy_keys",
    validator: validate_GetV3ProjectsIdDeployKeys_759941, base: "/api",
    url: url_GetV3ProjectsIdDeployKeys_759942, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdDeployKeysKeyId_759957 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdDeployKeysKeyId_759959(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/deploy_keys/"),
               (kind: VariableSegment, value: "key_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdDeployKeysKeyId_759958(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get single deploy key
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  ##   key_id: JInt (required)
  ##         : The ID of the deploy key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759960 = path.getOrDefault("id")
  valid_759960 = validateParameter(valid_759960, JString, required = true,
                                 default = nil)
  if valid_759960 != nil:
    section.add "id", valid_759960
  var valid_759961 = path.getOrDefault("key_id")
  valid_759961 = validateParameter(valid_759961, JInt, required = true, default = nil)
  if valid_759961 != nil:
    section.add "key_id", valid_759961
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759962: Call_GetV3ProjectsIdDeployKeysKeyId_759957; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get single deploy key
  ## 
  let valid = call_759962.validator(path, query, header, formData, body)
  let scheme = call_759962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759962.url(scheme.get, call_759962.host, call_759962.base,
                         call_759962.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759962, url, valid)

proc call*(call_759963: Call_GetV3ProjectsIdDeployKeysKeyId_759957; id: string;
          keyId: int): Recallable =
  ## getV3ProjectsIdDeployKeysKeyId
  ## Get single deploy key
  ##   id: string (required)
  ##     : The ID of the project
  ##   keyId: int (required)
  ##        : The ID of the deploy key
  var path_759964 = newJObject()
  add(path_759964, "id", newJString(id))
  add(path_759964, "key_id", newJInt(keyId))
  result = call_759963.call(path_759964, nil, nil, nil, nil)

var getV3ProjectsIdDeployKeysKeyId* = Call_GetV3ProjectsIdDeployKeysKeyId_759957(
    name: "getV3ProjectsIdDeployKeysKeyId", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/deploy_keys/{key_id}",
    validator: validate_GetV3ProjectsIdDeployKeysKeyId_759958, base: "/api",
    url: url_GetV3ProjectsIdDeployKeysKeyId_759959, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdDeployKeysKeyId_759965 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdDeployKeysKeyId_759967(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/deploy_keys/"),
               (kind: VariableSegment, value: "key_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdDeployKeysKeyId_759966(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete deploy key for a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  ##   key_id: JInt (required)
  ##         : The ID of the deploy key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759968 = path.getOrDefault("id")
  valid_759968 = validateParameter(valid_759968, JString, required = true,
                                 default = nil)
  if valid_759968 != nil:
    section.add "id", valid_759968
  var valid_759969 = path.getOrDefault("key_id")
  valid_759969 = validateParameter(valid_759969, JInt, required = true, default = nil)
  if valid_759969 != nil:
    section.add "key_id", valid_759969
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759970: Call_DeleteV3ProjectsIdDeployKeysKeyId_759965;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete deploy key for a project
  ## 
  let valid = call_759970.validator(path, query, header, formData, body)
  let scheme = call_759970.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759970.url(scheme.get, call_759970.host, call_759970.base,
                         call_759970.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759970, url, valid)

proc call*(call_759971: Call_DeleteV3ProjectsIdDeployKeysKeyId_759965; id: string;
          keyId: int): Recallable =
  ## deleteV3ProjectsIdDeployKeysKeyId
  ## Delete deploy key for a project
  ##   id: string (required)
  ##     : The ID of the project
  ##   keyId: int (required)
  ##        : The ID of the deploy key
  var path_759972 = newJObject()
  add(path_759972, "id", newJString(id))
  add(path_759972, "key_id", newJInt(keyId))
  result = call_759971.call(path_759972, nil, nil, nil, nil)

var deleteV3ProjectsIdDeployKeysKeyId* = Call_DeleteV3ProjectsIdDeployKeysKeyId_759965(
    name: "deleteV3ProjectsIdDeployKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/deploy_keys/{key_id}",
    validator: validate_DeleteV3ProjectsIdDeployKeysKeyId_759966, base: "/api",
    url: url_DeleteV3ProjectsIdDeployKeysKeyId_759967, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdDeployKeysKeyIdDisable_759973 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdDeployKeysKeyIdDisable_759975(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/deploy_keys/"),
               (kind: VariableSegment, value: "key_id"),
               (kind: ConstantSegment, value: "/disable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdDeployKeysKeyIdDisable_759974(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was added in GitLab 8.11
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  ##   key_id: JInt (required)
  ##         : The ID of the deploy key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759976 = path.getOrDefault("id")
  valid_759976 = validateParameter(valid_759976, JString, required = true,
                                 default = nil)
  if valid_759976 != nil:
    section.add "id", valid_759976
  var valid_759977 = path.getOrDefault("key_id")
  valid_759977 = validateParameter(valid_759977, JInt, required = true, default = nil)
  if valid_759977 != nil:
    section.add "key_id", valid_759977
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759978: Call_DeleteV3ProjectsIdDeployKeysKeyIdDisable_759973;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was added in GitLab 8.11
  ## 
  let valid = call_759978.validator(path, query, header, formData, body)
  let scheme = call_759978.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759978.url(scheme.get, call_759978.host, call_759978.base,
                         call_759978.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759978, url, valid)

proc call*(call_759979: Call_DeleteV3ProjectsIdDeployKeysKeyIdDisable_759973;
          id: string; keyId: int): Recallable =
  ## deleteV3ProjectsIdDeployKeysKeyIdDisable
  ## This feature was added in GitLab 8.11
  ##   id: string (required)
  ##     : The ID of the project
  ##   keyId: int (required)
  ##        : The ID of the deploy key
  var path_759980 = newJObject()
  add(path_759980, "id", newJString(id))
  add(path_759980, "key_id", newJInt(keyId))
  result = call_759979.call(path_759980, nil, nil, nil, nil)

var deleteV3ProjectsIdDeployKeysKeyIdDisable* = Call_DeleteV3ProjectsIdDeployKeysKeyIdDisable_759973(
    name: "deleteV3ProjectsIdDeployKeysKeyIdDisable", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/deploy_keys/{key_id}/disable",
    validator: validate_DeleteV3ProjectsIdDeployKeysKeyIdDisable_759974,
    base: "/api", url: url_DeleteV3ProjectsIdDeployKeysKeyIdDisable_759975,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdDeployKeysKeyIdEnable_759981 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdDeployKeysKeyIdEnable_759983(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/deploy_keys/"),
               (kind: VariableSegment, value: "key_id"),
               (kind: ConstantSegment, value: "/enable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdDeployKeysKeyIdEnable_759982(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was added in GitLab 8.11
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  ##   key_id: JInt (required)
  ##         : The ID of the deploy key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759984 = path.getOrDefault("id")
  valid_759984 = validateParameter(valid_759984, JString, required = true,
                                 default = nil)
  if valid_759984 != nil:
    section.add "id", valid_759984
  var valid_759985 = path.getOrDefault("key_id")
  valid_759985 = validateParameter(valid_759985, JInt, required = true, default = nil)
  if valid_759985 != nil:
    section.add "key_id", valid_759985
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759986: Call_PostV3ProjectsIdDeployKeysKeyIdEnable_759981;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was added in GitLab 8.11
  ## 
  let valid = call_759986.validator(path, query, header, formData, body)
  let scheme = call_759986.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759986.url(scheme.get, call_759986.host, call_759986.base,
                         call_759986.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759986, url, valid)

proc call*(call_759987: Call_PostV3ProjectsIdDeployKeysKeyIdEnable_759981;
          id: string; keyId: int): Recallable =
  ## postV3ProjectsIdDeployKeysKeyIdEnable
  ## This feature was added in GitLab 8.11
  ##   id: string (required)
  ##     : The ID of the project
  ##   keyId: int (required)
  ##        : The ID of the deploy key
  var path_759988 = newJObject()
  add(path_759988, "id", newJString(id))
  add(path_759988, "key_id", newJInt(keyId))
  result = call_759987.call(path_759988, nil, nil, nil, nil)

var postV3ProjectsIdDeployKeysKeyIdEnable* = Call_PostV3ProjectsIdDeployKeysKeyIdEnable_759981(
    name: "postV3ProjectsIdDeployKeysKeyIdEnable", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/deploy_keys/{key_id}/enable",
    validator: validate_PostV3ProjectsIdDeployKeysKeyIdEnable_759982,
    base: "/api", url: url_PostV3ProjectsIdDeployKeysKeyIdEnable_759983,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdDeployments_759989 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdDeployments_759991(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdDeployments_759990(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_759992 = path.getOrDefault("id")
  valid_759992 = validateParameter(valid_759992, JString, required = true,
                                 default = nil)
  if valid_759992 != nil:
    section.add "id", valid_759992
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_759993 = query.getOrDefault("per_page")
  valid_759993 = validateParameter(valid_759993, JInt, required = false, default = nil)
  if valid_759993 != nil:
    section.add "per_page", valid_759993
  var valid_759994 = query.getOrDefault("page")
  valid_759994 = validateParameter(valid_759994, JInt, required = false, default = nil)
  if valid_759994 != nil:
    section.add "page", valid_759994
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_759995: Call_GetV3ProjectsIdDeployments_759989; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_759995.validator(path, query, header, formData, body)
  let scheme = call_759995.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_759995.url(scheme.get, call_759995.host, call_759995.base,
                         call_759995.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_759995, url, valid)

proc call*(call_759996: Call_GetV3ProjectsIdDeployments_759989; id: string;
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdDeployments
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The project ID
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_759997 = newJObject()
  var query_759998 = newJObject()
  add(path_759997, "id", newJString(id))
  add(query_759998, "per_page", newJInt(perPage))
  add(query_759998, "page", newJInt(page))
  result = call_759996.call(path_759997, query_759998, nil, nil, nil)

var getV3ProjectsIdDeployments* = Call_GetV3ProjectsIdDeployments_759989(
    name: "getV3ProjectsIdDeployments", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/deployments",
    validator: validate_GetV3ProjectsIdDeployments_759990, base: "/api",
    url: url_GetV3ProjectsIdDeployments_759991, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdDeploymentsDeploymentId_759999 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdDeploymentsDeploymentId_760001(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "deployment_id" in path, "`deployment_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "deployment_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdDeploymentsDeploymentId_760000(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   deployment_id: JInt (required)
  ##                : The deployment ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760002 = path.getOrDefault("id")
  valid_760002 = validateParameter(valid_760002, JString, required = true,
                                 default = nil)
  if valid_760002 != nil:
    section.add "id", valid_760002
  var valid_760003 = path.getOrDefault("deployment_id")
  valid_760003 = validateParameter(valid_760003, JInt, required = true, default = nil)
  if valid_760003 != nil:
    section.add "deployment_id", valid_760003
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760004: Call_GetV3ProjectsIdDeploymentsDeploymentId_759999;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_760004.validator(path, query, header, formData, body)
  let scheme = call_760004.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760004.url(scheme.get, call_760004.host, call_760004.base,
                         call_760004.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760004, url, valid)

proc call*(call_760005: Call_GetV3ProjectsIdDeploymentsDeploymentId_759999;
          id: string; deploymentId: int): Recallable =
  ## getV3ProjectsIdDeploymentsDeploymentId
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The project ID
  ##   deploymentId: int (required)
  ##               : The deployment ID
  var path_760006 = newJObject()
  add(path_760006, "id", newJString(id))
  add(path_760006, "deployment_id", newJInt(deploymentId))
  result = call_760005.call(path_760006, nil, nil, nil, nil)

var getV3ProjectsIdDeploymentsDeploymentId* = Call_GetV3ProjectsIdDeploymentsDeploymentId_759999(
    name: "getV3ProjectsIdDeploymentsDeploymentId", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/deployments/{deployment_id}",
    validator: validate_GetV3ProjectsIdDeploymentsDeploymentId_760000,
    base: "/api", url: url_GetV3ProjectsIdDeploymentsDeploymentId_760001,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdEnvironments_760017 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdEnvironments_760019(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/environments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdEnvironments_760018(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760020 = path.getOrDefault("id")
  valid_760020 = validateParameter(valid_760020, JString, required = true,
                                 default = nil)
  if valid_760020 != nil:
    section.add "id", valid_760020
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   slug: JString
  ##   external_url: JString
  ##               : URL on which this deployment is viewable
  ##   name: JString (required)
  ##       : The name of the environment to be created
  section = newJObject()
  var valid_760021 = formData.getOrDefault("slug")
  valid_760021 = validateParameter(valid_760021, JString, required = false,
                                 default = nil)
  if valid_760021 != nil:
    section.add "slug", valid_760021
  var valid_760022 = formData.getOrDefault("external_url")
  valid_760022 = validateParameter(valid_760022, JString, required = false,
                                 default = nil)
  if valid_760022 != nil:
    section.add "external_url", valid_760022
  assert formData != nil,
        "formData argument is necessary due to required `name` field"
  var valid_760023 = formData.getOrDefault("name")
  valid_760023 = validateParameter(valid_760023, JString, required = true,
                                 default = nil)
  if valid_760023 != nil:
    section.add "name", valid_760023
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760024: Call_PostV3ProjectsIdEnvironments_760017; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_760024.validator(path, query, header, formData, body)
  let scheme = call_760024.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760024.url(scheme.get, call_760024.host, call_760024.base,
                         call_760024.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760024, url, valid)

proc call*(call_760025: Call_PostV3ProjectsIdEnvironments_760017; id: string;
          name: string; slug: string = ""; externalUrl: string = ""): Recallable =
  ## postV3ProjectsIdEnvironments
  ## This feature was introduced in GitLab 8.11.
  ##   slug: string
  ##   id: string (required)
  ##     : The project ID
  ##   externalUrl: string
  ##              : URL on which this deployment is viewable
  ##   name: string (required)
  ##       : The name of the environment to be created
  var path_760026 = newJObject()
  var formData_760027 = newJObject()
  add(formData_760027, "slug", newJString(slug))
  add(path_760026, "id", newJString(id))
  add(formData_760027, "external_url", newJString(externalUrl))
  add(formData_760027, "name", newJString(name))
  result = call_760025.call(path_760026, nil, nil, formData_760027, nil)

var postV3ProjectsIdEnvironments* = Call_PostV3ProjectsIdEnvironments_760017(
    name: "postV3ProjectsIdEnvironments", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/environments",
    validator: validate_PostV3ProjectsIdEnvironments_760018, base: "/api",
    url: url_PostV3ProjectsIdEnvironments_760019, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdEnvironments_760007 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdEnvironments_760009(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/environments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdEnvironments_760008(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760010 = path.getOrDefault("id")
  valid_760010 = validateParameter(valid_760010, JString, required = true,
                                 default = nil)
  if valid_760010 != nil:
    section.add "id", valid_760010
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760011 = query.getOrDefault("per_page")
  valid_760011 = validateParameter(valid_760011, JInt, required = false, default = nil)
  if valid_760011 != nil:
    section.add "per_page", valid_760011
  var valid_760012 = query.getOrDefault("page")
  valid_760012 = validateParameter(valid_760012, JInt, required = false, default = nil)
  if valid_760012 != nil:
    section.add "page", valid_760012
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760013: Call_GetV3ProjectsIdEnvironments_760007; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_760013.validator(path, query, header, formData, body)
  let scheme = call_760013.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760013.url(scheme.get, call_760013.host, call_760013.base,
                         call_760013.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760013, url, valid)

proc call*(call_760014: Call_GetV3ProjectsIdEnvironments_760007; id: string;
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdEnvironments
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The project ID
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_760015 = newJObject()
  var query_760016 = newJObject()
  add(path_760015, "id", newJString(id))
  add(query_760016, "per_page", newJInt(perPage))
  add(query_760016, "page", newJInt(page))
  result = call_760014.call(path_760015, query_760016, nil, nil, nil)

var getV3ProjectsIdEnvironments* = Call_GetV3ProjectsIdEnvironments_760007(
    name: "getV3ProjectsIdEnvironments", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/environments",
    validator: validate_GetV3ProjectsIdEnvironments_760008, base: "/api",
    url: url_GetV3ProjectsIdEnvironments_760009, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdEnvironmentsEnvironmentId_760028 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdEnvironmentsEnvironmentId_760030(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "environment_id" in path, "`environment_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/environments/"),
               (kind: VariableSegment, value: "environment_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdEnvironmentsEnvironmentId_760029(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   environment_id: JInt (required)
  ##                 : The environment ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760031 = path.getOrDefault("id")
  valid_760031 = validateParameter(valid_760031, JString, required = true,
                                 default = nil)
  if valid_760031 != nil:
    section.add "id", valid_760031
  var valid_760032 = path.getOrDefault("environment_id")
  valid_760032 = validateParameter(valid_760032, JInt, required = true, default = nil)
  if valid_760032 != nil:
    section.add "environment_id", valid_760032
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   slug: JString
  ##   external_url: JString
  ##               : The new URL on which this deployment is viewable
  ##   name: JString
  ##       : The new environment name
  section = newJObject()
  var valid_760033 = formData.getOrDefault("slug")
  valid_760033 = validateParameter(valid_760033, JString, required = false,
                                 default = nil)
  if valid_760033 != nil:
    section.add "slug", valid_760033
  var valid_760034 = formData.getOrDefault("external_url")
  valid_760034 = validateParameter(valid_760034, JString, required = false,
                                 default = nil)
  if valid_760034 != nil:
    section.add "external_url", valid_760034
  var valid_760035 = formData.getOrDefault("name")
  valid_760035 = validateParameter(valid_760035, JString, required = false,
                                 default = nil)
  if valid_760035 != nil:
    section.add "name", valid_760035
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760036: Call_PutV3ProjectsIdEnvironmentsEnvironmentId_760028;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_760036.validator(path, query, header, formData, body)
  let scheme = call_760036.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760036.url(scheme.get, call_760036.host, call_760036.base,
                         call_760036.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760036, url, valid)

proc call*(call_760037: Call_PutV3ProjectsIdEnvironmentsEnvironmentId_760028;
          id: string; environmentId: int; slug: string = ""; externalUrl: string = "";
          name: string = ""): Recallable =
  ## putV3ProjectsIdEnvironmentsEnvironmentId
  ## This feature was introduced in GitLab 8.11.
  ##   slug: string
  ##   id: string (required)
  ##     : The project ID
  ##   externalUrl: string
  ##              : The new URL on which this deployment is viewable
  ##   environmentId: int (required)
  ##                : The environment ID
  ##   name: string
  ##       : The new environment name
  var path_760038 = newJObject()
  var formData_760039 = newJObject()
  add(formData_760039, "slug", newJString(slug))
  add(path_760038, "id", newJString(id))
  add(formData_760039, "external_url", newJString(externalUrl))
  add(path_760038, "environment_id", newJInt(environmentId))
  add(formData_760039, "name", newJString(name))
  result = call_760037.call(path_760038, nil, nil, formData_760039, nil)

var putV3ProjectsIdEnvironmentsEnvironmentId* = Call_PutV3ProjectsIdEnvironmentsEnvironmentId_760028(
    name: "putV3ProjectsIdEnvironmentsEnvironmentId", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/environments/{environment_id}",
    validator: validate_PutV3ProjectsIdEnvironmentsEnvironmentId_760029,
    base: "/api", url: url_PutV3ProjectsIdEnvironmentsEnvironmentId_760030,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdEnvironmentsEnvironmentId_760040 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdEnvironmentsEnvironmentId_760042(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "environment_id" in path, "`environment_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/environments/"),
               (kind: VariableSegment, value: "environment_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdEnvironmentsEnvironmentId_760041(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   environment_id: JInt (required)
  ##                 : The environment ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760043 = path.getOrDefault("id")
  valid_760043 = validateParameter(valid_760043, JString, required = true,
                                 default = nil)
  if valid_760043 != nil:
    section.add "id", valid_760043
  var valid_760044 = path.getOrDefault("environment_id")
  valid_760044 = validateParameter(valid_760044, JInt, required = true, default = nil)
  if valid_760044 != nil:
    section.add "environment_id", valid_760044
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760045: Call_DeleteV3ProjectsIdEnvironmentsEnvironmentId_760040;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_760045.validator(path, query, header, formData, body)
  let scheme = call_760045.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760045.url(scheme.get, call_760045.host, call_760045.base,
                         call_760045.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760045, url, valid)

proc call*(call_760046: Call_DeleteV3ProjectsIdEnvironmentsEnvironmentId_760040;
          id: string; environmentId: int): Recallable =
  ## deleteV3ProjectsIdEnvironmentsEnvironmentId
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The project ID
  ##   environmentId: int (required)
  ##                : The environment ID
  var path_760047 = newJObject()
  add(path_760047, "id", newJString(id))
  add(path_760047, "environment_id", newJInt(environmentId))
  result = call_760046.call(path_760047, nil, nil, nil, nil)

var deleteV3ProjectsIdEnvironmentsEnvironmentId* = Call_DeleteV3ProjectsIdEnvironmentsEnvironmentId_760040(
    name: "deleteV3ProjectsIdEnvironmentsEnvironmentId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/environments/{environment_id}",
    validator: validate_DeleteV3ProjectsIdEnvironmentsEnvironmentId_760041,
    base: "/api", url: url_DeleteV3ProjectsIdEnvironmentsEnvironmentId_760042,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdEvents_760048 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdEvents_760050(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdEvents_760049(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get events for a single project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760051 = path.getOrDefault("id")
  valid_760051 = validateParameter(valid_760051, JString, required = true,
                                 default = nil)
  if valid_760051 != nil:
    section.add "id", valid_760051
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760052 = query.getOrDefault("per_page")
  valid_760052 = validateParameter(valid_760052, JInt, required = false, default = nil)
  if valid_760052 != nil:
    section.add "per_page", valid_760052
  var valid_760053 = query.getOrDefault("page")
  valid_760053 = validateParameter(valid_760053, JInt, required = false, default = nil)
  if valid_760053 != nil:
    section.add "page", valid_760053
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760054: Call_GetV3ProjectsIdEvents_760048; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get events for a single project
  ## 
  let valid = call_760054.validator(path, query, header, formData, body)
  let scheme = call_760054.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760054.url(scheme.get, call_760054.host, call_760054.base,
                         call_760054.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760054, url, valid)

proc call*(call_760055: Call_GetV3ProjectsIdEvents_760048; id: string;
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdEvents
  ## Get events for a single project
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_760056 = newJObject()
  var query_760057 = newJObject()
  add(path_760056, "id", newJString(id))
  add(query_760057, "per_page", newJInt(perPage))
  add(query_760057, "page", newJInt(page))
  result = call_760055.call(path_760056, query_760057, nil, nil, nil)

var getV3ProjectsIdEvents* = Call_GetV3ProjectsIdEvents_760048(
    name: "getV3ProjectsIdEvents", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/events", validator: validate_GetV3ProjectsIdEvents_760049,
    base: "/api", url: url_GetV3ProjectsIdEvents_760050, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdFork_760058 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdFork_760060(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/fork")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdFork_760059(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove a forked_from relationship
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760061 = path.getOrDefault("id")
  valid_760061 = validateParameter(valid_760061, JString, required = true,
                                 default = nil)
  if valid_760061 != nil:
    section.add "id", valid_760061
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760062: Call_DeleteV3ProjectsIdFork_760058; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove a forked_from relationship
  ## 
  let valid = call_760062.validator(path, query, header, formData, body)
  let scheme = call_760062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760062.url(scheme.get, call_760062.host, call_760062.base,
                         call_760062.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760062, url, valid)

proc call*(call_760063: Call_DeleteV3ProjectsIdFork_760058; id: string): Recallable =
  ## deleteV3ProjectsIdFork
  ## Remove a forked_from relationship
  ##   id: string (required)
  ##     : The ID of a project
  var path_760064 = newJObject()
  add(path_760064, "id", newJString(id))
  result = call_760063.call(path_760064, nil, nil, nil, nil)

var deleteV3ProjectsIdFork* = Call_DeleteV3ProjectsIdFork_760058(
    name: "deleteV3ProjectsIdFork", meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/fork", validator: validate_DeleteV3ProjectsIdFork_760059,
    base: "/api", url: url_DeleteV3ProjectsIdFork_760060, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdForkForkedFromId_760065 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdForkForkedFromId_760067(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "forked_from_id" in path, "`forked_from_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/fork/"),
               (kind: VariableSegment, value: "forked_from_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdForkForkedFromId_760066(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Mark this project as forked from another
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   forked_from_id: JString (required)
  ##                 : The ID of the project it was forked from
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760068 = path.getOrDefault("id")
  valid_760068 = validateParameter(valid_760068, JString, required = true,
                                 default = nil)
  if valid_760068 != nil:
    section.add "id", valid_760068
  var valid_760069 = path.getOrDefault("forked_from_id")
  valid_760069 = validateParameter(valid_760069, JString, required = true,
                                 default = nil)
  if valid_760069 != nil:
    section.add "forked_from_id", valid_760069
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760070: Call_PostV3ProjectsIdForkForkedFromId_760065;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Mark this project as forked from another
  ## 
  let valid = call_760070.validator(path, query, header, formData, body)
  let scheme = call_760070.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760070.url(scheme.get, call_760070.host, call_760070.base,
                         call_760070.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760070, url, valid)

proc call*(call_760071: Call_PostV3ProjectsIdForkForkedFromId_760065; id: string;
          forkedFromId: string): Recallable =
  ## postV3ProjectsIdForkForkedFromId
  ## Mark this project as forked from another
  ##   id: string (required)
  ##     : The ID of a project
  ##   forkedFromId: string (required)
  ##               : The ID of the project it was forked from
  var path_760072 = newJObject()
  add(path_760072, "id", newJString(id))
  add(path_760072, "forked_from_id", newJString(forkedFromId))
  result = call_760071.call(path_760072, nil, nil, nil, nil)

var postV3ProjectsIdForkForkedFromId* = Call_PostV3ProjectsIdForkForkedFromId_760065(
    name: "postV3ProjectsIdForkForkedFromId", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/fork/{forked_from_id}",
    validator: validate_PostV3ProjectsIdForkForkedFromId_760066, base: "/api",
    url: url_PostV3ProjectsIdForkForkedFromId_760067, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdHooks_760083 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdHooks_760085(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdHooks_760084(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add hook to project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760086 = path.getOrDefault("id")
  valid_760086 = validateParameter(valid_760086, JString, required = true,
                                 default = nil)
  if valid_760086 != nil:
    section.add "id", valid_760086
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   enable_ssl_verification: JBool
  ##                          : Do SSL verification when triggering the hook
  ##   issues_events: JBool
  ##                : Trigger hook on issues events
  ##   merge_requests_events: JBool
  ##                        : Trigger hook on merge request events
  ##   url: JString (required)
  ##      : The URL to send the request to
  ##   note_events: JBool
  ##              : Trigger hook on note(comment) events
  ##   token: JString
  ##        : Secret token to validate received payloads; this will not be returned in the response
  ##   pipeline_events: JBool
  ##                  : Trigger hook on pipeline events
  ##   push_events: JBool
  ##              : Trigger hook on push events
  ##   wiki_page_events: JBool
  ##                   : Trigger hook on wiki events
  ##   tag_push_events: JBool
  ##                  : Trigger hook on tag push events
  ##   build_events: JBool
  ##               : Trigger hook on build events
  section = newJObject()
  var valid_760087 = formData.getOrDefault("enable_ssl_verification")
  valid_760087 = validateParameter(valid_760087, JBool, required = false, default = nil)
  if valid_760087 != nil:
    section.add "enable_ssl_verification", valid_760087
  var valid_760088 = formData.getOrDefault("issues_events")
  valid_760088 = validateParameter(valid_760088, JBool, required = false, default = nil)
  if valid_760088 != nil:
    section.add "issues_events", valid_760088
  var valid_760089 = formData.getOrDefault("merge_requests_events")
  valid_760089 = validateParameter(valid_760089, JBool, required = false, default = nil)
  if valid_760089 != nil:
    section.add "merge_requests_events", valid_760089
  assert formData != nil,
        "formData argument is necessary due to required `url` field"
  var valid_760090 = formData.getOrDefault("url")
  valid_760090 = validateParameter(valid_760090, JString, required = true,
                                 default = nil)
  if valid_760090 != nil:
    section.add "url", valid_760090
  var valid_760091 = formData.getOrDefault("note_events")
  valid_760091 = validateParameter(valid_760091, JBool, required = false, default = nil)
  if valid_760091 != nil:
    section.add "note_events", valid_760091
  var valid_760092 = formData.getOrDefault("token")
  valid_760092 = validateParameter(valid_760092, JString, required = false,
                                 default = nil)
  if valid_760092 != nil:
    section.add "token", valid_760092
  var valid_760093 = formData.getOrDefault("pipeline_events")
  valid_760093 = validateParameter(valid_760093, JBool, required = false, default = nil)
  if valid_760093 != nil:
    section.add "pipeline_events", valid_760093
  var valid_760094 = formData.getOrDefault("push_events")
  valid_760094 = validateParameter(valid_760094, JBool, required = false, default = nil)
  if valid_760094 != nil:
    section.add "push_events", valid_760094
  var valid_760095 = formData.getOrDefault("wiki_page_events")
  valid_760095 = validateParameter(valid_760095, JBool, required = false, default = nil)
  if valid_760095 != nil:
    section.add "wiki_page_events", valid_760095
  var valid_760096 = formData.getOrDefault("tag_push_events")
  valid_760096 = validateParameter(valid_760096, JBool, required = false, default = nil)
  if valid_760096 != nil:
    section.add "tag_push_events", valid_760096
  var valid_760097 = formData.getOrDefault("build_events")
  valid_760097 = validateParameter(valid_760097, JBool, required = false, default = nil)
  if valid_760097 != nil:
    section.add "build_events", valid_760097
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760098: Call_PostV3ProjectsIdHooks_760083; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Add hook to project
  ## 
  let valid = call_760098.validator(path, query, header, formData, body)
  let scheme = call_760098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760098.url(scheme.get, call_760098.host, call_760098.base,
                         call_760098.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760098, url, valid)

proc call*(call_760099: Call_PostV3ProjectsIdHooks_760083; id: string; url: string;
          enableSslVerification: bool = false; issuesEvents: bool = false;
          mergeRequestsEvents: bool = false; noteEvents: bool = false;
          token: string = ""; pipelineEvents: bool = false; pushEvents: bool = false;
          wikiPageEvents: bool = false; tagPushEvents: bool = false;
          buildEvents: bool = false): Recallable =
  ## postV3ProjectsIdHooks
  ## Add hook to project
  ##   id: string (required)
  ##     : The ID of a project
  ##   enableSslVerification: bool
  ##                        : Do SSL verification when triggering the hook
  ##   issuesEvents: bool
  ##               : Trigger hook on issues events
  ##   mergeRequestsEvents: bool
  ##                      : Trigger hook on merge request events
  ##   url: string (required)
  ##      : The URL to send the request to
  ##   noteEvents: bool
  ##             : Trigger hook on note(comment) events
  ##   token: string
  ##        : Secret token to validate received payloads; this will not be returned in the response
  ##   pipelineEvents: bool
  ##                 : Trigger hook on pipeline events
  ##   pushEvents: bool
  ##             : Trigger hook on push events
  ##   wikiPageEvents: bool
  ##                 : Trigger hook on wiki events
  ##   tagPushEvents: bool
  ##                : Trigger hook on tag push events
  ##   buildEvents: bool
  ##              : Trigger hook on build events
  var path_760100 = newJObject()
  var formData_760101 = newJObject()
  add(path_760100, "id", newJString(id))
  add(formData_760101, "enable_ssl_verification", newJBool(enableSslVerification))
  add(formData_760101, "issues_events", newJBool(issuesEvents))
  add(formData_760101, "merge_requests_events", newJBool(mergeRequestsEvents))
  add(formData_760101, "url", newJString(url))
  add(formData_760101, "note_events", newJBool(noteEvents))
  add(formData_760101, "token", newJString(token))
  add(formData_760101, "pipeline_events", newJBool(pipelineEvents))
  add(formData_760101, "push_events", newJBool(pushEvents))
  add(formData_760101, "wiki_page_events", newJBool(wikiPageEvents))
  add(formData_760101, "tag_push_events", newJBool(tagPushEvents))
  add(formData_760101, "build_events", newJBool(buildEvents))
  result = call_760099.call(path_760100, nil, nil, formData_760101, nil)

var postV3ProjectsIdHooks* = Call_PostV3ProjectsIdHooks_760083(
    name: "postV3ProjectsIdHooks", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/hooks", validator: validate_PostV3ProjectsIdHooks_760084,
    base: "/api", url: url_PostV3ProjectsIdHooks_760085, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdHooks_760073 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdHooks_760075(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdHooks_760074(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get project hooks
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760076 = path.getOrDefault("id")
  valid_760076 = validateParameter(valid_760076, JString, required = true,
                                 default = nil)
  if valid_760076 != nil:
    section.add "id", valid_760076
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760077 = query.getOrDefault("per_page")
  valid_760077 = validateParameter(valid_760077, JInt, required = false, default = nil)
  if valid_760077 != nil:
    section.add "per_page", valid_760077
  var valid_760078 = query.getOrDefault("page")
  valid_760078 = validateParameter(valid_760078, JInt, required = false, default = nil)
  if valid_760078 != nil:
    section.add "page", valid_760078
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760079: Call_GetV3ProjectsIdHooks_760073; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get project hooks
  ## 
  let valid = call_760079.validator(path, query, header, formData, body)
  let scheme = call_760079.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760079.url(scheme.get, call_760079.host, call_760079.base,
                         call_760079.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760079, url, valid)

proc call*(call_760080: Call_GetV3ProjectsIdHooks_760073; id: string;
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdHooks
  ## Get project hooks
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_760081 = newJObject()
  var query_760082 = newJObject()
  add(path_760081, "id", newJString(id))
  add(query_760082, "per_page", newJInt(perPage))
  add(query_760082, "page", newJInt(page))
  result = call_760080.call(path_760081, query_760082, nil, nil, nil)

var getV3ProjectsIdHooks* = Call_GetV3ProjectsIdHooks_760073(
    name: "getV3ProjectsIdHooks", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/hooks", validator: validate_GetV3ProjectsIdHooks_760074,
    base: "/api", url: url_GetV3ProjectsIdHooks_760075, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdHooksHookId_760110 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdHooksHookId_760112(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "hook_id" in path, "`hook_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hook_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdHooksHookId_760111(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update an existing project hook
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   hook_id: JInt (required)
  ##          : The ID of the hook to update
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `hook_id` field"
  var valid_760113 = path.getOrDefault("hook_id")
  valid_760113 = validateParameter(valid_760113, JInt, required = true, default = nil)
  if valid_760113 != nil:
    section.add "hook_id", valid_760113
  var valid_760114 = path.getOrDefault("id")
  valid_760114 = validateParameter(valid_760114, JString, required = true,
                                 default = nil)
  if valid_760114 != nil:
    section.add "id", valid_760114
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   enable_ssl_verification: JBool
  ##                          : Do SSL verification when triggering the hook
  ##   issues_events: JBool
  ##                : Trigger hook on issues events
  ##   merge_requests_events: JBool
  ##                        : Trigger hook on merge request events
  ##   url: JString (required)
  ##      : The URL to send the request to
  ##   note_events: JBool
  ##              : Trigger hook on note(comment) events
  ##   token: JString
  ##        : Secret token to validate received payloads; this will not be returned in the response
  ##   pipeline_events: JBool
  ##                  : Trigger hook on pipeline events
  ##   push_events: JBool
  ##              : Trigger hook on push events
  ##   wiki_page_events: JBool
  ##                   : Trigger hook on wiki events
  ##   tag_push_events: JBool
  ##                  : Trigger hook on tag push events
  ##   build_events: JBool
  ##               : Trigger hook on build events
  section = newJObject()
  var valid_760115 = formData.getOrDefault("enable_ssl_verification")
  valid_760115 = validateParameter(valid_760115, JBool, required = false, default = nil)
  if valid_760115 != nil:
    section.add "enable_ssl_verification", valid_760115
  var valid_760116 = formData.getOrDefault("issues_events")
  valid_760116 = validateParameter(valid_760116, JBool, required = false, default = nil)
  if valid_760116 != nil:
    section.add "issues_events", valid_760116
  var valid_760117 = formData.getOrDefault("merge_requests_events")
  valid_760117 = validateParameter(valid_760117, JBool, required = false, default = nil)
  if valid_760117 != nil:
    section.add "merge_requests_events", valid_760117
  assert formData != nil,
        "formData argument is necessary due to required `url` field"
  var valid_760118 = formData.getOrDefault("url")
  valid_760118 = validateParameter(valid_760118, JString, required = true,
                                 default = nil)
  if valid_760118 != nil:
    section.add "url", valid_760118
  var valid_760119 = formData.getOrDefault("note_events")
  valid_760119 = validateParameter(valid_760119, JBool, required = false, default = nil)
  if valid_760119 != nil:
    section.add "note_events", valid_760119
  var valid_760120 = formData.getOrDefault("token")
  valid_760120 = validateParameter(valid_760120, JString, required = false,
                                 default = nil)
  if valid_760120 != nil:
    section.add "token", valid_760120
  var valid_760121 = formData.getOrDefault("pipeline_events")
  valid_760121 = validateParameter(valid_760121, JBool, required = false, default = nil)
  if valid_760121 != nil:
    section.add "pipeline_events", valid_760121
  var valid_760122 = formData.getOrDefault("push_events")
  valid_760122 = validateParameter(valid_760122, JBool, required = false, default = nil)
  if valid_760122 != nil:
    section.add "push_events", valid_760122
  var valid_760123 = formData.getOrDefault("wiki_page_events")
  valid_760123 = validateParameter(valid_760123, JBool, required = false, default = nil)
  if valid_760123 != nil:
    section.add "wiki_page_events", valid_760123
  var valid_760124 = formData.getOrDefault("tag_push_events")
  valid_760124 = validateParameter(valid_760124, JBool, required = false, default = nil)
  if valid_760124 != nil:
    section.add "tag_push_events", valid_760124
  var valid_760125 = formData.getOrDefault("build_events")
  valid_760125 = validateParameter(valid_760125, JBool, required = false, default = nil)
  if valid_760125 != nil:
    section.add "build_events", valid_760125
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760126: Call_PutV3ProjectsIdHooksHookId_760110; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update an existing project hook
  ## 
  let valid = call_760126.validator(path, query, header, formData, body)
  let scheme = call_760126.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760126.url(scheme.get, call_760126.host, call_760126.base,
                         call_760126.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760126, url, valid)

proc call*(call_760127: Call_PutV3ProjectsIdHooksHookId_760110; hookId: int;
          id: string; url: string; enableSslVerification: bool = false;
          issuesEvents: bool = false; mergeRequestsEvents: bool = false;
          noteEvents: bool = false; token: string = ""; pipelineEvents: bool = false;
          pushEvents: bool = false; wikiPageEvents: bool = false;
          tagPushEvents: bool = false; buildEvents: bool = false): Recallable =
  ## putV3ProjectsIdHooksHookId
  ## Update an existing project hook
  ##   hookId: int (required)
  ##         : The ID of the hook to update
  ##   id: string (required)
  ##     : The ID of a project
  ##   enableSslVerification: bool
  ##                        : Do SSL verification when triggering the hook
  ##   issuesEvents: bool
  ##               : Trigger hook on issues events
  ##   mergeRequestsEvents: bool
  ##                      : Trigger hook on merge request events
  ##   url: string (required)
  ##      : The URL to send the request to
  ##   noteEvents: bool
  ##             : Trigger hook on note(comment) events
  ##   token: string
  ##        : Secret token to validate received payloads; this will not be returned in the response
  ##   pipelineEvents: bool
  ##                 : Trigger hook on pipeline events
  ##   pushEvents: bool
  ##             : Trigger hook on push events
  ##   wikiPageEvents: bool
  ##                 : Trigger hook on wiki events
  ##   tagPushEvents: bool
  ##                : Trigger hook on tag push events
  ##   buildEvents: bool
  ##              : Trigger hook on build events
  var path_760128 = newJObject()
  var formData_760129 = newJObject()
  add(path_760128, "hook_id", newJInt(hookId))
  add(path_760128, "id", newJString(id))
  add(formData_760129, "enable_ssl_verification", newJBool(enableSslVerification))
  add(formData_760129, "issues_events", newJBool(issuesEvents))
  add(formData_760129, "merge_requests_events", newJBool(mergeRequestsEvents))
  add(formData_760129, "url", newJString(url))
  add(formData_760129, "note_events", newJBool(noteEvents))
  add(formData_760129, "token", newJString(token))
  add(formData_760129, "pipeline_events", newJBool(pipelineEvents))
  add(formData_760129, "push_events", newJBool(pushEvents))
  add(formData_760129, "wiki_page_events", newJBool(wikiPageEvents))
  add(formData_760129, "tag_push_events", newJBool(tagPushEvents))
  add(formData_760129, "build_events", newJBool(buildEvents))
  result = call_760127.call(path_760128, nil, nil, formData_760129, nil)

var putV3ProjectsIdHooksHookId* = Call_PutV3ProjectsIdHooksHookId_760110(
    name: "putV3ProjectsIdHooksHookId", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/hooks/{hook_id}",
    validator: validate_PutV3ProjectsIdHooksHookId_760111, base: "/api",
    url: url_PutV3ProjectsIdHooksHookId_760112, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdHooksHookId_760102 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdHooksHookId_760104(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "hook_id" in path, "`hook_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hook_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdHooksHookId_760103(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a project hook
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   hook_id: JInt (required)
  ##          : The ID of a project hook
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `hook_id` field"
  var valid_760105 = path.getOrDefault("hook_id")
  valid_760105 = validateParameter(valid_760105, JInt, required = true, default = nil)
  if valid_760105 != nil:
    section.add "hook_id", valid_760105
  var valid_760106 = path.getOrDefault("id")
  valid_760106 = validateParameter(valid_760106, JString, required = true,
                                 default = nil)
  if valid_760106 != nil:
    section.add "id", valid_760106
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760107: Call_GetV3ProjectsIdHooksHookId_760102; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a project hook
  ## 
  let valid = call_760107.validator(path, query, header, formData, body)
  let scheme = call_760107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760107.url(scheme.get, call_760107.host, call_760107.base,
                         call_760107.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760107, url, valid)

proc call*(call_760108: Call_GetV3ProjectsIdHooksHookId_760102; hookId: int;
          id: string): Recallable =
  ## getV3ProjectsIdHooksHookId
  ## Get a project hook
  ##   hookId: int (required)
  ##         : The ID of a project hook
  ##   id: string (required)
  ##     : The ID of a project
  var path_760109 = newJObject()
  add(path_760109, "hook_id", newJInt(hookId))
  add(path_760109, "id", newJString(id))
  result = call_760108.call(path_760109, nil, nil, nil, nil)

var getV3ProjectsIdHooksHookId* = Call_GetV3ProjectsIdHooksHookId_760102(
    name: "getV3ProjectsIdHooksHookId", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/hooks/{hook_id}",
    validator: validate_GetV3ProjectsIdHooksHookId_760103, base: "/api",
    url: url_GetV3ProjectsIdHooksHookId_760104, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdHooksHookId_760130 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdHooksHookId_760132(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "hook_id" in path, "`hook_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hook_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdHooksHookId_760131(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes project hook
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   hook_id: JInt (required)
  ##          : The ID of the hook to delete
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `hook_id` field"
  var valid_760133 = path.getOrDefault("hook_id")
  valid_760133 = validateParameter(valid_760133, JInt, required = true, default = nil)
  if valid_760133 != nil:
    section.add "hook_id", valid_760133
  var valid_760134 = path.getOrDefault("id")
  valid_760134 = validateParameter(valid_760134, JString, required = true,
                                 default = nil)
  if valid_760134 != nil:
    section.add "id", valid_760134
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760135: Call_DeleteV3ProjectsIdHooksHookId_760130; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes project hook
  ## 
  let valid = call_760135.validator(path, query, header, formData, body)
  let scheme = call_760135.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760135.url(scheme.get, call_760135.host, call_760135.base,
                         call_760135.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760135, url, valid)

proc call*(call_760136: Call_DeleteV3ProjectsIdHooksHookId_760130; hookId: int;
          id: string): Recallable =
  ## deleteV3ProjectsIdHooksHookId
  ## Deletes project hook
  ##   hookId: int (required)
  ##         : The ID of the hook to delete
  ##   id: string (required)
  ##     : The ID of a project
  var path_760137 = newJObject()
  add(path_760137, "hook_id", newJInt(hookId))
  add(path_760137, "id", newJString(id))
  result = call_760136.call(path_760137, nil, nil, nil, nil)

var deleteV3ProjectsIdHooksHookId* = Call_DeleteV3ProjectsIdHooksHookId_760130(
    name: "deleteV3ProjectsIdHooksHookId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/hooks/{hook_id}",
    validator: validate_DeleteV3ProjectsIdHooksHookId_760131, base: "/api",
    url: url_DeleteV3ProjectsIdHooksHookId_760132, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssues_760154 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssues_760156(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssues_760155(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new project issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760157 = path.getOrDefault("id")
  valid_760157 = validateParameter(valid_760157, JString, required = true,
                                 default = nil)
  if valid_760157 != nil:
    section.add "id", valid_760157
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   title: JString (required)
  ##        : The title of an issue
  ##   labels: JString
  ##         : Comma-separated list of label names
  ##   milestone_id: JInt
  ##               : The ID of a milestone to assign issue
  ##   merge_request_for_resolving_discussions: JInt
  ##                                          : The IID of a merge request for which to resolve discussions
  ##   assignee_id: JInt
  ##              : The ID of a user to assign issue
  ##   created_at: JString
  ##             : Date time when the issue was created. Available only for admins and project owners.
  ##   due_date: JString
  ##           : Date time string in the format YEAR-MONTH-DAY
  ##   confidential: JBool
  ##               : Boolean parameter if the issue should be confidential
  ##   description: JString
  ##              : The description of an issue
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `title` field"
  var valid_760158 = formData.getOrDefault("title")
  valid_760158 = validateParameter(valid_760158, JString, required = true,
                                 default = nil)
  if valid_760158 != nil:
    section.add "title", valid_760158
  var valid_760159 = formData.getOrDefault("labels")
  valid_760159 = validateParameter(valid_760159, JString, required = false,
                                 default = nil)
  if valid_760159 != nil:
    section.add "labels", valid_760159
  var valid_760160 = formData.getOrDefault("milestone_id")
  valid_760160 = validateParameter(valid_760160, JInt, required = false, default = nil)
  if valid_760160 != nil:
    section.add "milestone_id", valid_760160
  var valid_760161 = formData.getOrDefault("merge_request_for_resolving_discussions")
  valid_760161 = validateParameter(valid_760161, JInt, required = false, default = nil)
  if valid_760161 != nil:
    section.add "merge_request_for_resolving_discussions", valid_760161
  var valid_760162 = formData.getOrDefault("assignee_id")
  valid_760162 = validateParameter(valid_760162, JInt, required = false, default = nil)
  if valid_760162 != nil:
    section.add "assignee_id", valid_760162
  var valid_760163 = formData.getOrDefault("created_at")
  valid_760163 = validateParameter(valid_760163, JString, required = false,
                                 default = nil)
  if valid_760163 != nil:
    section.add "created_at", valid_760163
  var valid_760164 = formData.getOrDefault("due_date")
  valid_760164 = validateParameter(valid_760164, JString, required = false,
                                 default = nil)
  if valid_760164 != nil:
    section.add "due_date", valid_760164
  var valid_760165 = formData.getOrDefault("confidential")
  valid_760165 = validateParameter(valid_760165, JBool, required = false, default = nil)
  if valid_760165 != nil:
    section.add "confidential", valid_760165
  var valid_760166 = formData.getOrDefault("description")
  valid_760166 = validateParameter(valid_760166, JString, required = false,
                                 default = nil)
  if valid_760166 != nil:
    section.add "description", valid_760166
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760167: Call_PostV3ProjectsIdIssues_760154; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new project issue
  ## 
  let valid = call_760167.validator(path, query, header, formData, body)
  let scheme = call_760167.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760167.url(scheme.get, call_760167.host, call_760167.base,
                         call_760167.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760167, url, valid)

proc call*(call_760168: Call_PostV3ProjectsIdIssues_760154; title: string;
          id: string; labels: string = ""; milestoneId: int = 0;
          mergeRequestForResolvingDiscussions: int = 0; assigneeId: int = 0;
          createdAt: string = ""; dueDate: string = ""; confidential: bool = false;
          description: string = ""): Recallable =
  ## postV3ProjectsIdIssues
  ## Create a new project issue
  ##   title: string (required)
  ##        : The title of an issue
  ##   labels: string
  ##         : Comma-separated list of label names
  ##   id: string (required)
  ##     : The ID of a project
  ##   milestoneId: int
  ##              : The ID of a milestone to assign issue
  ##   mergeRequestForResolvingDiscussions: int
  ##                                      : The IID of a merge request for which to resolve discussions
  ##   assigneeId: int
  ##             : The ID of a user to assign issue
  ##   createdAt: string
  ##            : Date time when the issue was created. Available only for admins and project owners.
  ##   dueDate: string
  ##          : Date time string in the format YEAR-MONTH-DAY
  ##   confidential: bool
  ##               : Boolean parameter if the issue should be confidential
  ##   description: string
  ##              : The description of an issue
  var path_760169 = newJObject()
  var formData_760170 = newJObject()
  add(formData_760170, "title", newJString(title))
  add(formData_760170, "labels", newJString(labels))
  add(path_760169, "id", newJString(id))
  add(formData_760170, "milestone_id", newJInt(milestoneId))
  add(formData_760170, "merge_request_for_resolving_discussions",
      newJInt(mergeRequestForResolvingDiscussions))
  add(formData_760170, "assignee_id", newJInt(assigneeId))
  add(formData_760170, "created_at", newJString(createdAt))
  add(formData_760170, "due_date", newJString(dueDate))
  add(formData_760170, "confidential", newJBool(confidential))
  add(formData_760170, "description", newJString(description))
  result = call_760168.call(path_760169, nil, nil, formData_760170, nil)

var postV3ProjectsIdIssues* = Call_PostV3ProjectsIdIssues_760154(
    name: "postV3ProjectsIdIssues", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/issues", validator: validate_PostV3ProjectsIdIssues_760155,
    base: "/api", url: url_PostV3ProjectsIdIssues_760156, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdIssues_760138 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdIssues_760140(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdIssues_760139(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a list of project issues
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760141 = path.getOrDefault("id")
  valid_760141 = validateParameter(valid_760141, JString, required = true,
                                 default = nil)
  if valid_760141 != nil:
    section.add "id", valid_760141
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString
  ##         : Comma-separated list of label names
  ##   iid: JInt
  ##      : Return the issue having the given `iid`
  ##   state: JString
  ##        : Return opened, closed, or all issues
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   milestone: JString
  ##            : Return issues for a specific milestone
  ##   order_by: JString
  ##           : Return issues ordered by `created_at` or `updated_at` fields.
  ##   sort: JString
  ##       : Return issues sorted in `asc` or `desc` order.
  section = newJObject()
  var valid_760142 = query.getOrDefault("labels")
  valid_760142 = validateParameter(valid_760142, JString, required = false,
                                 default = nil)
  if valid_760142 != nil:
    section.add "labels", valid_760142
  var valid_760143 = query.getOrDefault("iid")
  valid_760143 = validateParameter(valid_760143, JInt, required = false, default = nil)
  if valid_760143 != nil:
    section.add "iid", valid_760143
  var valid_760144 = query.getOrDefault("state")
  valid_760144 = validateParameter(valid_760144, JString, required = false,
                                 default = newJString("all"))
  if valid_760144 != nil:
    section.add "state", valid_760144
  var valid_760145 = query.getOrDefault("per_page")
  valid_760145 = validateParameter(valid_760145, JInt, required = false, default = nil)
  if valid_760145 != nil:
    section.add "per_page", valid_760145
  var valid_760146 = query.getOrDefault("page")
  valid_760146 = validateParameter(valid_760146, JInt, required = false, default = nil)
  if valid_760146 != nil:
    section.add "page", valid_760146
  var valid_760147 = query.getOrDefault("milestone")
  valid_760147 = validateParameter(valid_760147, JString, required = false,
                                 default = nil)
  if valid_760147 != nil:
    section.add "milestone", valid_760147
  var valid_760148 = query.getOrDefault("order_by")
  valid_760148 = validateParameter(valid_760148, JString, required = false,
                                 default = newJString("created_at"))
  if valid_760148 != nil:
    section.add "order_by", valid_760148
  var valid_760149 = query.getOrDefault("sort")
  valid_760149 = validateParameter(valid_760149, JString, required = false,
                                 default = newJString("desc"))
  if valid_760149 != nil:
    section.add "sort", valid_760149
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760150: Call_GetV3ProjectsIdIssues_760138; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a list of project issues
  ## 
  let valid = call_760150.validator(path, query, header, formData, body)
  let scheme = call_760150.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760150.url(scheme.get, call_760150.host, call_760150.base,
                         call_760150.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760150, url, valid)

proc call*(call_760151: Call_GetV3ProjectsIdIssues_760138; id: string;
          labels: string = ""; iid: int = 0; state: string = "all"; perPage: int = 0;
          page: int = 0; milestone: string = ""; orderBy: string = "created_at";
          sort: string = "desc"): Recallable =
  ## getV3ProjectsIdIssues
  ## Get a list of project issues
  ##   labels: string
  ##         : Comma-separated list of label names
  ##   iid: int
  ##      : Return the issue having the given `iid`
  ##   id: string (required)
  ##     : The ID of a project
  ##   state: string
  ##        : Return opened, closed, or all issues
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   milestone: string
  ##            : Return issues for a specific milestone
  ##   orderBy: string
  ##          : Return issues ordered by `created_at` or `updated_at` fields.
  ##   sort: string
  ##       : Return issues sorted in `asc` or `desc` order.
  var path_760152 = newJObject()
  var query_760153 = newJObject()
  add(query_760153, "labels", newJString(labels))
  add(query_760153, "iid", newJInt(iid))
  add(path_760152, "id", newJString(id))
  add(query_760153, "state", newJString(state))
  add(query_760153, "per_page", newJInt(perPage))
  add(query_760153, "page", newJInt(page))
  add(query_760153, "milestone", newJString(milestone))
  add(query_760153, "order_by", newJString(orderBy))
  add(query_760153, "sort", newJString(sort))
  result = call_760151.call(path_760152, query_760153, nil, nil, nil)

var getV3ProjectsIdIssues* = Call_GetV3ProjectsIdIssues_760138(
    name: "getV3ProjectsIdIssues", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/issues", validator: validate_GetV3ProjectsIdIssues_760139,
    base: "/api", url: url_GetV3ProjectsIdIssues_760140, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdIssuesIssueId_760179 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdIssuesIssueId_760181(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdIssuesIssueId_760180(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update an existing issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of a project issue
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760182 = path.getOrDefault("id")
  valid_760182 = validateParameter(valid_760182, JString, required = true,
                                 default = nil)
  if valid_760182 != nil:
    section.add "id", valid_760182
  var valid_760183 = path.getOrDefault("issue_id")
  valid_760183 = validateParameter(valid_760183, JInt, required = true, default = nil)
  if valid_760183 != nil:
    section.add "issue_id", valid_760183
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   title: JString
  ##        : The title of an issue
  ##   labels: JString
  ##         : Comma-separated list of label names
  ##   milestone_id: JInt
  ##               : The ID of a milestone to assign issue
  ##   assignee_id: JInt
  ##              : The ID of a user to assign issue
  ##   created_at: JString
  ##   due_date: JString
  ##           : Date time string in the format YEAR-MONTH-DAY
  ##   confidential: JBool
  ##               : Boolean parameter if the issue should be confidential
  ##   description: JString
  ##              : The description of an issue
  ##   updated_at: JString
  ##             : Date time when the issue was updated. Available only for admins and project owners.
  ##   state_event: JString
  ##              : State of the issue
  section = newJObject()
  var valid_760184 = formData.getOrDefault("title")
  valid_760184 = validateParameter(valid_760184, JString, required = false,
                                 default = nil)
  if valid_760184 != nil:
    section.add "title", valid_760184
  var valid_760185 = formData.getOrDefault("labels")
  valid_760185 = validateParameter(valid_760185, JString, required = false,
                                 default = nil)
  if valid_760185 != nil:
    section.add "labels", valid_760185
  var valid_760186 = formData.getOrDefault("milestone_id")
  valid_760186 = validateParameter(valid_760186, JInt, required = false, default = nil)
  if valid_760186 != nil:
    section.add "milestone_id", valid_760186
  var valid_760187 = formData.getOrDefault("assignee_id")
  valid_760187 = validateParameter(valid_760187, JInt, required = false, default = nil)
  if valid_760187 != nil:
    section.add "assignee_id", valid_760187
  var valid_760188 = formData.getOrDefault("created_at")
  valid_760188 = validateParameter(valid_760188, JString, required = false,
                                 default = nil)
  if valid_760188 != nil:
    section.add "created_at", valid_760188
  var valid_760189 = formData.getOrDefault("due_date")
  valid_760189 = validateParameter(valid_760189, JString, required = false,
                                 default = nil)
  if valid_760189 != nil:
    section.add "due_date", valid_760189
  var valid_760190 = formData.getOrDefault("confidential")
  valid_760190 = validateParameter(valid_760190, JBool, required = false, default = nil)
  if valid_760190 != nil:
    section.add "confidential", valid_760190
  var valid_760191 = formData.getOrDefault("description")
  valid_760191 = validateParameter(valid_760191, JString, required = false,
                                 default = nil)
  if valid_760191 != nil:
    section.add "description", valid_760191
  var valid_760192 = formData.getOrDefault("updated_at")
  valid_760192 = validateParameter(valid_760192, JString, required = false,
                                 default = nil)
  if valid_760192 != nil:
    section.add "updated_at", valid_760192
  var valid_760193 = formData.getOrDefault("state_event")
  valid_760193 = validateParameter(valid_760193, JString, required = false,
                                 default = newJString("reopen"))
  if valid_760193 != nil:
    section.add "state_event", valid_760193
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760194: Call_PutV3ProjectsIdIssuesIssueId_760179; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update an existing issue
  ## 
  let valid = call_760194.validator(path, query, header, formData, body)
  let scheme = call_760194.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760194.url(scheme.get, call_760194.host, call_760194.base,
                         call_760194.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760194, url, valid)

proc call*(call_760195: Call_PutV3ProjectsIdIssuesIssueId_760179; id: string;
          issueId: int; title: string = ""; labels: string = ""; milestoneId: int = 0;
          assigneeId: int = 0; createdAt: string = ""; dueDate: string = "";
          confidential: bool = false; description: string = ""; updatedAt: string = "";
          stateEvent: string = "reopen"): Recallable =
  ## putV3ProjectsIdIssuesIssueId
  ## Update an existing issue
  ##   title: string
  ##        : The title of an issue
  ##   labels: string
  ##         : Comma-separated list of label names
  ##   id: string (required)
  ##     : The ID of a project
  ##   milestoneId: int
  ##              : The ID of a milestone to assign issue
  ##   assigneeId: int
  ##             : The ID of a user to assign issue
  ##   createdAt: string
  ##   dueDate: string
  ##          : Date time string in the format YEAR-MONTH-DAY
  ##   issueId: int (required)
  ##          : The ID of a project issue
  ##   confidential: bool
  ##               : Boolean parameter if the issue should be confidential
  ##   description: string
  ##              : The description of an issue
  ##   updatedAt: string
  ##            : Date time when the issue was updated. Available only for admins and project owners.
  ##   stateEvent: string
  ##             : State of the issue
  var path_760196 = newJObject()
  var formData_760197 = newJObject()
  add(formData_760197, "title", newJString(title))
  add(formData_760197, "labels", newJString(labels))
  add(path_760196, "id", newJString(id))
  add(formData_760197, "milestone_id", newJInt(milestoneId))
  add(formData_760197, "assignee_id", newJInt(assigneeId))
  add(formData_760197, "created_at", newJString(createdAt))
  add(formData_760197, "due_date", newJString(dueDate))
  add(path_760196, "issue_id", newJInt(issueId))
  add(formData_760197, "confidential", newJBool(confidential))
  add(formData_760197, "description", newJString(description))
  add(formData_760197, "updated_at", newJString(updatedAt))
  add(formData_760197, "state_event", newJString(stateEvent))
  result = call_760195.call(path_760196, nil, nil, formData_760197, nil)

var putV3ProjectsIdIssuesIssueId* = Call_PutV3ProjectsIdIssuesIssueId_760179(
    name: "putV3ProjectsIdIssuesIssueId", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/issues/{issue_id}",
    validator: validate_PutV3ProjectsIdIssuesIssueId_760180, base: "/api",
    url: url_PutV3ProjectsIdIssuesIssueId_760181, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdIssuesIssueId_760171 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdIssuesIssueId_760173(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdIssuesIssueId_760172(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single project issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of a project issue
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760174 = path.getOrDefault("id")
  valid_760174 = validateParameter(valid_760174, JString, required = true,
                                 default = nil)
  if valid_760174 != nil:
    section.add "id", valid_760174
  var valid_760175 = path.getOrDefault("issue_id")
  valid_760175 = validateParameter(valid_760175, JInt, required = true, default = nil)
  if valid_760175 != nil:
    section.add "issue_id", valid_760175
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760176: Call_GetV3ProjectsIdIssuesIssueId_760171; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single project issue
  ## 
  let valid = call_760176.validator(path, query, header, formData, body)
  let scheme = call_760176.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760176.url(scheme.get, call_760176.host, call_760176.base,
                         call_760176.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760176, url, valid)

proc call*(call_760177: Call_GetV3ProjectsIdIssuesIssueId_760171; id: string;
          issueId: int): Recallable =
  ## getV3ProjectsIdIssuesIssueId
  ## Get a single project issue
  ##   id: string (required)
  ##     : The ID of a project
  ##   issueId: int (required)
  ##          : The ID of a project issue
  var path_760178 = newJObject()
  add(path_760178, "id", newJString(id))
  add(path_760178, "issue_id", newJInt(issueId))
  result = call_760177.call(path_760178, nil, nil, nil, nil)

var getV3ProjectsIdIssuesIssueId* = Call_GetV3ProjectsIdIssuesIssueId_760171(
    name: "getV3ProjectsIdIssuesIssueId", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/issues/{issue_id}",
    validator: validate_GetV3ProjectsIdIssuesIssueId_760172, base: "/api",
    url: url_GetV3ProjectsIdIssuesIssueId_760173, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdIssuesIssueId_760198 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdIssuesIssueId_760200(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdIssuesIssueId_760199(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a project issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of a project issue
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760201 = path.getOrDefault("id")
  valid_760201 = validateParameter(valid_760201, JString, required = true,
                                 default = nil)
  if valid_760201 != nil:
    section.add "id", valid_760201
  var valid_760202 = path.getOrDefault("issue_id")
  valid_760202 = validateParameter(valid_760202, JInt, required = true, default = nil)
  if valid_760202 != nil:
    section.add "issue_id", valid_760202
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760203: Call_DeleteV3ProjectsIdIssuesIssueId_760198;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a project issue
  ## 
  let valid = call_760203.validator(path, query, header, formData, body)
  let scheme = call_760203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760203.url(scheme.get, call_760203.host, call_760203.base,
                         call_760203.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760203, url, valid)

proc call*(call_760204: Call_DeleteV3ProjectsIdIssuesIssueId_760198; id: string;
          issueId: int): Recallable =
  ## deleteV3ProjectsIdIssuesIssueId
  ## Delete a project issue
  ##   id: string (required)
  ##     : The ID of a project
  ##   issueId: int (required)
  ##          : The ID of a project issue
  var path_760205 = newJObject()
  add(path_760205, "id", newJString(id))
  add(path_760205, "issue_id", newJInt(issueId))
  result = call_760204.call(path_760205, nil, nil, nil, nil)

var deleteV3ProjectsIdIssuesIssueId* = Call_DeleteV3ProjectsIdIssuesIssueId_760198(
    name: "deleteV3ProjectsIdIssuesIssueId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/issues/{issue_id}",
    validator: validate_DeleteV3ProjectsIdIssuesIssueId_760199, base: "/api",
    url: url_DeleteV3ProjectsIdIssuesIssueId_760200, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssuesIssueIdAddSpentTime_760206 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssuesIssueIdAddSpentTime_760208(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/add_spent_time")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssuesIssueIdAddSpentTime_760207(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add spent time for a project issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of a project issue
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760209 = path.getOrDefault("id")
  valid_760209 = validateParameter(valid_760209, JString, required = true,
                                 default = nil)
  if valid_760209 != nil:
    section.add "id", valid_760209
  var valid_760210 = path.getOrDefault("issue_id")
  valid_760210 = validateParameter(valid_760210, JInt, required = true, default = nil)
  if valid_760210 != nil:
    section.add "issue_id", valid_760210
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   duration: JString (required)
  ##           : The duration to be parsed
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `duration` field"
  var valid_760211 = formData.getOrDefault("duration")
  valid_760211 = validateParameter(valid_760211, JString, required = true,
                                 default = nil)
  if valid_760211 != nil:
    section.add "duration", valid_760211
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760212: Call_PostV3ProjectsIdIssuesIssueIdAddSpentTime_760206;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add spent time for a project issue
  ## 
  let valid = call_760212.validator(path, query, header, formData, body)
  let scheme = call_760212.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760212.url(scheme.get, call_760212.host, call_760212.base,
                         call_760212.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760212, url, valid)

proc call*(call_760213: Call_PostV3ProjectsIdIssuesIssueIdAddSpentTime_760206;
          id: string; issueId: int; duration: string): Recallable =
  ## postV3ProjectsIdIssuesIssueIdAddSpentTime
  ## Add spent time for a project issue
  ##   id: string (required)
  ##     : The ID of a project
  ##   issueId: int (required)
  ##          : The ID of a project issue
  ##   duration: string (required)
  ##           : The duration to be parsed
  var path_760214 = newJObject()
  var formData_760215 = newJObject()
  add(path_760214, "id", newJString(id))
  add(path_760214, "issue_id", newJInt(issueId))
  add(formData_760215, "duration", newJString(duration))
  result = call_760213.call(path_760214, nil, nil, formData_760215, nil)

var postV3ProjectsIdIssuesIssueIdAddSpentTime* = Call_PostV3ProjectsIdIssuesIssueIdAddSpentTime_760206(
    name: "postV3ProjectsIdIssuesIssueIdAddSpentTime", meth: HttpMethod.HttpPost,
    host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{issue_id}/add_spent_time",
    validator: validate_PostV3ProjectsIdIssuesIssueIdAddSpentTime_760207,
    base: "/api", url: url_PostV3ProjectsIdIssuesIssueIdAddSpentTime_760208,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssuesIssueIdAwardEmoji_760227 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssuesIssueIdAwardEmoji_760229(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssuesIssueIdAwardEmoji_760228(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   issue_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760230 = path.getOrDefault("id")
  valid_760230 = validateParameter(valid_760230, JInt, required = true, default = nil)
  if valid_760230 != nil:
    section.add "id", valid_760230
  var valid_760231 = path.getOrDefault("issue_id")
  valid_760231 = validateParameter(valid_760231, JInt, required = true, default = nil)
  if valid_760231 != nil:
    section.add "issue_id", valid_760231
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   name: JString (required)
  ##       : The name of a award_emoji (without colons)
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `name` field"
  var valid_760232 = formData.getOrDefault("name")
  valid_760232 = validateParameter(valid_760232, JString, required = true,
                                 default = nil)
  if valid_760232 != nil:
    section.add "name", valid_760232
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760233: Call_PostV3ProjectsIdIssuesIssueIdAwardEmoji_760227;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760233.validator(path, query, header, formData, body)
  let scheme = call_760233.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760233.url(scheme.get, call_760233.host, call_760233.base,
                         call_760233.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760233, url, valid)

proc call*(call_760234: Call_PostV3ProjectsIdIssuesIssueIdAwardEmoji_760227;
          id: int; issueId: int; name: string): Recallable =
  ## postV3ProjectsIdIssuesIssueIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   issueId: int (required)
  ##   name: string (required)
  ##       : The name of a award_emoji (without colons)
  var path_760235 = newJObject()
  var formData_760236 = newJObject()
  add(path_760235, "id", newJInt(id))
  add(path_760235, "issue_id", newJInt(issueId))
  add(formData_760236, "name", newJString(name))
  result = call_760234.call(path_760235, nil, nil, formData_760236, nil)

var postV3ProjectsIdIssuesIssueIdAwardEmoji* = Call_PostV3ProjectsIdIssuesIssueIdAwardEmoji_760227(
    name: "postV3ProjectsIdIssuesIssueIdAwardEmoji", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/issues/{issue_id}/award_emoji",
    validator: validate_PostV3ProjectsIdIssuesIssueIdAwardEmoji_760228,
    base: "/api", url: url_PostV3ProjectsIdIssuesIssueIdAwardEmoji_760229,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdIssuesIssueIdAwardEmoji_760216 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdIssuesIssueIdAwardEmoji_760218(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdIssuesIssueIdAwardEmoji_760217(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of an Issue, Merge Request or Snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760219 = path.getOrDefault("id")
  valid_760219 = validateParameter(valid_760219, JString, required = true,
                                 default = nil)
  if valid_760219 != nil:
    section.add "id", valid_760219
  var valid_760220 = path.getOrDefault("issue_id")
  valid_760220 = validateParameter(valid_760220, JInt, required = true, default = nil)
  if valid_760220 != nil:
    section.add "issue_id", valid_760220
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760221 = query.getOrDefault("per_page")
  valid_760221 = validateParameter(valid_760221, JInt, required = false, default = nil)
  if valid_760221 != nil:
    section.add "per_page", valid_760221
  var valid_760222 = query.getOrDefault("page")
  valid_760222 = validateParameter(valid_760222, JInt, required = false, default = nil)
  if valid_760222 != nil:
    section.add "page", valid_760222
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760223: Call_GetV3ProjectsIdIssuesIssueIdAwardEmoji_760216;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760223.validator(path, query, header, formData, body)
  let scheme = call_760223.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760223.url(scheme.get, call_760223.host, call_760223.base,
                         call_760223.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760223, url, valid)

proc call*(call_760224: Call_GetV3ProjectsIdIssuesIssueIdAwardEmoji_760216;
          id: string; issueId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdIssuesIssueIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   issueId: int (required)
  ##          : The ID of an Issue, Merge Request or Snippet
  var path_760225 = newJObject()
  var query_760226 = newJObject()
  add(path_760225, "id", newJString(id))
  add(query_760226, "per_page", newJInt(perPage))
  add(query_760226, "page", newJInt(page))
  add(path_760225, "issue_id", newJInt(issueId))
  result = call_760224.call(path_760225, query_760226, nil, nil, nil)

var getV3ProjectsIdIssuesIssueIdAwardEmoji* = Call_GetV3ProjectsIdIssuesIssueIdAwardEmoji_760216(
    name: "getV3ProjectsIdIssuesIssueIdAwardEmoji", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/issues/{issue_id}/award_emoji",
    validator: validate_GetV3ProjectsIdIssuesIssueIdAwardEmoji_760217,
    base: "/api", url: url_GetV3ProjectsIdIssuesIssueIdAwardEmoji_760218,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760237 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760239(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760238(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of the award
  ##   issue_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760240 = path.getOrDefault("id")
  valid_760240 = validateParameter(valid_760240, JInt, required = true, default = nil)
  if valid_760240 != nil:
    section.add "id", valid_760240
  var valid_760241 = path.getOrDefault("award_id")
  valid_760241 = validateParameter(valid_760241, JInt, required = true, default = nil)
  if valid_760241 != nil:
    section.add "award_id", valid_760241
  var valid_760242 = path.getOrDefault("issue_id")
  valid_760242 = validateParameter(valid_760242, JInt, required = true, default = nil)
  if valid_760242 != nil:
    section.add "issue_id", valid_760242
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760243: Call_GetV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760237;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760243.validator(path, query, header, formData, body)
  let scheme = call_760243.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760243.url(scheme.get, call_760243.host, call_760243.base,
                         call_760243.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760243, url, valid)

proc call*(call_760244: Call_GetV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760237;
          id: int; awardId: int; issueId: int): Recallable =
  ## getV3ProjectsIdIssuesIssueIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of the award
  ##   issueId: int (required)
  var path_760245 = newJObject()
  add(path_760245, "id", newJInt(id))
  add(path_760245, "award_id", newJInt(awardId))
  add(path_760245, "issue_id", newJInt(issueId))
  result = call_760244.call(path_760245, nil, nil, nil, nil)

var getV3ProjectsIdIssuesIssueIdAwardEmojiAwardId* = Call_GetV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760237(
    name: "getV3ProjectsIdIssuesIssueIdAwardEmojiAwardId",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{issue_id}/award_emoji/{award_id}",
    validator: validate_GetV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760238,
    base: "/api", url: url_GetV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760239,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760246 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760248(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760247(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of an award emoji
  ##   issue_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760249 = path.getOrDefault("id")
  valid_760249 = validateParameter(valid_760249, JInt, required = true, default = nil)
  if valid_760249 != nil:
    section.add "id", valid_760249
  var valid_760250 = path.getOrDefault("award_id")
  valid_760250 = validateParameter(valid_760250, JInt, required = true, default = nil)
  if valid_760250 != nil:
    section.add "award_id", valid_760250
  var valid_760251 = path.getOrDefault("issue_id")
  valid_760251 = validateParameter(valid_760251, JInt, required = true, default = nil)
  if valid_760251 != nil:
    section.add "issue_id", valid_760251
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760252: Call_DeleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760246;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760252.validator(path, query, header, formData, body)
  let scheme = call_760252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760252.url(scheme.get, call_760252.host, call_760252.base,
                         call_760252.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760252, url, valid)

proc call*(call_760253: Call_DeleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760246;
          id: int; awardId: int; issueId: int): Recallable =
  ## deleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of an award emoji
  ##   issueId: int (required)
  var path_760254 = newJObject()
  add(path_760254, "id", newJInt(id))
  add(path_760254, "award_id", newJInt(awardId))
  add(path_760254, "issue_id", newJInt(issueId))
  result = call_760253.call(path_760254, nil, nil, nil, nil)

var deleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId* = Call_DeleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760246(
    name: "deleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{issue_id}/award_emoji/{award_id}",
    validator: validate_DeleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760247,
    base: "/api", url: url_DeleteV3ProjectsIdIssuesIssueIdAwardEmojiAwardId_760248,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssuesIssueIdMove_760255 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssuesIssueIdMove_760257(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/move")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssuesIssueIdMove_760256(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Move an existing issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of a project issue
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760258 = path.getOrDefault("id")
  valid_760258 = validateParameter(valid_760258, JString, required = true,
                                 default = nil)
  if valid_760258 != nil:
    section.add "id", valid_760258
  var valid_760259 = path.getOrDefault("issue_id")
  valid_760259 = validateParameter(valid_760259, JInt, required = true, default = nil)
  if valid_760259 != nil:
    section.add "issue_id", valid_760259
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   to_project_id: JInt (required)
  ##                : The ID of the new project
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `to_project_id` field"
  var valid_760260 = formData.getOrDefault("to_project_id")
  valid_760260 = validateParameter(valid_760260, JInt, required = true, default = nil)
  if valid_760260 != nil:
    section.add "to_project_id", valid_760260
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760261: Call_PostV3ProjectsIdIssuesIssueIdMove_760255;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Move an existing issue
  ## 
  let valid = call_760261.validator(path, query, header, formData, body)
  let scheme = call_760261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760261.url(scheme.get, call_760261.host, call_760261.base,
                         call_760261.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760261, url, valid)

proc call*(call_760262: Call_PostV3ProjectsIdIssuesIssueIdMove_760255; id: string;
          toProjectId: int; issueId: int): Recallable =
  ## postV3ProjectsIdIssuesIssueIdMove
  ## Move an existing issue
  ##   id: string (required)
  ##     : The ID of a project
  ##   toProjectId: int (required)
  ##              : The ID of the new project
  ##   issueId: int (required)
  ##          : The ID of a project issue
  var path_760263 = newJObject()
  var formData_760264 = newJObject()
  add(path_760263, "id", newJString(id))
  add(formData_760264, "to_project_id", newJInt(toProjectId))
  add(path_760263, "issue_id", newJInt(issueId))
  result = call_760262.call(path_760263, nil, nil, formData_760264, nil)

var postV3ProjectsIdIssuesIssueIdMove* = Call_PostV3ProjectsIdIssuesIssueIdMove_760255(
    name: "postV3ProjectsIdIssuesIssueIdMove", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/issues/{issue_id}/move",
    validator: validate_PostV3ProjectsIdIssuesIssueIdMove_760256, base: "/api",
    url: url_PostV3ProjectsIdIssuesIssueIdMove_760257, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760277 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760279(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760278(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   issue_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760280 = path.getOrDefault("id")
  valid_760280 = validateParameter(valid_760280, JInt, required = true, default = nil)
  if valid_760280 != nil:
    section.add "id", valid_760280
  var valid_760281 = path.getOrDefault("issue_id")
  valid_760281 = validateParameter(valid_760281, JInt, required = true, default = nil)
  if valid_760281 != nil:
    section.add "issue_id", valid_760281
  var valid_760282 = path.getOrDefault("note_id")
  valid_760282 = validateParameter(valid_760282, JInt, required = true, default = nil)
  if valid_760282 != nil:
    section.add "note_id", valid_760282
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   name: JString (required)
  ##       : The name of a award_emoji (without colons)
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `name` field"
  var valid_760283 = formData.getOrDefault("name")
  valid_760283 = validateParameter(valid_760283, JString, required = true,
                                 default = nil)
  if valid_760283 != nil:
    section.add "name", valid_760283
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760284: Call_PostV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760277;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760284.validator(path, query, header, formData, body)
  let scheme = call_760284.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760284.url(scheme.get, call_760284.host, call_760284.base,
                         call_760284.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760284, url, valid)

proc call*(call_760285: Call_PostV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760277;
          id: int; issueId: int; noteId: int; name: string): Recallable =
  ## postV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   issueId: int (required)
  ##   noteId: int (required)
  ##   name: string (required)
  ##       : The name of a award_emoji (without colons)
  var path_760286 = newJObject()
  var formData_760287 = newJObject()
  add(path_760286, "id", newJInt(id))
  add(path_760286, "issue_id", newJInt(issueId))
  add(path_760286, "note_id", newJInt(noteId))
  add(formData_760287, "name", newJString(name))
  result = call_760285.call(path_760286, nil, nil, formData_760287, nil)

var postV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji* = Call_PostV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760277(
    name: "postV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{issue_id}/notes/{note_id}/award_emoji",
    validator: validate_PostV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760278,
    base: "/api", url: url_PostV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760279,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760265 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760267(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760266(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   issue_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760268 = path.getOrDefault("id")
  valid_760268 = validateParameter(valid_760268, JInt, required = true, default = nil)
  if valid_760268 != nil:
    section.add "id", valid_760268
  var valid_760269 = path.getOrDefault("issue_id")
  valid_760269 = validateParameter(valid_760269, JInt, required = true, default = nil)
  if valid_760269 != nil:
    section.add "issue_id", valid_760269
  var valid_760270 = path.getOrDefault("note_id")
  valid_760270 = validateParameter(valid_760270, JInt, required = true, default = nil)
  if valid_760270 != nil:
    section.add "note_id", valid_760270
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760271 = query.getOrDefault("per_page")
  valid_760271 = validateParameter(valid_760271, JInt, required = false, default = nil)
  if valid_760271 != nil:
    section.add "per_page", valid_760271
  var valid_760272 = query.getOrDefault("page")
  valid_760272 = validateParameter(valid_760272, JInt, required = false, default = nil)
  if valid_760272 != nil:
    section.add "page", valid_760272
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760273: Call_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760265;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760273.validator(path, query, header, formData, body)
  let scheme = call_760273.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760273.url(scheme.get, call_760273.host, call_760273.base,
                         call_760273.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760273, url, valid)

proc call*(call_760274: Call_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760265;
          id: int; issueId: int; noteId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   issueId: int (required)
  ##   noteId: int (required)
  var path_760275 = newJObject()
  var query_760276 = newJObject()
  add(path_760275, "id", newJInt(id))
  add(query_760276, "per_page", newJInt(perPage))
  add(query_760276, "page", newJInt(page))
  add(path_760275, "issue_id", newJInt(issueId))
  add(path_760275, "note_id", newJInt(noteId))
  result = call_760274.call(path_760275, query_760276, nil, nil, nil)

var getV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji* = Call_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760265(
    name: "getV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{issue_id}/notes/{note_id}/award_emoji",
    validator: validate_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760266,
    base: "/api", url: url_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmoji_760267,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760288 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760290(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760289(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of the award
  ##   issue_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760291 = path.getOrDefault("id")
  valid_760291 = validateParameter(valid_760291, JInt, required = true, default = nil)
  if valid_760291 != nil:
    section.add "id", valid_760291
  var valid_760292 = path.getOrDefault("award_id")
  valid_760292 = validateParameter(valid_760292, JInt, required = true, default = nil)
  if valid_760292 != nil:
    section.add "award_id", valid_760292
  var valid_760293 = path.getOrDefault("issue_id")
  valid_760293 = validateParameter(valid_760293, JInt, required = true, default = nil)
  if valid_760293 != nil:
    section.add "issue_id", valid_760293
  var valid_760294 = path.getOrDefault("note_id")
  valid_760294 = validateParameter(valid_760294, JInt, required = true, default = nil)
  if valid_760294 != nil:
    section.add "note_id", valid_760294
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760295: Call_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760288;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760295.validator(path, query, header, formData, body)
  let scheme = call_760295.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760295.url(scheme.get, call_760295.host, call_760295.base,
                         call_760295.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760295, url, valid)

proc call*(call_760296: Call_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760288;
          id: int; awardId: int; issueId: int; noteId: int): Recallable =
  ## getV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of the award
  ##   issueId: int (required)
  ##   noteId: int (required)
  var path_760297 = newJObject()
  add(path_760297, "id", newJInt(id))
  add(path_760297, "award_id", newJInt(awardId))
  add(path_760297, "issue_id", newJInt(issueId))
  add(path_760297, "note_id", newJInt(noteId))
  result = call_760296.call(path_760297, nil, nil, nil, nil)

var getV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId* = Call_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760288(
    name: "getV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/projects/{id}/issues/{issue_id}/notes/{note_id}/award_emoji/{award_id}", validator: validate_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760289,
    base: "/api",
    url: url_GetV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760290,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760298 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760300(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760299(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of an award emoji
  ##   issue_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760301 = path.getOrDefault("id")
  valid_760301 = validateParameter(valid_760301, JInt, required = true, default = nil)
  if valid_760301 != nil:
    section.add "id", valid_760301
  var valid_760302 = path.getOrDefault("award_id")
  valid_760302 = validateParameter(valid_760302, JInt, required = true, default = nil)
  if valid_760302 != nil:
    section.add "award_id", valid_760302
  var valid_760303 = path.getOrDefault("issue_id")
  valid_760303 = validateParameter(valid_760303, JInt, required = true, default = nil)
  if valid_760303 != nil:
    section.add "issue_id", valid_760303
  var valid_760304 = path.getOrDefault("note_id")
  valid_760304 = validateParameter(valid_760304, JInt, required = true, default = nil)
  if valid_760304 != nil:
    section.add "note_id", valid_760304
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760305: Call_DeleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760298;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760305.validator(path, query, header, formData, body)
  let scheme = call_760305.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760305.url(scheme.get, call_760305.host, call_760305.base,
                         call_760305.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760305, url, valid)

proc call*(call_760306: Call_DeleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760298;
          id: int; awardId: int; issueId: int; noteId: int): Recallable =
  ## deleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of an award emoji
  ##   issueId: int (required)
  ##   noteId: int (required)
  var path_760307 = newJObject()
  add(path_760307, "id", newJInt(id))
  add(path_760307, "award_id", newJInt(awardId))
  add(path_760307, "issue_id", newJInt(issueId))
  add(path_760307, "note_id", newJInt(noteId))
  result = call_760306.call(path_760307, nil, nil, nil, nil)

var deleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId* = Call_DeleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760298(
    name: "deleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com", route: "/v3/projects/{id}/issues/{issue_id}/notes/{note_id}/award_emoji/{award_id}", validator: validate_DeleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760299,
    base: "/api",
    url: url_DeleteV3ProjectsIdIssuesIssueIdNotesNoteIdAwardEmojiAwardId_760300,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssuesIssueIdResetSpentTime_760308 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssuesIssueIdResetSpentTime_760310(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/reset_spent_time")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssuesIssueIdResetSpentTime_760309(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reset spent time for a project issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of a project issue
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760311 = path.getOrDefault("id")
  valid_760311 = validateParameter(valid_760311, JString, required = true,
                                 default = nil)
  if valid_760311 != nil:
    section.add "id", valid_760311
  var valid_760312 = path.getOrDefault("issue_id")
  valid_760312 = validateParameter(valid_760312, JInt, required = true, default = nil)
  if valid_760312 != nil:
    section.add "issue_id", valid_760312
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760313: Call_PostV3ProjectsIdIssuesIssueIdResetSpentTime_760308;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Reset spent time for a project issue
  ## 
  let valid = call_760313.validator(path, query, header, formData, body)
  let scheme = call_760313.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760313.url(scheme.get, call_760313.host, call_760313.base,
                         call_760313.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760313, url, valid)

proc call*(call_760314: Call_PostV3ProjectsIdIssuesIssueIdResetSpentTime_760308;
          id: string; issueId: int): Recallable =
  ## postV3ProjectsIdIssuesIssueIdResetSpentTime
  ## Reset spent time for a project issue
  ##   id: string (required)
  ##     : The ID of a project
  ##   issueId: int (required)
  ##          : The ID of a project issue
  var path_760315 = newJObject()
  add(path_760315, "id", newJString(id))
  add(path_760315, "issue_id", newJInt(issueId))
  result = call_760314.call(path_760315, nil, nil, nil, nil)

var postV3ProjectsIdIssuesIssueIdResetSpentTime* = Call_PostV3ProjectsIdIssuesIssueIdResetSpentTime_760308(
    name: "postV3ProjectsIdIssuesIssueIdResetSpentTime",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{issue_id}/reset_spent_time",
    validator: validate_PostV3ProjectsIdIssuesIssueIdResetSpentTime_760309,
    base: "/api", url: url_PostV3ProjectsIdIssuesIssueIdResetSpentTime_760310,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssuesIssueIdResetTimeEstimate_760316 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssuesIssueIdResetTimeEstimate_760318(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/reset_time_estimate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssuesIssueIdResetTimeEstimate_760317(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Reset the time estimate for a project issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of a project issue
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760319 = path.getOrDefault("id")
  valid_760319 = validateParameter(valid_760319, JString, required = true,
                                 default = nil)
  if valid_760319 != nil:
    section.add "id", valid_760319
  var valid_760320 = path.getOrDefault("issue_id")
  valid_760320 = validateParameter(valid_760320, JInt, required = true, default = nil)
  if valid_760320 != nil:
    section.add "issue_id", valid_760320
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760321: Call_PostV3ProjectsIdIssuesIssueIdResetTimeEstimate_760316;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Reset the time estimate for a project issue
  ## 
  let valid = call_760321.validator(path, query, header, formData, body)
  let scheme = call_760321.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760321.url(scheme.get, call_760321.host, call_760321.base,
                         call_760321.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760321, url, valid)

proc call*(call_760322: Call_PostV3ProjectsIdIssuesIssueIdResetTimeEstimate_760316;
          id: string; issueId: int): Recallable =
  ## postV3ProjectsIdIssuesIssueIdResetTimeEstimate
  ## Reset the time estimate for a project issue
  ##   id: string (required)
  ##     : The ID of a project
  ##   issueId: int (required)
  ##          : The ID of a project issue
  var path_760323 = newJObject()
  add(path_760323, "id", newJString(id))
  add(path_760323, "issue_id", newJInt(issueId))
  result = call_760322.call(path_760323, nil, nil, nil, nil)

var postV3ProjectsIdIssuesIssueIdResetTimeEstimate* = Call_PostV3ProjectsIdIssuesIssueIdResetTimeEstimate_760316(
    name: "postV3ProjectsIdIssuesIssueIdResetTimeEstimate",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{issue_id}/reset_time_estimate",
    validator: validate_PostV3ProjectsIdIssuesIssueIdResetTimeEstimate_760317,
    base: "/api", url: url_PostV3ProjectsIdIssuesIssueIdResetTimeEstimate_760318,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssuesIssueIdTimeEstimate_760324 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssuesIssueIdTimeEstimate_760326(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/time_estimate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssuesIssueIdTimeEstimate_760325(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set a time estimate for a project issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of a project issue
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760327 = path.getOrDefault("id")
  valid_760327 = validateParameter(valid_760327, JString, required = true,
                                 default = nil)
  if valid_760327 != nil:
    section.add "id", valid_760327
  var valid_760328 = path.getOrDefault("issue_id")
  valid_760328 = validateParameter(valid_760328, JInt, required = true, default = nil)
  if valid_760328 != nil:
    section.add "issue_id", valid_760328
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   duration: JString (required)
  ##           : The duration to be parsed
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `duration` field"
  var valid_760329 = formData.getOrDefault("duration")
  valid_760329 = validateParameter(valid_760329, JString, required = true,
                                 default = nil)
  if valid_760329 != nil:
    section.add "duration", valid_760329
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760330: Call_PostV3ProjectsIdIssuesIssueIdTimeEstimate_760324;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set a time estimate for a project issue
  ## 
  let valid = call_760330.validator(path, query, header, formData, body)
  let scheme = call_760330.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760330.url(scheme.get, call_760330.host, call_760330.base,
                         call_760330.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760330, url, valid)

proc call*(call_760331: Call_PostV3ProjectsIdIssuesIssueIdTimeEstimate_760324;
          id: string; issueId: int; duration: string): Recallable =
  ## postV3ProjectsIdIssuesIssueIdTimeEstimate
  ## Set a time estimate for a project issue
  ##   id: string (required)
  ##     : The ID of a project
  ##   issueId: int (required)
  ##          : The ID of a project issue
  ##   duration: string (required)
  ##           : The duration to be parsed
  var path_760332 = newJObject()
  var formData_760333 = newJObject()
  add(path_760332, "id", newJString(id))
  add(path_760332, "issue_id", newJInt(issueId))
  add(formData_760333, "duration", newJString(duration))
  result = call_760331.call(path_760332, nil, nil, formData_760333, nil)

var postV3ProjectsIdIssuesIssueIdTimeEstimate* = Call_PostV3ProjectsIdIssuesIssueIdTimeEstimate_760324(
    name: "postV3ProjectsIdIssuesIssueIdTimeEstimate", meth: HttpMethod.HttpPost,
    host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{issue_id}/time_estimate",
    validator: validate_PostV3ProjectsIdIssuesIssueIdTimeEstimate_760325,
    base: "/api", url: url_PostV3ProjectsIdIssuesIssueIdTimeEstimate_760326,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdIssuesIssueIdTimeStats_760334 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdIssuesIssueIdTimeStats_760336(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/time_stats")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdIssuesIssueIdTimeStats_760335(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Show time stats for a project issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of a project issue
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760337 = path.getOrDefault("id")
  valid_760337 = validateParameter(valid_760337, JString, required = true,
                                 default = nil)
  if valid_760337 != nil:
    section.add "id", valid_760337
  var valid_760338 = path.getOrDefault("issue_id")
  valid_760338 = validateParameter(valid_760338, JInt, required = true, default = nil)
  if valid_760338 != nil:
    section.add "issue_id", valid_760338
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760339: Call_GetV3ProjectsIdIssuesIssueIdTimeStats_760334;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Show time stats for a project issue
  ## 
  let valid = call_760339.validator(path, query, header, formData, body)
  let scheme = call_760339.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760339.url(scheme.get, call_760339.host, call_760339.base,
                         call_760339.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760339, url, valid)

proc call*(call_760340: Call_GetV3ProjectsIdIssuesIssueIdTimeStats_760334;
          id: string; issueId: int): Recallable =
  ## getV3ProjectsIdIssuesIssueIdTimeStats
  ## Show time stats for a project issue
  ##   id: string (required)
  ##     : The ID of a project
  ##   issueId: int (required)
  ##          : The ID of a project issue
  var path_760341 = newJObject()
  add(path_760341, "id", newJString(id))
  add(path_760341, "issue_id", newJInt(issueId))
  result = call_760340.call(path_760341, nil, nil, nil, nil)

var getV3ProjectsIdIssuesIssueIdTimeStats* = Call_GetV3ProjectsIdIssuesIssueIdTimeStats_760334(
    name: "getV3ProjectsIdIssuesIssueIdTimeStats", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/issues/{issue_id}/time_stats",
    validator: validate_GetV3ProjectsIdIssuesIssueIdTimeStats_760335,
    base: "/api", url: url_GetV3ProjectsIdIssuesIssueIdTimeStats_760336,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssuesIssueIdTodo_760342 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssuesIssueIdTodo_760344(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "issue_id" in path, "`issue_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "issue_id"),
               (kind: ConstantSegment, value: "/todo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssuesIssueIdTodo_760343(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a todo on an issuable
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   issue_id: JInt (required)
  ##           : The ID of an issuable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760345 = path.getOrDefault("id")
  valid_760345 = validateParameter(valid_760345, JString, required = true,
                                 default = nil)
  if valid_760345 != nil:
    section.add "id", valid_760345
  var valid_760346 = path.getOrDefault("issue_id")
  valid_760346 = validateParameter(valid_760346, JInt, required = true, default = nil)
  if valid_760346 != nil:
    section.add "issue_id", valid_760346
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760347: Call_PostV3ProjectsIdIssuesIssueIdTodo_760342;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a todo on an issuable
  ## 
  let valid = call_760347.validator(path, query, header, formData, body)
  let scheme = call_760347.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760347.url(scheme.get, call_760347.host, call_760347.base,
                         call_760347.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760347, url, valid)

proc call*(call_760348: Call_PostV3ProjectsIdIssuesIssueIdTodo_760342; id: string;
          issueId: int): Recallable =
  ## postV3ProjectsIdIssuesIssueIdTodo
  ## Create a todo on an issuable
  ##   id: string (required)
  ##     : The ID of a project
  ##   issueId: int (required)
  ##          : The ID of an issuable
  var path_760349 = newJObject()
  add(path_760349, "id", newJString(id))
  add(path_760349, "issue_id", newJInt(issueId))
  result = call_760348.call(path_760349, nil, nil, nil, nil)

var postV3ProjectsIdIssuesIssueIdTodo* = Call_PostV3ProjectsIdIssuesIssueIdTodo_760342(
    name: "postV3ProjectsIdIssuesIssueIdTodo", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/issues/{issue_id}/todo",
    validator: validate_PostV3ProjectsIdIssuesIssueIdTodo_760343, base: "/api",
    url: url_PostV3ProjectsIdIssuesIssueIdTodo_760344, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssuesNoteableIdNotes_760361 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssuesNoteableIdNotes_760363(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssuesNoteableIdNotes_760362(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760364 = path.getOrDefault("id")
  valid_760364 = validateParameter(valid_760364, JString, required = true,
                                 default = nil)
  if valid_760364 != nil:
    section.add "id", valid_760364
  var valid_760365 = path.getOrDefault("noteable_id")
  valid_760365 = validateParameter(valid_760365, JInt, required = true, default = nil)
  if valid_760365 != nil:
    section.add "noteable_id", valid_760365
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   created_at: JString
  ##             : The creation date of the note
  ##   body: JString (required)
  ##       : The content of a note
  section = newJObject()
  var valid_760366 = formData.getOrDefault("created_at")
  valid_760366 = validateParameter(valid_760366, JString, required = false,
                                 default = nil)
  if valid_760366 != nil:
    section.add "created_at", valid_760366
  assert formData != nil,
        "formData argument is necessary due to required `body` field"
  var valid_760367 = formData.getOrDefault("body")
  valid_760367 = validateParameter(valid_760367, JString, required = true,
                                 default = nil)
  if valid_760367 != nil:
    section.add "body", valid_760367
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760368: Call_PostV3ProjectsIdIssuesNoteableIdNotes_760361;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a new +noteable+ note
  ## 
  let valid = call_760368.validator(path, query, header, formData, body)
  let scheme = call_760368.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760368.url(scheme.get, call_760368.host, call_760368.base,
                         call_760368.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760368, url, valid)

proc call*(call_760369: Call_PostV3ProjectsIdIssuesNoteableIdNotes_760361;
          id: string; body: string; noteableId: int; createdAt: string = ""): Recallable =
  ## postV3ProjectsIdIssuesNoteableIdNotes
  ## Create a new +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   createdAt: string
  ##            : The creation date of the note
  ##   body: string (required)
  ##       : The content of a note
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  var path_760370 = newJObject()
  var formData_760371 = newJObject()
  add(path_760370, "id", newJString(id))
  add(formData_760371, "created_at", newJString(createdAt))
  add(formData_760371, "body", newJString(body))
  add(path_760370, "noteable_id", newJInt(noteableId))
  result = call_760369.call(path_760370, nil, nil, formData_760371, nil)

var postV3ProjectsIdIssuesNoteableIdNotes* = Call_PostV3ProjectsIdIssuesNoteableIdNotes_760361(
    name: "postV3ProjectsIdIssuesNoteableIdNotes", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/issues/{noteable_id}/notes",
    validator: validate_PostV3ProjectsIdIssuesNoteableIdNotes_760362,
    base: "/api", url: url_PostV3ProjectsIdIssuesNoteableIdNotes_760363,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdIssuesNoteableIdNotes_760350 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdIssuesNoteableIdNotes_760352(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdIssuesNoteableIdNotes_760351(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a list of project +noteable+ notes
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760353 = path.getOrDefault("id")
  valid_760353 = validateParameter(valid_760353, JString, required = true,
                                 default = nil)
  if valid_760353 != nil:
    section.add "id", valid_760353
  var valid_760354 = path.getOrDefault("noteable_id")
  valid_760354 = validateParameter(valid_760354, JInt, required = true, default = nil)
  if valid_760354 != nil:
    section.add "noteable_id", valid_760354
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760355 = query.getOrDefault("per_page")
  valid_760355 = validateParameter(valid_760355, JInt, required = false, default = nil)
  if valid_760355 != nil:
    section.add "per_page", valid_760355
  var valid_760356 = query.getOrDefault("page")
  valid_760356 = validateParameter(valid_760356, JInt, required = false, default = nil)
  if valid_760356 != nil:
    section.add "page", valid_760356
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760357: Call_GetV3ProjectsIdIssuesNoteableIdNotes_760350;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a list of project +noteable+ notes
  ## 
  let valid = call_760357.validator(path, query, header, formData, body)
  let scheme = call_760357.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760357.url(scheme.get, call_760357.host, call_760357.base,
                         call_760357.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760357, url, valid)

proc call*(call_760358: Call_GetV3ProjectsIdIssuesNoteableIdNotes_760350;
          id: string; noteableId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdIssuesNoteableIdNotes
  ## Get a list of project +noteable+ notes
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  var path_760359 = newJObject()
  var query_760360 = newJObject()
  add(path_760359, "id", newJString(id))
  add(query_760360, "per_page", newJInt(perPage))
  add(query_760360, "page", newJInt(page))
  add(path_760359, "noteable_id", newJInt(noteableId))
  result = call_760358.call(path_760359, query_760360, nil, nil, nil)

var getV3ProjectsIdIssuesNoteableIdNotes* = Call_GetV3ProjectsIdIssuesNoteableIdNotes_760350(
    name: "getV3ProjectsIdIssuesNoteableIdNotes", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/issues/{noteable_id}/notes",
    validator: validate_GetV3ProjectsIdIssuesNoteableIdNotes_760351, base: "/api",
    url: url_GetV3ProjectsIdIssuesNoteableIdNotes_760352, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdIssuesNoteableIdNotesNoteId_760381 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdIssuesNoteableIdNotesNoteId_760383(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdIssuesNoteableIdNotesNoteId_760382(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update an existing +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  ##   note_id: JInt (required)
  ##          : The ID of a note
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760384 = path.getOrDefault("id")
  valid_760384 = validateParameter(valid_760384, JString, required = true,
                                 default = nil)
  if valid_760384 != nil:
    section.add "id", valid_760384
  var valid_760385 = path.getOrDefault("noteable_id")
  valid_760385 = validateParameter(valid_760385, JInt, required = true, default = nil)
  if valid_760385 != nil:
    section.add "noteable_id", valid_760385
  var valid_760386 = path.getOrDefault("note_id")
  valid_760386 = validateParameter(valid_760386, JInt, required = true, default = nil)
  if valid_760386 != nil:
    section.add "note_id", valid_760386
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   body: JString (required)
  ##       : The content of a note
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `body` field"
  var valid_760387 = formData.getOrDefault("body")
  valid_760387 = validateParameter(valid_760387, JString, required = true,
                                 default = nil)
  if valid_760387 != nil:
    section.add "body", valid_760387
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760388: Call_PutV3ProjectsIdIssuesNoteableIdNotesNoteId_760381;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update an existing +noteable+ note
  ## 
  let valid = call_760388.validator(path, query, header, formData, body)
  let scheme = call_760388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760388.url(scheme.get, call_760388.host, call_760388.base,
                         call_760388.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760388, url, valid)

proc call*(call_760389: Call_PutV3ProjectsIdIssuesNoteableIdNotesNoteId_760381;
          id: string; body: string; noteableId: int; noteId: int): Recallable =
  ## putV3ProjectsIdIssuesNoteableIdNotesNoteId
  ## Update an existing +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   body: string (required)
  ##       : The content of a note
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  ##   noteId: int (required)
  ##         : The ID of a note
  var path_760390 = newJObject()
  var formData_760391 = newJObject()
  add(path_760390, "id", newJString(id))
  add(formData_760391, "body", newJString(body))
  add(path_760390, "noteable_id", newJInt(noteableId))
  add(path_760390, "note_id", newJInt(noteId))
  result = call_760389.call(path_760390, nil, nil, formData_760391, nil)

var putV3ProjectsIdIssuesNoteableIdNotesNoteId* = Call_PutV3ProjectsIdIssuesNoteableIdNotesNoteId_760381(
    name: "putV3ProjectsIdIssuesNoteableIdNotesNoteId", meth: HttpMethod.HttpPut,
    host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{noteable_id}/notes/{note_id}",
    validator: validate_PutV3ProjectsIdIssuesNoteableIdNotesNoteId_760382,
    base: "/api", url: url_PutV3ProjectsIdIssuesNoteableIdNotesNoteId_760383,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdIssuesNoteableIdNotesNoteId_760372 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdIssuesNoteableIdNotesNoteId_760374(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdIssuesNoteableIdNotesNoteId_760373(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  ##   note_id: JInt (required)
  ##          : The ID of a note
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760375 = path.getOrDefault("id")
  valid_760375 = validateParameter(valid_760375, JString, required = true,
                                 default = nil)
  if valid_760375 != nil:
    section.add "id", valid_760375
  var valid_760376 = path.getOrDefault("noteable_id")
  valid_760376 = validateParameter(valid_760376, JInt, required = true, default = nil)
  if valid_760376 != nil:
    section.add "noteable_id", valid_760376
  var valid_760377 = path.getOrDefault("note_id")
  valid_760377 = validateParameter(valid_760377, JInt, required = true, default = nil)
  if valid_760377 != nil:
    section.add "note_id", valid_760377
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760378: Call_GetV3ProjectsIdIssuesNoteableIdNotesNoteId_760372;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single +noteable+ note
  ## 
  let valid = call_760378.validator(path, query, header, formData, body)
  let scheme = call_760378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760378.url(scheme.get, call_760378.host, call_760378.base,
                         call_760378.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760378, url, valid)

proc call*(call_760379: Call_GetV3ProjectsIdIssuesNoteableIdNotesNoteId_760372;
          id: string; noteableId: int; noteId: int): Recallable =
  ## getV3ProjectsIdIssuesNoteableIdNotesNoteId
  ## Get a single +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  ##   noteId: int (required)
  ##         : The ID of a note
  var path_760380 = newJObject()
  add(path_760380, "id", newJString(id))
  add(path_760380, "noteable_id", newJInt(noteableId))
  add(path_760380, "note_id", newJInt(noteId))
  result = call_760379.call(path_760380, nil, nil, nil, nil)

var getV3ProjectsIdIssuesNoteableIdNotesNoteId* = Call_GetV3ProjectsIdIssuesNoteableIdNotesNoteId_760372(
    name: "getV3ProjectsIdIssuesNoteableIdNotesNoteId", meth: HttpMethod.HttpGet,
    host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{noteable_id}/notes/{note_id}",
    validator: validate_GetV3ProjectsIdIssuesNoteableIdNotesNoteId_760373,
    base: "/api", url: url_GetV3ProjectsIdIssuesNoteableIdNotesNoteId_760374,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdIssuesNoteableIdNotesNoteId_760392 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdIssuesNoteableIdNotesNoteId_760394(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdIssuesNoteableIdNotesNoteId_760393(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Delete a +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  ##   note_id: JInt (required)
  ##          : The ID of a note
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760395 = path.getOrDefault("id")
  valid_760395 = validateParameter(valid_760395, JString, required = true,
                                 default = nil)
  if valid_760395 != nil:
    section.add "id", valid_760395
  var valid_760396 = path.getOrDefault("noteable_id")
  valid_760396 = validateParameter(valid_760396, JInt, required = true, default = nil)
  if valid_760396 != nil:
    section.add "noteable_id", valid_760396
  var valid_760397 = path.getOrDefault("note_id")
  valid_760397 = validateParameter(valid_760397, JInt, required = true, default = nil)
  if valid_760397 != nil:
    section.add "note_id", valid_760397
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760398: Call_DeleteV3ProjectsIdIssuesNoteableIdNotesNoteId_760392;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a +noteable+ note
  ## 
  let valid = call_760398.validator(path, query, header, formData, body)
  let scheme = call_760398.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760398.url(scheme.get, call_760398.host, call_760398.base,
                         call_760398.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760398, url, valid)

proc call*(call_760399: Call_DeleteV3ProjectsIdIssuesNoteableIdNotesNoteId_760392;
          id: string; noteableId: int; noteId: int): Recallable =
  ## deleteV3ProjectsIdIssuesNoteableIdNotesNoteId
  ## Delete a +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  ##   noteId: int (required)
  ##         : The ID of a note
  var path_760400 = newJObject()
  add(path_760400, "id", newJString(id))
  add(path_760400, "noteable_id", newJInt(noteableId))
  add(path_760400, "note_id", newJInt(noteId))
  result = call_760399.call(path_760400, nil, nil, nil, nil)

var deleteV3ProjectsIdIssuesNoteableIdNotesNoteId* = Call_DeleteV3ProjectsIdIssuesNoteableIdNotesNoteId_760392(
    name: "deleteV3ProjectsIdIssuesNoteableIdNotesNoteId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{noteable_id}/notes/{note_id}",
    validator: validate_DeleteV3ProjectsIdIssuesNoteableIdNotesNoteId_760393,
    base: "/api", url: url_DeleteV3ProjectsIdIssuesNoteableIdNotesNoteId_760394,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdIssuesSubscribableIdSubscription_760401 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdIssuesSubscribableIdSubscription_760403(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "subscribable_id" in path, "`subscribable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "subscribable_id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdIssuesSubscribableIdSubscription_760402(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Subscribe to a resource
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   subscribable_id: JString (required)
  ##                  : The ID of a resource
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760404 = path.getOrDefault("id")
  valid_760404 = validateParameter(valid_760404, JString, required = true,
                                 default = nil)
  if valid_760404 != nil:
    section.add "id", valid_760404
  var valid_760405 = path.getOrDefault("subscribable_id")
  valid_760405 = validateParameter(valid_760405, JString, required = true,
                                 default = nil)
  if valid_760405 != nil:
    section.add "subscribable_id", valid_760405
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760406: Call_PostV3ProjectsIdIssuesSubscribableIdSubscription_760401;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Subscribe to a resource
  ## 
  let valid = call_760406.validator(path, query, header, formData, body)
  let scheme = call_760406.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760406.url(scheme.get, call_760406.host, call_760406.base,
                         call_760406.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760406, url, valid)

proc call*(call_760407: Call_PostV3ProjectsIdIssuesSubscribableIdSubscription_760401;
          id: string; subscribableId: string): Recallable =
  ## postV3ProjectsIdIssuesSubscribableIdSubscription
  ## Subscribe to a resource
  ##   id: string (required)
  ##     : The ID of a project
  ##   subscribableId: string (required)
  ##                 : The ID of a resource
  var path_760408 = newJObject()
  add(path_760408, "id", newJString(id))
  add(path_760408, "subscribable_id", newJString(subscribableId))
  result = call_760407.call(path_760408, nil, nil, nil, nil)

var postV3ProjectsIdIssuesSubscribableIdSubscription* = Call_PostV3ProjectsIdIssuesSubscribableIdSubscription_760401(
    name: "postV3ProjectsIdIssuesSubscribableIdSubscription",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{subscribable_id}/subscription",
    validator: validate_PostV3ProjectsIdIssuesSubscribableIdSubscription_760402,
    base: "/api", url: url_PostV3ProjectsIdIssuesSubscribableIdSubscription_760403,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdIssuesSubscribableIdSubscription_760409 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdIssuesSubscribableIdSubscription_760411(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "subscribable_id" in path, "`subscribable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "subscribable_id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdIssuesSubscribableIdSubscription_760410(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Unsubscribe from a resource
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   subscribable_id: JString (required)
  ##                  : The ID of a resource
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760412 = path.getOrDefault("id")
  valid_760412 = validateParameter(valid_760412, JString, required = true,
                                 default = nil)
  if valid_760412 != nil:
    section.add "id", valid_760412
  var valid_760413 = path.getOrDefault("subscribable_id")
  valid_760413 = validateParameter(valid_760413, JString, required = true,
                                 default = nil)
  if valid_760413 != nil:
    section.add "subscribable_id", valid_760413
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760414: Call_DeleteV3ProjectsIdIssuesSubscribableIdSubscription_760409;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Unsubscribe from a resource
  ## 
  let valid = call_760414.validator(path, query, header, formData, body)
  let scheme = call_760414.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760414.url(scheme.get, call_760414.host, call_760414.base,
                         call_760414.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760414, url, valid)

proc call*(call_760415: Call_DeleteV3ProjectsIdIssuesSubscribableIdSubscription_760409;
          id: string; subscribableId: string): Recallable =
  ## deleteV3ProjectsIdIssuesSubscribableIdSubscription
  ## Unsubscribe from a resource
  ##   id: string (required)
  ##     : The ID of a project
  ##   subscribableId: string (required)
  ##                 : The ID of a resource
  var path_760416 = newJObject()
  add(path_760416, "id", newJString(id))
  add(path_760416, "subscribable_id", newJString(subscribableId))
  result = call_760415.call(path_760416, nil, nil, nil, nil)

var deleteV3ProjectsIdIssuesSubscribableIdSubscription* = Call_DeleteV3ProjectsIdIssuesSubscribableIdSubscription_760409(
    name: "deleteV3ProjectsIdIssuesSubscribableIdSubscription",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/issues/{subscribable_id}/subscription",
    validator: validate_DeleteV3ProjectsIdIssuesSubscribableIdSubscription_760410,
    base: "/api", url: url_DeleteV3ProjectsIdIssuesSubscribableIdSubscription_760411,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdKeys_760424 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdKeys_760426(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdKeys_760425(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add new deploy key to currently authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760427 = path.getOrDefault("id")
  valid_760427 = validateParameter(valid_760427, JString, required = true,
                                 default = nil)
  if valid_760427 != nil:
    section.add "id", valid_760427
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   title: JString (required)
  ##        : The name of the deploy key
  ##   key: JString (required)
  ##      : The new deploy key
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `title` field"
  var valid_760428 = formData.getOrDefault("title")
  valid_760428 = validateParameter(valid_760428, JString, required = true,
                                 default = nil)
  if valid_760428 != nil:
    section.add "title", valid_760428
  var valid_760429 = formData.getOrDefault("key")
  valid_760429 = validateParameter(valid_760429, JString, required = true,
                                 default = nil)
  if valid_760429 != nil:
    section.add "key", valid_760429
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760430: Call_PostV3ProjectsIdKeys_760424; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Add new deploy key to currently authenticated user
  ## 
  let valid = call_760430.validator(path, query, header, formData, body)
  let scheme = call_760430.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760430.url(scheme.get, call_760430.host, call_760430.base,
                         call_760430.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760430, url, valid)

proc call*(call_760431: Call_PostV3ProjectsIdKeys_760424; title: string; id: string;
          key: string): Recallable =
  ## postV3ProjectsIdKeys
  ## Add new deploy key to currently authenticated user
  ##   title: string (required)
  ##        : The name of the deploy key
  ##   id: string (required)
  ##     : The ID of the project
  ##   key: string (required)
  ##      : The new deploy key
  var path_760432 = newJObject()
  var formData_760433 = newJObject()
  add(formData_760433, "title", newJString(title))
  add(path_760432, "id", newJString(id))
  add(formData_760433, "key", newJString(key))
  result = call_760431.call(path_760432, nil, nil, formData_760433, nil)

var postV3ProjectsIdKeys* = Call_PostV3ProjectsIdKeys_760424(
    name: "postV3ProjectsIdKeys", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/keys", validator: validate_PostV3ProjectsIdKeys_760425,
    base: "/api", url: url_PostV3ProjectsIdKeys_760426, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdKeys_760417 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdKeys_760419(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdKeys_760418(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Get a specific project's deploy keys
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760420 = path.getOrDefault("id")
  valid_760420 = validateParameter(valid_760420, JString, required = true,
                                 default = nil)
  if valid_760420 != nil:
    section.add "id", valid_760420
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760421: Call_GetV3ProjectsIdKeys_760417; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a specific project's deploy keys
  ## 
  let valid = call_760421.validator(path, query, header, formData, body)
  let scheme = call_760421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760421.url(scheme.get, call_760421.host, call_760421.base,
                         call_760421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760421, url, valid)

proc call*(call_760422: Call_GetV3ProjectsIdKeys_760417; id: string): Recallable =
  ## getV3ProjectsIdKeys
  ## Get a specific project's deploy keys
  ##   id: string (required)
  ##     : The ID of the project
  var path_760423 = newJObject()
  add(path_760423, "id", newJString(id))
  result = call_760422.call(path_760423, nil, nil, nil, nil)

var getV3ProjectsIdKeys* = Call_GetV3ProjectsIdKeys_760417(
    name: "getV3ProjectsIdKeys", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/keys", validator: validate_GetV3ProjectsIdKeys_760418,
    base: "/api", url: url_GetV3ProjectsIdKeys_760419, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdKeysKeyId_760434 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdKeysKeyId_760436(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "key_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdKeysKeyId_760435(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get single deploy key
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  ##   key_id: JInt (required)
  ##         : The ID of the deploy key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760437 = path.getOrDefault("id")
  valid_760437 = validateParameter(valid_760437, JString, required = true,
                                 default = nil)
  if valid_760437 != nil:
    section.add "id", valid_760437
  var valid_760438 = path.getOrDefault("key_id")
  valid_760438 = validateParameter(valid_760438, JInt, required = true, default = nil)
  if valid_760438 != nil:
    section.add "key_id", valid_760438
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760439: Call_GetV3ProjectsIdKeysKeyId_760434; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get single deploy key
  ## 
  let valid = call_760439.validator(path, query, header, formData, body)
  let scheme = call_760439.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760439.url(scheme.get, call_760439.host, call_760439.base,
                         call_760439.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760439, url, valid)

proc call*(call_760440: Call_GetV3ProjectsIdKeysKeyId_760434; id: string; keyId: int): Recallable =
  ## getV3ProjectsIdKeysKeyId
  ## Get single deploy key
  ##   id: string (required)
  ##     : The ID of the project
  ##   keyId: int (required)
  ##        : The ID of the deploy key
  var path_760441 = newJObject()
  add(path_760441, "id", newJString(id))
  add(path_760441, "key_id", newJInt(keyId))
  result = call_760440.call(path_760441, nil, nil, nil, nil)

var getV3ProjectsIdKeysKeyId* = Call_GetV3ProjectsIdKeysKeyId_760434(
    name: "getV3ProjectsIdKeysKeyId", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/keys/{key_id}",
    validator: validate_GetV3ProjectsIdKeysKeyId_760435, base: "/api",
    url: url_GetV3ProjectsIdKeysKeyId_760436, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdKeysKeyId_760442 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdKeysKeyId_760444(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "key_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdKeysKeyId_760443(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete deploy key for a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  ##   key_id: JInt (required)
  ##         : The ID of the deploy key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760445 = path.getOrDefault("id")
  valid_760445 = validateParameter(valid_760445, JString, required = true,
                                 default = nil)
  if valid_760445 != nil:
    section.add "id", valid_760445
  var valid_760446 = path.getOrDefault("key_id")
  valid_760446 = validateParameter(valid_760446, JInt, required = true, default = nil)
  if valid_760446 != nil:
    section.add "key_id", valid_760446
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760447: Call_DeleteV3ProjectsIdKeysKeyId_760442; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete deploy key for a project
  ## 
  let valid = call_760447.validator(path, query, header, formData, body)
  let scheme = call_760447.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760447.url(scheme.get, call_760447.host, call_760447.base,
                         call_760447.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760447, url, valid)

proc call*(call_760448: Call_DeleteV3ProjectsIdKeysKeyId_760442; id: string;
          keyId: int): Recallable =
  ## deleteV3ProjectsIdKeysKeyId
  ## Delete deploy key for a project
  ##   id: string (required)
  ##     : The ID of the project
  ##   keyId: int (required)
  ##        : The ID of the deploy key
  var path_760449 = newJObject()
  add(path_760449, "id", newJString(id))
  add(path_760449, "key_id", newJInt(keyId))
  result = call_760448.call(path_760449, nil, nil, nil, nil)

var deleteV3ProjectsIdKeysKeyId* = Call_DeleteV3ProjectsIdKeysKeyId_760442(
    name: "deleteV3ProjectsIdKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/keys/{key_id}",
    validator: validate_DeleteV3ProjectsIdKeysKeyId_760443, base: "/api",
    url: url_DeleteV3ProjectsIdKeysKeyId_760444, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdKeysKeyIdDisable_760450 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdKeysKeyIdDisable_760452(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "key_id"),
               (kind: ConstantSegment, value: "/disable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdKeysKeyIdDisable_760451(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was added in GitLab 8.11
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  ##   key_id: JInt (required)
  ##         : The ID of the deploy key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760453 = path.getOrDefault("id")
  valid_760453 = validateParameter(valid_760453, JString, required = true,
                                 default = nil)
  if valid_760453 != nil:
    section.add "id", valid_760453
  var valid_760454 = path.getOrDefault("key_id")
  valid_760454 = validateParameter(valid_760454, JInt, required = true, default = nil)
  if valid_760454 != nil:
    section.add "key_id", valid_760454
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760455: Call_DeleteV3ProjectsIdKeysKeyIdDisable_760450;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was added in GitLab 8.11
  ## 
  let valid = call_760455.validator(path, query, header, formData, body)
  let scheme = call_760455.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760455.url(scheme.get, call_760455.host, call_760455.base,
                         call_760455.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760455, url, valid)

proc call*(call_760456: Call_DeleteV3ProjectsIdKeysKeyIdDisable_760450; id: string;
          keyId: int): Recallable =
  ## deleteV3ProjectsIdKeysKeyIdDisable
  ## This feature was added in GitLab 8.11
  ##   id: string (required)
  ##     : The ID of the project
  ##   keyId: int (required)
  ##        : The ID of the deploy key
  var path_760457 = newJObject()
  add(path_760457, "id", newJString(id))
  add(path_760457, "key_id", newJInt(keyId))
  result = call_760456.call(path_760457, nil, nil, nil, nil)

var deleteV3ProjectsIdKeysKeyIdDisable* = Call_DeleteV3ProjectsIdKeysKeyIdDisable_760450(
    name: "deleteV3ProjectsIdKeysKeyIdDisable", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/keys/{key_id}/disable",
    validator: validate_DeleteV3ProjectsIdKeysKeyIdDisable_760451, base: "/api",
    url: url_DeleteV3ProjectsIdKeysKeyIdDisable_760452, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdKeysKeyIdEnable_760458 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdKeysKeyIdEnable_760460(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "key_id"),
               (kind: ConstantSegment, value: "/enable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdKeysKeyIdEnable_760459(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was added in GitLab 8.11
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of the project
  ##   key_id: JInt (required)
  ##         : The ID of the deploy key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760461 = path.getOrDefault("id")
  valid_760461 = validateParameter(valid_760461, JString, required = true,
                                 default = nil)
  if valid_760461 != nil:
    section.add "id", valid_760461
  var valid_760462 = path.getOrDefault("key_id")
  valid_760462 = validateParameter(valid_760462, JInt, required = true, default = nil)
  if valid_760462 != nil:
    section.add "key_id", valid_760462
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760463: Call_PostV3ProjectsIdKeysKeyIdEnable_760458;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was added in GitLab 8.11
  ## 
  let valid = call_760463.validator(path, query, header, formData, body)
  let scheme = call_760463.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760463.url(scheme.get, call_760463.host, call_760463.base,
                         call_760463.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760463, url, valid)

proc call*(call_760464: Call_PostV3ProjectsIdKeysKeyIdEnable_760458; id: string;
          keyId: int): Recallable =
  ## postV3ProjectsIdKeysKeyIdEnable
  ## This feature was added in GitLab 8.11
  ##   id: string (required)
  ##     : The ID of the project
  ##   keyId: int (required)
  ##        : The ID of the deploy key
  var path_760465 = newJObject()
  add(path_760465, "id", newJString(id))
  add(path_760465, "key_id", newJInt(keyId))
  result = call_760464.call(path_760465, nil, nil, nil, nil)

var postV3ProjectsIdKeysKeyIdEnable* = Call_PostV3ProjectsIdKeysKeyIdEnable_760458(
    name: "postV3ProjectsIdKeysKeyIdEnable", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/keys/{key_id}/enable",
    validator: validate_PostV3ProjectsIdKeysKeyIdEnable_760459, base: "/api",
    url: url_PostV3ProjectsIdKeysKeyIdEnable_760460, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdLabels_760473 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdLabels_760475(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdLabels_760474(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update an existing label. At least one optional parameter is required.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760476 = path.getOrDefault("id")
  valid_760476 = validateParameter(valid_760476, JString, required = true,
                                 default = nil)
  if valid_760476 != nil:
    section.add "id", valid_760476
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   color: JString
  ##        : The new color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB)
  ##   description: JString
  ##              : The new description of label
  ##   priority: JInt
  ##           : The priority of the label
  ##   new_name: JString
  ##           : The new name of the label
  ##   name: JString (required)
  ##       : The name of the label to be updated
  section = newJObject()
  var valid_760477 = formData.getOrDefault("color")
  valid_760477 = validateParameter(valid_760477, JString, required = false,
                                 default = nil)
  if valid_760477 != nil:
    section.add "color", valid_760477
  var valid_760478 = formData.getOrDefault("description")
  valid_760478 = validateParameter(valid_760478, JString, required = false,
                                 default = nil)
  if valid_760478 != nil:
    section.add "description", valid_760478
  var valid_760479 = formData.getOrDefault("priority")
  valid_760479 = validateParameter(valid_760479, JInt, required = false, default = nil)
  if valid_760479 != nil:
    section.add "priority", valid_760479
  var valid_760480 = formData.getOrDefault("new_name")
  valid_760480 = validateParameter(valid_760480, JString, required = false,
                                 default = nil)
  if valid_760480 != nil:
    section.add "new_name", valid_760480
  assert formData != nil,
        "formData argument is necessary due to required `name` field"
  var valid_760481 = formData.getOrDefault("name")
  valid_760481 = validateParameter(valid_760481, JString, required = true,
                                 default = nil)
  if valid_760481 != nil:
    section.add "name", valid_760481
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760482: Call_PutV3ProjectsIdLabels_760473; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update an existing label. At least one optional parameter is required.
  ## 
  let valid = call_760482.validator(path, query, header, formData, body)
  let scheme = call_760482.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760482.url(scheme.get, call_760482.host, call_760482.base,
                         call_760482.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760482, url, valid)

proc call*(call_760483: Call_PutV3ProjectsIdLabels_760473; id: string; name: string;
          color: string = ""; description: string = ""; priority: int = 0;
          newName: string = ""): Recallable =
  ## putV3ProjectsIdLabels
  ## Update an existing label. At least one optional parameter is required.
  ##   color: string
  ##        : The new color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB)
  ##   id: string (required)
  ##     : The ID of a project
  ##   description: string
  ##              : The new description of label
  ##   priority: int
  ##           : The priority of the label
  ##   newName: string
  ##          : The new name of the label
  ##   name: string (required)
  ##       : The name of the label to be updated
  var path_760484 = newJObject()
  var formData_760485 = newJObject()
  add(formData_760485, "color", newJString(color))
  add(path_760484, "id", newJString(id))
  add(formData_760485, "description", newJString(description))
  add(formData_760485, "priority", newJInt(priority))
  add(formData_760485, "new_name", newJString(newName))
  add(formData_760485, "name", newJString(name))
  result = call_760483.call(path_760484, nil, nil, formData_760485, nil)

var putV3ProjectsIdLabels* = Call_PutV3ProjectsIdLabels_760473(
    name: "putV3ProjectsIdLabels", meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/projects/{id}/labels", validator: validate_PutV3ProjectsIdLabels_760474,
    base: "/api", url: url_PutV3ProjectsIdLabels_760475, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdLabels_760486 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdLabels_760488(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdLabels_760487(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new label
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760489 = path.getOrDefault("id")
  valid_760489 = validateParameter(valid_760489, JString, required = true,
                                 default = nil)
  if valid_760489 != nil:
    section.add "id", valid_760489
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   color: JString (required)
  ##        : The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB)
  ##   description: JString
  ##              : The description of label to be created
  ##   priority: JInt
  ##           : The priority of the label
  ##   name: JString (required)
  ##       : The name of the label to be created
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `color` field"
  var valid_760490 = formData.getOrDefault("color")
  valid_760490 = validateParameter(valid_760490, JString, required = true,
                                 default = nil)
  if valid_760490 != nil:
    section.add "color", valid_760490
  var valid_760491 = formData.getOrDefault("description")
  valid_760491 = validateParameter(valid_760491, JString, required = false,
                                 default = nil)
  if valid_760491 != nil:
    section.add "description", valid_760491
  var valid_760492 = formData.getOrDefault("priority")
  valid_760492 = validateParameter(valid_760492, JInt, required = false, default = nil)
  if valid_760492 != nil:
    section.add "priority", valid_760492
  var valid_760493 = formData.getOrDefault("name")
  valid_760493 = validateParameter(valid_760493, JString, required = true,
                                 default = nil)
  if valid_760493 != nil:
    section.add "name", valid_760493
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760494: Call_PostV3ProjectsIdLabels_760486; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new label
  ## 
  let valid = call_760494.validator(path, query, header, formData, body)
  let scheme = call_760494.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760494.url(scheme.get, call_760494.host, call_760494.base,
                         call_760494.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760494, url, valid)

proc call*(call_760495: Call_PostV3ProjectsIdLabels_760486; color: string;
          id: string; name: string; description: string = ""; priority: int = 0): Recallable =
  ## postV3ProjectsIdLabels
  ## Create a new label
  ##   color: string (required)
  ##        : The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB)
  ##   id: string (required)
  ##     : The ID of a project
  ##   description: string
  ##              : The description of label to be created
  ##   priority: int
  ##           : The priority of the label
  ##   name: string (required)
  ##       : The name of the label to be created
  var path_760496 = newJObject()
  var formData_760497 = newJObject()
  add(formData_760497, "color", newJString(color))
  add(path_760496, "id", newJString(id))
  add(formData_760497, "description", newJString(description))
  add(formData_760497, "priority", newJInt(priority))
  add(formData_760497, "name", newJString(name))
  result = call_760495.call(path_760496, nil, nil, formData_760497, nil)

var postV3ProjectsIdLabels* = Call_PostV3ProjectsIdLabels_760486(
    name: "postV3ProjectsIdLabels", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/labels", validator: validate_PostV3ProjectsIdLabels_760487,
    base: "/api", url: url_PostV3ProjectsIdLabels_760488, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdLabels_760466 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdLabels_760468(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdLabels_760467(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get all labels of the project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760469 = path.getOrDefault("id")
  valid_760469 = validateParameter(valid_760469, JString, required = true,
                                 default = nil)
  if valid_760469 != nil:
    section.add "id", valid_760469
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760470: Call_GetV3ProjectsIdLabels_760466; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get all labels of the project
  ## 
  let valid = call_760470.validator(path, query, header, formData, body)
  let scheme = call_760470.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760470.url(scheme.get, call_760470.host, call_760470.base,
                         call_760470.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760470, url, valid)

proc call*(call_760471: Call_GetV3ProjectsIdLabels_760466; id: string): Recallable =
  ## getV3ProjectsIdLabels
  ## Get all labels of the project
  ##   id: string (required)
  ##     : The ID of a project
  var path_760472 = newJObject()
  add(path_760472, "id", newJString(id))
  result = call_760471.call(path_760472, nil, nil, nil, nil)

var getV3ProjectsIdLabels* = Call_GetV3ProjectsIdLabels_760466(
    name: "getV3ProjectsIdLabels", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/labels", validator: validate_GetV3ProjectsIdLabels_760467,
    base: "/api", url: url_GetV3ProjectsIdLabels_760468, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdLabels_760498 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdLabels_760500(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdLabels_760499(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete an existing label
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760501 = path.getOrDefault("id")
  valid_760501 = validateParameter(valid_760501, JString, required = true,
                                 default = nil)
  if valid_760501 != nil:
    section.add "id", valid_760501
  result.add "path", section
  ## parameters in `query` object:
  ##   name: JString (required)
  ##       : The name of the label to be deleted
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `name` field"
  var valid_760502 = query.getOrDefault("name")
  valid_760502 = validateParameter(valid_760502, JString, required = true,
                                 default = nil)
  if valid_760502 != nil:
    section.add "name", valid_760502
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760503: Call_DeleteV3ProjectsIdLabels_760498; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an existing label
  ## 
  let valid = call_760503.validator(path, query, header, formData, body)
  let scheme = call_760503.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760503.url(scheme.get, call_760503.host, call_760503.base,
                         call_760503.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760503, url, valid)

proc call*(call_760504: Call_DeleteV3ProjectsIdLabels_760498; name: string;
          id: string): Recallable =
  ## deleteV3ProjectsIdLabels
  ## Delete an existing label
  ##   name: string (required)
  ##       : The name of the label to be deleted
  ##   id: string (required)
  ##     : The ID of a project
  var path_760505 = newJObject()
  var query_760506 = newJObject()
  add(query_760506, "name", newJString(name))
  add(path_760505, "id", newJString(id))
  result = call_760504.call(path_760505, query_760506, nil, nil, nil)

var deleteV3ProjectsIdLabels* = Call_DeleteV3ProjectsIdLabels_760498(
    name: "deleteV3ProjectsIdLabels", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/labels",
    validator: validate_DeleteV3ProjectsIdLabels_760499, base: "/api",
    url: url_DeleteV3ProjectsIdLabels_760500, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdLabelsSubscribableIdSubscription_760507 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdLabelsSubscribableIdSubscription_760509(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "subscribable_id" in path, "`subscribable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "subscribable_id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdLabelsSubscribableIdSubscription_760508(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Subscribe to a resource
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   subscribable_id: JString (required)
  ##                  : The ID of a resource
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760510 = path.getOrDefault("id")
  valid_760510 = validateParameter(valid_760510, JString, required = true,
                                 default = nil)
  if valid_760510 != nil:
    section.add "id", valid_760510
  var valid_760511 = path.getOrDefault("subscribable_id")
  valid_760511 = validateParameter(valid_760511, JString, required = true,
                                 default = nil)
  if valid_760511 != nil:
    section.add "subscribable_id", valid_760511
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760512: Call_PostV3ProjectsIdLabelsSubscribableIdSubscription_760507;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Subscribe to a resource
  ## 
  let valid = call_760512.validator(path, query, header, formData, body)
  let scheme = call_760512.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760512.url(scheme.get, call_760512.host, call_760512.base,
                         call_760512.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760512, url, valid)

proc call*(call_760513: Call_PostV3ProjectsIdLabelsSubscribableIdSubscription_760507;
          id: string; subscribableId: string): Recallable =
  ## postV3ProjectsIdLabelsSubscribableIdSubscription
  ## Subscribe to a resource
  ##   id: string (required)
  ##     : The ID of a project
  ##   subscribableId: string (required)
  ##                 : The ID of a resource
  var path_760514 = newJObject()
  add(path_760514, "id", newJString(id))
  add(path_760514, "subscribable_id", newJString(subscribableId))
  result = call_760513.call(path_760514, nil, nil, nil, nil)

var postV3ProjectsIdLabelsSubscribableIdSubscription* = Call_PostV3ProjectsIdLabelsSubscribableIdSubscription_760507(
    name: "postV3ProjectsIdLabelsSubscribableIdSubscription",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/labels/{subscribable_id}/subscription",
    validator: validate_PostV3ProjectsIdLabelsSubscribableIdSubscription_760508,
    base: "/api", url: url_PostV3ProjectsIdLabelsSubscribableIdSubscription_760509,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdLabelsSubscribableIdSubscription_760515 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdLabelsSubscribableIdSubscription_760517(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "subscribable_id" in path, "`subscribable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "subscribable_id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdLabelsSubscribableIdSubscription_760516(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Unsubscribe from a resource
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   subscribable_id: JString (required)
  ##                  : The ID of a resource
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760518 = path.getOrDefault("id")
  valid_760518 = validateParameter(valid_760518, JString, required = true,
                                 default = nil)
  if valid_760518 != nil:
    section.add "id", valid_760518
  var valid_760519 = path.getOrDefault("subscribable_id")
  valid_760519 = validateParameter(valid_760519, JString, required = true,
                                 default = nil)
  if valid_760519 != nil:
    section.add "subscribable_id", valid_760519
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760520: Call_DeleteV3ProjectsIdLabelsSubscribableIdSubscription_760515;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Unsubscribe from a resource
  ## 
  let valid = call_760520.validator(path, query, header, formData, body)
  let scheme = call_760520.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760520.url(scheme.get, call_760520.host, call_760520.base,
                         call_760520.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760520, url, valid)

proc call*(call_760521: Call_DeleteV3ProjectsIdLabelsSubscribableIdSubscription_760515;
          id: string; subscribableId: string): Recallable =
  ## deleteV3ProjectsIdLabelsSubscribableIdSubscription
  ## Unsubscribe from a resource
  ##   id: string (required)
  ##     : The ID of a project
  ##   subscribableId: string (required)
  ##                 : The ID of a resource
  var path_760522 = newJObject()
  add(path_760522, "id", newJString(id))
  add(path_760522, "subscribable_id", newJString(subscribableId))
  result = call_760521.call(path_760522, nil, nil, nil, nil)

var deleteV3ProjectsIdLabelsSubscribableIdSubscription* = Call_DeleteV3ProjectsIdLabelsSubscribableIdSubscription_760515(
    name: "deleteV3ProjectsIdLabelsSubscribableIdSubscription",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/labels/{subscribable_id}/subscription",
    validator: validate_DeleteV3ProjectsIdLabelsSubscribableIdSubscription_760516,
    base: "/api", url: url_DeleteV3ProjectsIdLabelsSubscribableIdSubscription_760517,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMembers_760534 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMembers_760536(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMembers_760535(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a member to a group or project.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760537 = path.getOrDefault("id")
  valid_760537 = validateParameter(valid_760537, JString, required = true,
                                 default = nil)
  if valid_760537 != nil:
    section.add "id", valid_760537
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   access_level: JInt (required)
  ##               : A valid access level (defaults: `30`, developer access level)
  ##   expires_at: JString
  ##             : Date string in the format YEAR-MONTH-DAY
  ##   user_id: JInt (required)
  ##          : The user ID of the new member
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `access_level` field"
  var valid_760538 = formData.getOrDefault("access_level")
  valid_760538 = validateParameter(valid_760538, JInt, required = true, default = nil)
  if valid_760538 != nil:
    section.add "access_level", valid_760538
  var valid_760539 = formData.getOrDefault("expires_at")
  valid_760539 = validateParameter(valid_760539, JString, required = false,
                                 default = nil)
  if valid_760539 != nil:
    section.add "expires_at", valid_760539
  var valid_760540 = formData.getOrDefault("user_id")
  valid_760540 = validateParameter(valid_760540, JInt, required = true, default = nil)
  if valid_760540 != nil:
    section.add "user_id", valid_760540
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760541: Call_PostV3ProjectsIdMembers_760534; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a member to a group or project.
  ## 
  let valid = call_760541.validator(path, query, header, formData, body)
  let scheme = call_760541.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760541.url(scheme.get, call_760541.host, call_760541.base,
                         call_760541.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760541, url, valid)

proc call*(call_760542: Call_PostV3ProjectsIdMembers_760534; accessLevel: int;
          id: string; userId: int; expiresAt: string = ""): Recallable =
  ## postV3ProjectsIdMembers
  ## Adds a member to a group or project.
  ##   accessLevel: int (required)
  ##              : A valid access level (defaults: `30`, developer access level)
  ##   id: string (required)
  ##     : The project ID
  ##   expiresAt: string
  ##            : Date string in the format YEAR-MONTH-DAY
  ##   userId: int (required)
  ##         : The user ID of the new member
  var path_760543 = newJObject()
  var formData_760544 = newJObject()
  add(formData_760544, "access_level", newJInt(accessLevel))
  add(path_760543, "id", newJString(id))
  add(formData_760544, "expires_at", newJString(expiresAt))
  add(formData_760544, "user_id", newJInt(userId))
  result = call_760542.call(path_760543, nil, nil, formData_760544, nil)

var postV3ProjectsIdMembers* = Call_PostV3ProjectsIdMembers_760534(
    name: "postV3ProjectsIdMembers", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/members",
    validator: validate_PostV3ProjectsIdMembers_760535, base: "/api",
    url: url_PostV3ProjectsIdMembers_760536, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMembers_760523 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMembers_760525(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMembers_760524(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of group or project members viewable by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760526 = path.getOrDefault("id")
  valid_760526 = validateParameter(valid_760526, JString, required = true,
                                 default = nil)
  if valid_760526 != nil:
    section.add "id", valid_760526
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   query: JString
  ##        : A query string to search for members
  section = newJObject()
  var valid_760527 = query.getOrDefault("per_page")
  valid_760527 = validateParameter(valid_760527, JInt, required = false, default = nil)
  if valid_760527 != nil:
    section.add "per_page", valid_760527
  var valid_760528 = query.getOrDefault("page")
  valid_760528 = validateParameter(valid_760528, JInt, required = false, default = nil)
  if valid_760528 != nil:
    section.add "page", valid_760528
  var valid_760529 = query.getOrDefault("query")
  valid_760529 = validateParameter(valid_760529, JString, required = false,
                                 default = nil)
  if valid_760529 != nil:
    section.add "query", valid_760529
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760530: Call_GetV3ProjectsIdMembers_760523; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of group or project members viewable by the authenticated user.
  ## 
  let valid = call_760530.validator(path, query, header, formData, body)
  let scheme = call_760530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760530.url(scheme.get, call_760530.host, call_760530.base,
                         call_760530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760530, url, valid)

proc call*(call_760531: Call_GetV3ProjectsIdMembers_760523; id: string;
          perPage: int = 0; page: int = 0; query: string = ""): Recallable =
  ## getV3ProjectsIdMembers
  ## Gets a list of group or project members viewable by the authenticated user.
  ##   id: string (required)
  ##     : The project ID
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   query: string
  ##        : A query string to search for members
  var path_760532 = newJObject()
  var query_760533 = newJObject()
  add(path_760532, "id", newJString(id))
  add(query_760533, "per_page", newJInt(perPage))
  add(query_760533, "page", newJInt(page))
  add(query_760533, "query", newJString(query))
  result = call_760531.call(path_760532, query_760533, nil, nil, nil)

var getV3ProjectsIdMembers* = Call_GetV3ProjectsIdMembers_760523(
    name: "getV3ProjectsIdMembers", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/members",
    validator: validate_GetV3ProjectsIdMembers_760524, base: "/api",
    url: url_GetV3ProjectsIdMembers_760525, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdMembersUserId_760553 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdMembersUserId_760555(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "user_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdMembersUserId_760554(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a member of a group or project.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   user_id: JInt (required)
  ##          : The user ID of the new member
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760556 = path.getOrDefault("id")
  valid_760556 = validateParameter(valid_760556, JString, required = true,
                                 default = nil)
  if valid_760556 != nil:
    section.add "id", valid_760556
  var valid_760557 = path.getOrDefault("user_id")
  valid_760557 = validateParameter(valid_760557, JInt, required = true, default = nil)
  if valid_760557 != nil:
    section.add "user_id", valid_760557
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   access_level: JInt (required)
  ##               : A valid access level
  ##   expires_at: JString
  ##             : Date string in the format YEAR-MONTH-DAY
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `access_level` field"
  var valid_760558 = formData.getOrDefault("access_level")
  valid_760558 = validateParameter(valid_760558, JInt, required = true, default = nil)
  if valid_760558 != nil:
    section.add "access_level", valid_760558
  var valid_760559 = formData.getOrDefault("expires_at")
  valid_760559 = validateParameter(valid_760559, JString, required = false,
                                 default = nil)
  if valid_760559 != nil:
    section.add "expires_at", valid_760559
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760560: Call_PutV3ProjectsIdMembersUserId_760553; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a member of a group or project.
  ## 
  let valid = call_760560.validator(path, query, header, formData, body)
  let scheme = call_760560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760560.url(scheme.get, call_760560.host, call_760560.base,
                         call_760560.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760560, url, valid)

proc call*(call_760561: Call_PutV3ProjectsIdMembersUserId_760553; accessLevel: int;
          id: string; userId: int; expiresAt: string = ""): Recallable =
  ## putV3ProjectsIdMembersUserId
  ## Updates a member of a group or project.
  ##   accessLevel: int (required)
  ##              : A valid access level
  ##   id: string (required)
  ##     : The project ID
  ##   expiresAt: string
  ##            : Date string in the format YEAR-MONTH-DAY
  ##   userId: int (required)
  ##         : The user ID of the new member
  var path_760562 = newJObject()
  var formData_760563 = newJObject()
  add(formData_760563, "access_level", newJInt(accessLevel))
  add(path_760562, "id", newJString(id))
  add(formData_760563, "expires_at", newJString(expiresAt))
  add(path_760562, "user_id", newJInt(userId))
  result = call_760561.call(path_760562, nil, nil, formData_760563, nil)

var putV3ProjectsIdMembersUserId* = Call_PutV3ProjectsIdMembersUserId_760553(
    name: "putV3ProjectsIdMembersUserId", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/members/{user_id}",
    validator: validate_PutV3ProjectsIdMembersUserId_760554, base: "/api",
    url: url_PutV3ProjectsIdMembersUserId_760555, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMembersUserId_760545 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMembersUserId_760547(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "user_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMembersUserId_760546(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a member of a group or project.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   user_id: JInt (required)
  ##          : The user ID of the member
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760548 = path.getOrDefault("id")
  valid_760548 = validateParameter(valid_760548, JString, required = true,
                                 default = nil)
  if valid_760548 != nil:
    section.add "id", valid_760548
  var valid_760549 = path.getOrDefault("user_id")
  valid_760549 = validateParameter(valid_760549, JInt, required = true, default = nil)
  if valid_760549 != nil:
    section.add "user_id", valid_760549
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760550: Call_GetV3ProjectsIdMembersUserId_760545; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a member of a group or project.
  ## 
  let valid = call_760550.validator(path, query, header, formData, body)
  let scheme = call_760550.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760550.url(scheme.get, call_760550.host, call_760550.base,
                         call_760550.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760550, url, valid)

proc call*(call_760551: Call_GetV3ProjectsIdMembersUserId_760545; id: string;
          userId: int): Recallable =
  ## getV3ProjectsIdMembersUserId
  ## Gets a member of a group or project.
  ##   id: string (required)
  ##     : The project ID
  ##   userId: int (required)
  ##         : The user ID of the member
  var path_760552 = newJObject()
  add(path_760552, "id", newJString(id))
  add(path_760552, "user_id", newJInt(userId))
  result = call_760551.call(path_760552, nil, nil, nil, nil)

var getV3ProjectsIdMembersUserId* = Call_GetV3ProjectsIdMembersUserId_760545(
    name: "getV3ProjectsIdMembersUserId", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/members/{user_id}",
    validator: validate_GetV3ProjectsIdMembersUserId_760546, base: "/api",
    url: url_GetV3ProjectsIdMembersUserId_760547, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdMembersUserId_760564 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdMembersUserId_760566(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "user_id" in path, "`user_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "user_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdMembersUserId_760565(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes a user from a group or project.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   user_id: JInt (required)
  ##          : The user ID of the member
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760567 = path.getOrDefault("id")
  valid_760567 = validateParameter(valid_760567, JString, required = true,
                                 default = nil)
  if valid_760567 != nil:
    section.add "id", valid_760567
  var valid_760568 = path.getOrDefault("user_id")
  valid_760568 = validateParameter(valid_760568, JInt, required = true, default = nil)
  if valid_760568 != nil:
    section.add "user_id", valid_760568
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760569: Call_DeleteV3ProjectsIdMembersUserId_760564;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Removes a user from a group or project.
  ## 
  let valid = call_760569.validator(path, query, header, formData, body)
  let scheme = call_760569.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760569.url(scheme.get, call_760569.host, call_760569.base,
                         call_760569.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760569, url, valid)

proc call*(call_760570: Call_DeleteV3ProjectsIdMembersUserId_760564; id: string;
          userId: int): Recallable =
  ## deleteV3ProjectsIdMembersUserId
  ## Removes a user from a group or project.
  ##   id: string (required)
  ##     : The project ID
  ##   userId: int (required)
  ##         : The user ID of the member
  var path_760571 = newJObject()
  add(path_760571, "id", newJString(id))
  add(path_760571, "user_id", newJInt(userId))
  result = call_760570.call(path_760571, nil, nil, nil, nil)

var deleteV3ProjectsIdMembersUserId* = Call_DeleteV3ProjectsIdMembersUserId_760564(
    name: "deleteV3ProjectsIdMembersUserId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/members/{user_id}",
    validator: validate_DeleteV3ProjectsIdMembersUserId_760565, base: "/api",
    url: url_DeleteV3ProjectsIdMembersUserId_760566, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdMergeRequestMergeRequestId_760580 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdMergeRequestMergeRequestId_760582(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "merge_request_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdMergeRequestMergeRequestId_760581(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a merge request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760583 = path.getOrDefault("id")
  valid_760583 = validateParameter(valid_760583, JString, required = true,
                                 default = nil)
  if valid_760583 != nil:
    section.add "id", valid_760583
  var valid_760584 = path.getOrDefault("merge_request_id")
  valid_760584 = validateParameter(valid_760584, JInt, required = true, default = nil)
  if valid_760584 != nil:
    section.add "merge_request_id", valid_760584
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   remove_source_branch: JBool
  ##                       : Remove source branch when merging
  ##   title: JString
  ##        : The title of the merge request
  ##   labels: JString
  ##         : Comma-separated list of label names
  ##   milestone_id: JInt
  ##               : The ID of a milestone to assign the merge request
  ##   assignee_id: JInt
  ##              : The ID of a user to assign the merge request
  ##   target_branch: JString
  ##                : The target branch
  ##   description: JString
  ##              : The description of the merge request
  ##   state_event: JString
  ##              : Status of the merge request
  section = newJObject()
  var valid_760585 = formData.getOrDefault("remove_source_branch")
  valid_760585 = validateParameter(valid_760585, JBool, required = false, default = nil)
  if valid_760585 != nil:
    section.add "remove_source_branch", valid_760585
  var valid_760586 = formData.getOrDefault("title")
  valid_760586 = validateParameter(valid_760586, JString, required = false,
                                 default = nil)
  if valid_760586 != nil:
    section.add "title", valid_760586
  var valid_760587 = formData.getOrDefault("labels")
  valid_760587 = validateParameter(valid_760587, JString, required = false,
                                 default = nil)
  if valid_760587 != nil:
    section.add "labels", valid_760587
  var valid_760588 = formData.getOrDefault("milestone_id")
  valid_760588 = validateParameter(valid_760588, JInt, required = false, default = nil)
  if valid_760588 != nil:
    section.add "milestone_id", valid_760588
  var valid_760589 = formData.getOrDefault("assignee_id")
  valid_760589 = validateParameter(valid_760589, JInt, required = false, default = nil)
  if valid_760589 != nil:
    section.add "assignee_id", valid_760589
  var valid_760590 = formData.getOrDefault("target_branch")
  valid_760590 = validateParameter(valid_760590, JString, required = false,
                                 default = nil)
  if valid_760590 != nil:
    section.add "target_branch", valid_760590
  var valid_760591 = formData.getOrDefault("description")
  valid_760591 = validateParameter(valid_760591, JString, required = false,
                                 default = nil)
  if valid_760591 != nil:
    section.add "description", valid_760591
  var valid_760592 = formData.getOrDefault("state_event")
  valid_760592 = validateParameter(valid_760592, JString, required = false,
                                 default = newJString("close"))
  if valid_760592 != nil:
    section.add "state_event", valid_760592
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760593: Call_PutV3ProjectsIdMergeRequestMergeRequestId_760580;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a merge request
  ## 
  let valid = call_760593.validator(path, query, header, formData, body)
  let scheme = call_760593.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760593.url(scheme.get, call_760593.host, call_760593.base,
                         call_760593.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760593, url, valid)

proc call*(call_760594: Call_PutV3ProjectsIdMergeRequestMergeRequestId_760580;
          id: string; mergeRequestId: int; removeSourceBranch: bool = false;
          title: string = ""; labels: string = ""; milestoneId: int = 0;
          assigneeId: int = 0; targetBranch: string = ""; description: string = "";
          stateEvent: string = "close"): Recallable =
  ## putV3ProjectsIdMergeRequestMergeRequestId
  ## Update a merge request
  ##   removeSourceBranch: bool
  ##                     : Remove source branch when merging
  ##   title: string
  ##        : The title of the merge request
  ##   labels: string
  ##         : Comma-separated list of label names
  ##   id: string (required)
  ##     : The ID of a project
  ##   milestoneId: int
  ##              : The ID of a milestone to assign the merge request
  ##   assigneeId: int
  ##             : The ID of a user to assign the merge request
  ##   targetBranch: string
  ##               : The target branch
  ##   description: string
  ##              : The description of the merge request
  ##   stateEvent: string
  ##             : Status of the merge request
  ##   mergeRequestId: int (required)
  var path_760595 = newJObject()
  var formData_760596 = newJObject()
  add(formData_760596, "remove_source_branch", newJBool(removeSourceBranch))
  add(formData_760596, "title", newJString(title))
  add(formData_760596, "labels", newJString(labels))
  add(path_760595, "id", newJString(id))
  add(formData_760596, "milestone_id", newJInt(milestoneId))
  add(formData_760596, "assignee_id", newJInt(assigneeId))
  add(formData_760596, "target_branch", newJString(targetBranch))
  add(formData_760596, "description", newJString(description))
  add(formData_760596, "state_event", newJString(stateEvent))
  add(path_760595, "merge_request_id", newJInt(mergeRequestId))
  result = call_760594.call(path_760595, nil, nil, formData_760596, nil)

var putV3ProjectsIdMergeRequestMergeRequestId* = Call_PutV3ProjectsIdMergeRequestMergeRequestId_760580(
    name: "putV3ProjectsIdMergeRequestMergeRequestId", meth: HttpMethod.HttpPut,
    host: "gitlab.com",
    route: "/v3/projects/{id}/merge_request/{merge_request_id}",
    validator: validate_PutV3ProjectsIdMergeRequestMergeRequestId_760581,
    base: "/api", url: url_PutV3ProjectsIdMergeRequestMergeRequestId_760582,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestMergeRequestId_760572 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestMergeRequestId_760574(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "merge_request_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestMergeRequestId_760573(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  ##                   : The ID of a merge request
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760575 = path.getOrDefault("id")
  valid_760575 = validateParameter(valid_760575, JString, required = true,
                                 default = nil)
  if valid_760575 != nil:
    section.add "id", valid_760575
  var valid_760576 = path.getOrDefault("merge_request_id")
  valid_760576 = validateParameter(valid_760576, JInt, required = true, default = nil)
  if valid_760576 != nil:
    section.add "merge_request_id", valid_760576
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760577: Call_GetV3ProjectsIdMergeRequestMergeRequestId_760572;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This endpoint is deprecated and will be removed in GitLab 9.0.
  ## 
  let valid = call_760577.validator(path, query, header, formData, body)
  let scheme = call_760577.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760577.url(scheme.get, call_760577.host, call_760577.base,
                         call_760577.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760577, url, valid)

proc call*(call_760578: Call_GetV3ProjectsIdMergeRequestMergeRequestId_760572;
          id: string; mergeRequestId: int): Recallable =
  ## getV3ProjectsIdMergeRequestMergeRequestId
  ## This endpoint is deprecated and will be removed in GitLab 9.0.
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  ##                 : The ID of a merge request
  var path_760579 = newJObject()
  add(path_760579, "id", newJString(id))
  add(path_760579, "merge_request_id", newJInt(mergeRequestId))
  result = call_760578.call(path_760579, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestMergeRequestId* = Call_GetV3ProjectsIdMergeRequestMergeRequestId_760572(
    name: "getV3ProjectsIdMergeRequestMergeRequestId", meth: HttpMethod.HttpGet,
    host: "gitlab.com",
    route: "/v3/projects/{id}/merge_request/{merge_request_id}",
    validator: validate_GetV3ProjectsIdMergeRequestMergeRequestId_760573,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestMergeRequestId_760574,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds_760597 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds_760599(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "merge_request_id"), (
        kind: ConstantSegment, value: "/cancel_merge_when_build_succeeds")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds_760598(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Cancel merge if "Merge When Pipeline Succeeds" is enabled
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760600 = path.getOrDefault("id")
  valid_760600 = validateParameter(valid_760600, JString, required = true,
                                 default = nil)
  if valid_760600 != nil:
    section.add "id", valid_760600
  var valid_760601 = path.getOrDefault("merge_request_id")
  valid_760601 = validateParameter(valid_760601, JInt, required = true, default = nil)
  if valid_760601 != nil:
    section.add "merge_request_id", valid_760601
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760602: Call_PostV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds_760597;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancel merge if "Merge When Pipeline Succeeds" is enabled
  ## 
  let valid = call_760602.validator(path, query, header, formData, body)
  let scheme = call_760602.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760602.url(scheme.get, call_760602.host, call_760602.base,
                         call_760602.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760602, url, valid)

proc call*(call_760603: Call_PostV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds_760597;
          id: string; mergeRequestId: int): Recallable =
  ## postV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds
  ## Cancel merge if "Merge When Pipeline Succeeds" is enabled
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  var path_760604 = newJObject()
  add(path_760604, "id", newJString(id))
  add(path_760604, "merge_request_id", newJInt(mergeRequestId))
  result = call_760603.call(path_760604, nil, nil, nil, nil)

var postV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds* = Call_PostV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds_760597(name: "postV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/projects/{id}/merge_request/{merge_request_id}/cancel_merge_when_build_succeeds", validator: validate_PostV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds_760598,
    base: "/api", url: url_PostV3ProjectsIdMergeRequestMergeRequestIdCancelMergeWhenBuildSucceeds_760599,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestMergeRequestIdChanges_760605 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestMergeRequestIdChanges_760607(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/changes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestMergeRequestIdChanges_760606(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Show the merge request changes
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760608 = path.getOrDefault("id")
  valid_760608 = validateParameter(valid_760608, JString, required = true,
                                 default = nil)
  if valid_760608 != nil:
    section.add "id", valid_760608
  var valid_760609 = path.getOrDefault("merge_request_id")
  valid_760609 = validateParameter(valid_760609, JInt, required = true, default = nil)
  if valid_760609 != nil:
    section.add "merge_request_id", valid_760609
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760610: Call_GetV3ProjectsIdMergeRequestMergeRequestIdChanges_760605;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Show the merge request changes
  ## 
  let valid = call_760610.validator(path, query, header, formData, body)
  let scheme = call_760610.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760610.url(scheme.get, call_760610.host, call_760610.base,
                         call_760610.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760610, url, valid)

proc call*(call_760611: Call_GetV3ProjectsIdMergeRequestMergeRequestIdChanges_760605;
          id: string; mergeRequestId: int): Recallable =
  ## getV3ProjectsIdMergeRequestMergeRequestIdChanges
  ## Show the merge request changes
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  var path_760612 = newJObject()
  add(path_760612, "id", newJString(id))
  add(path_760612, "merge_request_id", newJInt(mergeRequestId))
  result = call_760611.call(path_760612, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestMergeRequestIdChanges* = Call_GetV3ProjectsIdMergeRequestMergeRequestIdChanges_760605(
    name: "getV3ProjectsIdMergeRequestMergeRequestIdChanges",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_request/{merge_request_id}/changes",
    validator: validate_GetV3ProjectsIdMergeRequestMergeRequestIdChanges_760606,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestMergeRequestIdChanges_760607,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestMergeRequestIdClosesIssues_760613 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestMergeRequestIdClosesIssues_760615(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/closes_issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestMergeRequestIdClosesIssues_760614(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## List issues that will be closed on merge
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760616 = path.getOrDefault("id")
  valid_760616 = validateParameter(valid_760616, JString, required = true,
                                 default = nil)
  if valid_760616 != nil:
    section.add "id", valid_760616
  var valid_760617 = path.getOrDefault("merge_request_id")
  valid_760617 = validateParameter(valid_760617, JInt, required = true, default = nil)
  if valid_760617 != nil:
    section.add "merge_request_id", valid_760617
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760618 = query.getOrDefault("per_page")
  valid_760618 = validateParameter(valid_760618, JInt, required = false, default = nil)
  if valid_760618 != nil:
    section.add "per_page", valid_760618
  var valid_760619 = query.getOrDefault("page")
  valid_760619 = validateParameter(valid_760619, JInt, required = false, default = nil)
  if valid_760619 != nil:
    section.add "page", valid_760619
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760620: Call_GetV3ProjectsIdMergeRequestMergeRequestIdClosesIssues_760613;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List issues that will be closed on merge
  ## 
  let valid = call_760620.validator(path, query, header, formData, body)
  let scheme = call_760620.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760620.url(scheme.get, call_760620.host, call_760620.base,
                         call_760620.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760620, url, valid)

proc call*(call_760621: Call_GetV3ProjectsIdMergeRequestMergeRequestIdClosesIssues_760613;
          id: string; mergeRequestId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdMergeRequestMergeRequestIdClosesIssues
  ## List issues that will be closed on merge
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   mergeRequestId: int (required)
  var path_760622 = newJObject()
  var query_760623 = newJObject()
  add(path_760622, "id", newJString(id))
  add(query_760623, "per_page", newJInt(perPage))
  add(query_760623, "page", newJInt(page))
  add(path_760622, "merge_request_id", newJInt(mergeRequestId))
  result = call_760621.call(path_760622, query_760623, nil, nil, nil)

var getV3ProjectsIdMergeRequestMergeRequestIdClosesIssues* = Call_GetV3ProjectsIdMergeRequestMergeRequestIdClosesIssues_760613(
    name: "getV3ProjectsIdMergeRequestMergeRequestIdClosesIssues",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_request/{merge_request_id}/closes_issues",
    validator: validate_GetV3ProjectsIdMergeRequestMergeRequestIdClosesIssues_760614,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestMergeRequestIdClosesIssues_760615,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestMergeRequestIdComments_760635 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestMergeRequestIdComments_760637(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestMergeRequestIdComments_760636(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760638 = path.getOrDefault("id")
  valid_760638 = validateParameter(valid_760638, JString, required = true,
                                 default = nil)
  if valid_760638 != nil:
    section.add "id", valid_760638
  var valid_760639 = path.getOrDefault("merge_request_id")
  valid_760639 = validateParameter(valid_760639, JInt, required = true, default = nil)
  if valid_760639 != nil:
    section.add "merge_request_id", valid_760639
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   note: JString (required)
  ##       : The text of the comment
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `note` field"
  var valid_760640 = formData.getOrDefault("note")
  valid_760640 = validateParameter(valid_760640, JString, required = true,
                                 default = nil)
  if valid_760640 != nil:
    section.add "note", valid_760640
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760641: Call_PostV3ProjectsIdMergeRequestMergeRequestIdComments_760635;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ## 
  let valid = call_760641.validator(path, query, header, formData, body)
  let scheme = call_760641.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760641.url(scheme.get, call_760641.host, call_760641.base,
                         call_760641.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760641, url, valid)

proc call*(call_760642: Call_PostV3ProjectsIdMergeRequestMergeRequestIdComments_760635;
          id: string; note: string; mergeRequestId: int): Recallable =
  ## postV3ProjectsIdMergeRequestMergeRequestIdComments
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ##   id: string (required)
  ##     : The ID of a project
  ##   note: string (required)
  ##       : The text of the comment
  ##   mergeRequestId: int (required)
  var path_760643 = newJObject()
  var formData_760644 = newJObject()
  add(path_760643, "id", newJString(id))
  add(formData_760644, "note", newJString(note))
  add(path_760643, "merge_request_id", newJInt(mergeRequestId))
  result = call_760642.call(path_760643, nil, nil, formData_760644, nil)

var postV3ProjectsIdMergeRequestMergeRequestIdComments* = Call_PostV3ProjectsIdMergeRequestMergeRequestIdComments_760635(
    name: "postV3ProjectsIdMergeRequestMergeRequestIdComments",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_request/{merge_request_id}/comments",
    validator: validate_PostV3ProjectsIdMergeRequestMergeRequestIdComments_760636,
    base: "/api", url: url_PostV3ProjectsIdMergeRequestMergeRequestIdComments_760637,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestMergeRequestIdComments_760624 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestMergeRequestIdComments_760626(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestMergeRequestIdComments_760625(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760627 = path.getOrDefault("id")
  valid_760627 = validateParameter(valid_760627, JString, required = true,
                                 default = nil)
  if valid_760627 != nil:
    section.add "id", valid_760627
  var valid_760628 = path.getOrDefault("merge_request_id")
  valid_760628 = validateParameter(valid_760628, JInt, required = true, default = nil)
  if valid_760628 != nil:
    section.add "merge_request_id", valid_760628
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760629 = query.getOrDefault("per_page")
  valid_760629 = validateParameter(valid_760629, JInt, required = false, default = nil)
  if valid_760629 != nil:
    section.add "per_page", valid_760629
  var valid_760630 = query.getOrDefault("page")
  valid_760630 = validateParameter(valid_760630, JInt, required = false, default = nil)
  if valid_760630 != nil:
    section.add "page", valid_760630
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760631: Call_GetV3ProjectsIdMergeRequestMergeRequestIdComments_760624;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ## 
  let valid = call_760631.validator(path, query, header, formData, body)
  let scheme = call_760631.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760631.url(scheme.get, call_760631.host, call_760631.base,
                         call_760631.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760631, url, valid)

proc call*(call_760632: Call_GetV3ProjectsIdMergeRequestMergeRequestIdComments_760624;
          id: string; mergeRequestId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdMergeRequestMergeRequestIdComments
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   mergeRequestId: int (required)
  var path_760633 = newJObject()
  var query_760634 = newJObject()
  add(path_760633, "id", newJString(id))
  add(query_760634, "per_page", newJInt(perPage))
  add(query_760634, "page", newJInt(page))
  add(path_760633, "merge_request_id", newJInt(mergeRequestId))
  result = call_760632.call(path_760633, query_760634, nil, nil, nil)

var getV3ProjectsIdMergeRequestMergeRequestIdComments* = Call_GetV3ProjectsIdMergeRequestMergeRequestIdComments_760624(
    name: "getV3ProjectsIdMergeRequestMergeRequestIdComments",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_request/{merge_request_id}/comments",
    validator: validate_GetV3ProjectsIdMergeRequestMergeRequestIdComments_760625,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestMergeRequestIdComments_760626,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestMergeRequestIdCommits_760645 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestMergeRequestIdCommits_760647(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestMergeRequestIdCommits_760646(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Get the commits of a merge request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760648 = path.getOrDefault("id")
  valid_760648 = validateParameter(valid_760648, JString, required = true,
                                 default = nil)
  if valid_760648 != nil:
    section.add "id", valid_760648
  var valid_760649 = path.getOrDefault("merge_request_id")
  valid_760649 = validateParameter(valid_760649, JInt, required = true, default = nil)
  if valid_760649 != nil:
    section.add "merge_request_id", valid_760649
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760650: Call_GetV3ProjectsIdMergeRequestMergeRequestIdCommits_760645;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the commits of a merge request
  ## 
  let valid = call_760650.validator(path, query, header, formData, body)
  let scheme = call_760650.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760650.url(scheme.get, call_760650.host, call_760650.base,
                         call_760650.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760650, url, valid)

proc call*(call_760651: Call_GetV3ProjectsIdMergeRequestMergeRequestIdCommits_760645;
          id: string; mergeRequestId: int): Recallable =
  ## getV3ProjectsIdMergeRequestMergeRequestIdCommits
  ## Get the commits of a merge request
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  var path_760652 = newJObject()
  add(path_760652, "id", newJString(id))
  add(path_760652, "merge_request_id", newJInt(mergeRequestId))
  result = call_760651.call(path_760652, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestMergeRequestIdCommits* = Call_GetV3ProjectsIdMergeRequestMergeRequestIdCommits_760645(
    name: "getV3ProjectsIdMergeRequestMergeRequestIdCommits",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_request/{merge_request_id}/commits",
    validator: validate_GetV3ProjectsIdMergeRequestMergeRequestIdCommits_760646,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestMergeRequestIdCommits_760647,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdMergeRequestMergeRequestIdMerge_760653 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdMergeRequestMergeRequestIdMerge_760655(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdMergeRequestMergeRequestIdMerge_760654(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Merge a merge request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760656 = path.getOrDefault("id")
  valid_760656 = validateParameter(valid_760656, JString, required = true,
                                 default = nil)
  if valid_760656 != nil:
    section.add "id", valid_760656
  var valid_760657 = path.getOrDefault("merge_request_id")
  valid_760657 = validateParameter(valid_760657, JInt, required = true, default = nil)
  if valid_760657 != nil:
    section.add "merge_request_id", valid_760657
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   merge_commit_message: JString
  ##                       : Custom merge commit message
  ##   sha: JString
  ##      : When present, must have the HEAD SHA of the source branch
  ##   merge_when_build_succeeds: JBool
  ##                            : When true, this merge request will be merged when the pipeline succeeds
  ##   should_remove_source_branch: JBool
  ##                              : When true, the source branch will be deleted if possible
  section = newJObject()
  var valid_760658 = formData.getOrDefault("merge_commit_message")
  valid_760658 = validateParameter(valid_760658, JString, required = false,
                                 default = nil)
  if valid_760658 != nil:
    section.add "merge_commit_message", valid_760658
  var valid_760659 = formData.getOrDefault("sha")
  valid_760659 = validateParameter(valid_760659, JString, required = false,
                                 default = nil)
  if valid_760659 != nil:
    section.add "sha", valid_760659
  var valid_760660 = formData.getOrDefault("merge_when_build_succeeds")
  valid_760660 = validateParameter(valid_760660, JBool, required = false, default = nil)
  if valid_760660 != nil:
    section.add "merge_when_build_succeeds", valid_760660
  var valid_760661 = formData.getOrDefault("should_remove_source_branch")
  valid_760661 = validateParameter(valid_760661, JBool, required = false, default = nil)
  if valid_760661 != nil:
    section.add "should_remove_source_branch", valid_760661
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760662: Call_PutV3ProjectsIdMergeRequestMergeRequestIdMerge_760653;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Merge a merge request
  ## 
  let valid = call_760662.validator(path, query, header, formData, body)
  let scheme = call_760662.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760662.url(scheme.get, call_760662.host, call_760662.base,
                         call_760662.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760662, url, valid)

proc call*(call_760663: Call_PutV3ProjectsIdMergeRequestMergeRequestIdMerge_760653;
          id: string; mergeRequestId: int; mergeCommitMessage: string = "";
          sha: string = ""; mergeWhenBuildSucceeds: bool = false;
          shouldRemoveSourceBranch: bool = false): Recallable =
  ## putV3ProjectsIdMergeRequestMergeRequestIdMerge
  ## Merge a merge request
  ##   mergeCommitMessage: string
  ##                     : Custom merge commit message
  ##   sha: string
  ##      : When present, must have the HEAD SHA of the source branch
  ##   mergeWhenBuildSucceeds: bool
  ##                         : When true, this merge request will be merged when the pipeline succeeds
  ##   id: string (required)
  ##     : The ID of a project
  ##   shouldRemoveSourceBranch: bool
  ##                           : When true, the source branch will be deleted if possible
  ##   mergeRequestId: int (required)
  var path_760664 = newJObject()
  var formData_760665 = newJObject()
  add(formData_760665, "merge_commit_message", newJString(mergeCommitMessage))
  add(formData_760665, "sha", newJString(sha))
  add(formData_760665, "merge_when_build_succeeds",
      newJBool(mergeWhenBuildSucceeds))
  add(path_760664, "id", newJString(id))
  add(formData_760665, "should_remove_source_branch",
      newJBool(shouldRemoveSourceBranch))
  add(path_760664, "merge_request_id", newJInt(mergeRequestId))
  result = call_760663.call(path_760664, nil, nil, formData_760665, nil)

var putV3ProjectsIdMergeRequestMergeRequestIdMerge* = Call_PutV3ProjectsIdMergeRequestMergeRequestIdMerge_760653(
    name: "putV3ProjectsIdMergeRequestMergeRequestIdMerge",
    meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_request/{merge_request_id}/merge",
    validator: validate_PutV3ProjectsIdMergeRequestMergeRequestIdMerge_760654,
    base: "/api", url: url_PutV3ProjectsIdMergeRequestMergeRequestIdMerge_760655,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestSubscribableIdSubscription_760666 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestSubscribableIdSubscription_760668(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "subscribable_id" in path, "`subscribable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "subscribable_id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestSubscribableIdSubscription_760667(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Subscribe to a resource
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   subscribable_id: JString (required)
  ##                  : The ID of a resource
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760669 = path.getOrDefault("id")
  valid_760669 = validateParameter(valid_760669, JString, required = true,
                                 default = nil)
  if valid_760669 != nil:
    section.add "id", valid_760669
  var valid_760670 = path.getOrDefault("subscribable_id")
  valid_760670 = validateParameter(valid_760670, JString, required = true,
                                 default = nil)
  if valid_760670 != nil:
    section.add "subscribable_id", valid_760670
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760671: Call_PostV3ProjectsIdMergeRequestSubscribableIdSubscription_760666;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Subscribe to a resource
  ## 
  let valid = call_760671.validator(path, query, header, formData, body)
  let scheme = call_760671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760671.url(scheme.get, call_760671.host, call_760671.base,
                         call_760671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760671, url, valid)

proc call*(call_760672: Call_PostV3ProjectsIdMergeRequestSubscribableIdSubscription_760666;
          id: string; subscribableId: string): Recallable =
  ## postV3ProjectsIdMergeRequestSubscribableIdSubscription
  ## Subscribe to a resource
  ##   id: string (required)
  ##     : The ID of a project
  ##   subscribableId: string (required)
  ##                 : The ID of a resource
  var path_760673 = newJObject()
  add(path_760673, "id", newJString(id))
  add(path_760673, "subscribable_id", newJString(subscribableId))
  result = call_760672.call(path_760673, nil, nil, nil, nil)

var postV3ProjectsIdMergeRequestSubscribableIdSubscription* = Call_PostV3ProjectsIdMergeRequestSubscribableIdSubscription_760666(
    name: "postV3ProjectsIdMergeRequestSubscribableIdSubscription",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_request/{subscribable_id}/subscription",
    validator: validate_PostV3ProjectsIdMergeRequestSubscribableIdSubscription_760667,
    base: "/api", url: url_PostV3ProjectsIdMergeRequestSubscribableIdSubscription_760668,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdMergeRequestSubscribableIdSubscription_760674 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdMergeRequestSubscribableIdSubscription_760676(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "subscribable_id" in path, "`subscribable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_request/"),
               (kind: VariableSegment, value: "subscribable_id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdMergeRequestSubscribableIdSubscription_760675(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Unsubscribe from a resource
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   subscribable_id: JString (required)
  ##                  : The ID of a resource
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760677 = path.getOrDefault("id")
  valid_760677 = validateParameter(valid_760677, JString, required = true,
                                 default = nil)
  if valid_760677 != nil:
    section.add "id", valid_760677
  var valid_760678 = path.getOrDefault("subscribable_id")
  valid_760678 = validateParameter(valid_760678, JString, required = true,
                                 default = nil)
  if valid_760678 != nil:
    section.add "subscribable_id", valid_760678
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760679: Call_DeleteV3ProjectsIdMergeRequestSubscribableIdSubscription_760674;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Unsubscribe from a resource
  ## 
  let valid = call_760679.validator(path, query, header, formData, body)
  let scheme = call_760679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760679.url(scheme.get, call_760679.host, call_760679.base,
                         call_760679.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760679, url, valid)

proc call*(call_760680: Call_DeleteV3ProjectsIdMergeRequestSubscribableIdSubscription_760674;
          id: string; subscribableId: string): Recallable =
  ## deleteV3ProjectsIdMergeRequestSubscribableIdSubscription
  ## Unsubscribe from a resource
  ##   id: string (required)
  ##     : The ID of a project
  ##   subscribableId: string (required)
  ##                 : The ID of a resource
  var path_760681 = newJObject()
  add(path_760681, "id", newJString(id))
  add(path_760681, "subscribable_id", newJString(subscribableId))
  result = call_760680.call(path_760681, nil, nil, nil, nil)

var deleteV3ProjectsIdMergeRequestSubscribableIdSubscription* = Call_DeleteV3ProjectsIdMergeRequestSubscribableIdSubscription_760674(
    name: "deleteV3ProjectsIdMergeRequestSubscribableIdSubscription",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_request/{subscribable_id}/subscription", validator: validate_DeleteV3ProjectsIdMergeRequestSubscribableIdSubscription_760675,
    base: "/api",
    url: url_DeleteV3ProjectsIdMergeRequestSubscribableIdSubscription_760676,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequests_760697 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequests_760699(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequests_760698(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a merge request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760700 = path.getOrDefault("id")
  valid_760700 = validateParameter(valid_760700, JString, required = true,
                                 default = nil)
  if valid_760700 != nil:
    section.add "id", valid_760700
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   remove_source_branch: JBool
  ##                       : Remove source branch when merging
  ##   target_project_id: JInt
  ##                    : The target project of the merge request defaults to the :id of the project
  ##   title: JString (required)
  ##        : The title of the merge request
  ##   labels: JString
  ##         : Comma-separated list of label names
  ##   milestone_id: JInt
  ##               : The ID of a milestone to assign the merge request
  ##   source_branch: JString (required)
  ##                : The source branch
  ##   assignee_id: JInt
  ##              : The ID of a user to assign the merge request
  ##   target_branch: JString (required)
  ##                : The target branch
  ##   description: JString
  ##              : The description of the merge request
  section = newJObject()
  var valid_760701 = formData.getOrDefault("remove_source_branch")
  valid_760701 = validateParameter(valid_760701, JBool, required = false, default = nil)
  if valid_760701 != nil:
    section.add "remove_source_branch", valid_760701
  var valid_760702 = formData.getOrDefault("target_project_id")
  valid_760702 = validateParameter(valid_760702, JInt, required = false, default = nil)
  if valid_760702 != nil:
    section.add "target_project_id", valid_760702
  assert formData != nil,
        "formData argument is necessary due to required `title` field"
  var valid_760703 = formData.getOrDefault("title")
  valid_760703 = validateParameter(valid_760703, JString, required = true,
                                 default = nil)
  if valid_760703 != nil:
    section.add "title", valid_760703
  var valid_760704 = formData.getOrDefault("labels")
  valid_760704 = validateParameter(valid_760704, JString, required = false,
                                 default = nil)
  if valid_760704 != nil:
    section.add "labels", valid_760704
  var valid_760705 = formData.getOrDefault("milestone_id")
  valid_760705 = validateParameter(valid_760705, JInt, required = false, default = nil)
  if valid_760705 != nil:
    section.add "milestone_id", valid_760705
  var valid_760706 = formData.getOrDefault("source_branch")
  valid_760706 = validateParameter(valid_760706, JString, required = true,
                                 default = nil)
  if valid_760706 != nil:
    section.add "source_branch", valid_760706
  var valid_760707 = formData.getOrDefault("assignee_id")
  valid_760707 = validateParameter(valid_760707, JInt, required = false, default = nil)
  if valid_760707 != nil:
    section.add "assignee_id", valid_760707
  var valid_760708 = formData.getOrDefault("target_branch")
  valid_760708 = validateParameter(valid_760708, JString, required = true,
                                 default = nil)
  if valid_760708 != nil:
    section.add "target_branch", valid_760708
  var valid_760709 = formData.getOrDefault("description")
  valid_760709 = validateParameter(valid_760709, JString, required = false,
                                 default = nil)
  if valid_760709 != nil:
    section.add "description", valid_760709
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760710: Call_PostV3ProjectsIdMergeRequests_760697; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a merge request
  ## 
  let valid = call_760710.validator(path, query, header, formData, body)
  let scheme = call_760710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760710.url(scheme.get, call_760710.host, call_760710.base,
                         call_760710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760710, url, valid)

proc call*(call_760711: Call_PostV3ProjectsIdMergeRequests_760697; title: string;
          id: string; sourceBranch: string; targetBranch: string;
          removeSourceBranch: bool = false; targetProjectId: int = 0;
          labels: string = ""; milestoneId: int = 0; assigneeId: int = 0;
          description: string = ""): Recallable =
  ## postV3ProjectsIdMergeRequests
  ## Create a merge request
  ##   removeSourceBranch: bool
  ##                     : Remove source branch when merging
  ##   targetProjectId: int
  ##                  : The target project of the merge request defaults to the :id of the project
  ##   title: string (required)
  ##        : The title of the merge request
  ##   labels: string
  ##         : Comma-separated list of label names
  ##   id: string (required)
  ##     : The ID of a project
  ##   milestoneId: int
  ##              : The ID of a milestone to assign the merge request
  ##   sourceBranch: string (required)
  ##               : The source branch
  ##   assigneeId: int
  ##             : The ID of a user to assign the merge request
  ##   targetBranch: string (required)
  ##               : The target branch
  ##   description: string
  ##              : The description of the merge request
  var path_760712 = newJObject()
  var formData_760713 = newJObject()
  add(formData_760713, "remove_source_branch", newJBool(removeSourceBranch))
  add(formData_760713, "target_project_id", newJInt(targetProjectId))
  add(formData_760713, "title", newJString(title))
  add(formData_760713, "labels", newJString(labels))
  add(path_760712, "id", newJString(id))
  add(formData_760713, "milestone_id", newJInt(milestoneId))
  add(formData_760713, "source_branch", newJString(sourceBranch))
  add(formData_760713, "assignee_id", newJInt(assigneeId))
  add(formData_760713, "target_branch", newJString(targetBranch))
  add(formData_760713, "description", newJString(description))
  result = call_760711.call(path_760712, nil, nil, formData_760713, nil)

var postV3ProjectsIdMergeRequests* = Call_PostV3ProjectsIdMergeRequests_760697(
    name: "postV3ProjectsIdMergeRequests", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/merge_requests",
    validator: validate_PostV3ProjectsIdMergeRequests_760698, base: "/api",
    url: url_PostV3ProjectsIdMergeRequests_760699, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequests_760682 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequests_760684(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequests_760683(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List merge requests
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760685 = path.getOrDefault("id")
  valid_760685 = validateParameter(valid_760685, JString, required = true,
                                 default = nil)
  if valid_760685 != nil:
    section.add "id", valid_760685
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : Return opened, closed, merged, or all merge requests
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   order_by: JString
  ##           : Return merge requests ordered by `created_at` or `updated_at` fields.
  ##   sort: JString
  ##       : Return merge requests sorted in `asc` or `desc` order.
  section = newJObject()
  var valid_760686 = query.getOrDefault("state")
  valid_760686 = validateParameter(valid_760686, JString, required = false,
                                 default = newJString("all"))
  if valid_760686 != nil:
    section.add "state", valid_760686
  var valid_760687 = query.getOrDefault("per_page")
  valid_760687 = validateParameter(valid_760687, JInt, required = false, default = nil)
  if valid_760687 != nil:
    section.add "per_page", valid_760687
  var valid_760688 = query.getOrDefault("page")
  valid_760688 = validateParameter(valid_760688, JInt, required = false, default = nil)
  if valid_760688 != nil:
    section.add "page", valid_760688
  var valid_760689 = query.getOrDefault("order_by")
  valid_760689 = validateParameter(valid_760689, JString, required = false,
                                 default = newJString("created_at"))
  if valid_760689 != nil:
    section.add "order_by", valid_760689
  var valid_760690 = query.getOrDefault("sort")
  valid_760690 = validateParameter(valid_760690, JString, required = false,
                                 default = newJString("desc"))
  if valid_760690 != nil:
    section.add "sort", valid_760690
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   iid: JArray
  ##      : The IID of the merge requests
  section = newJObject()
  var valid_760691 = formData.getOrDefault("iid")
  valid_760691 = validateParameter(valid_760691, JArray, required = false,
                                 default = nil)
  if valid_760691 != nil:
    section.add "iid", valid_760691
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760692: Call_GetV3ProjectsIdMergeRequests_760682; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List merge requests
  ## 
  let valid = call_760692.validator(path, query, header, formData, body)
  let scheme = call_760692.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760692.url(scheme.get, call_760692.host, call_760692.base,
                         call_760692.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760692, url, valid)

proc call*(call_760693: Call_GetV3ProjectsIdMergeRequests_760682; id: string;
          state: string = "all"; perPage: int = 0; page: int = 0; iid: JsonNode = nil;
          orderBy: string = "created_at"; sort: string = "desc"): Recallable =
  ## getV3ProjectsIdMergeRequests
  ## List merge requests
  ##   id: string (required)
  ##     : The ID of a project
  ##   state: string
  ##        : Return opened, closed, merged, or all merge requests
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   iid: JArray
  ##      : The IID of the merge requests
  ##   orderBy: string
  ##          : Return merge requests ordered by `created_at` or `updated_at` fields.
  ##   sort: string
  ##       : Return merge requests sorted in `asc` or `desc` order.
  var path_760694 = newJObject()
  var query_760695 = newJObject()
  var formData_760696 = newJObject()
  add(path_760694, "id", newJString(id))
  add(query_760695, "state", newJString(state))
  add(query_760695, "per_page", newJInt(perPage))
  add(query_760695, "page", newJInt(page))
  if iid != nil:
    formData_760696.add "iid", iid
  add(query_760695, "order_by", newJString(orderBy))
  add(query_760695, "sort", newJString(sort))
  result = call_760693.call(path_760694, query_760695, nil, formData_760696, nil)

var getV3ProjectsIdMergeRequests* = Call_GetV3ProjectsIdMergeRequests_760682(
    name: "getV3ProjectsIdMergeRequests", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/merge_requests",
    validator: validate_GetV3ProjectsIdMergeRequests_760683, base: "/api",
    url: url_GetV3ProjectsIdMergeRequests_760684, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdMergeRequestsMergeRequestId_760722 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdMergeRequestsMergeRequestId_760724(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdMergeRequestsMergeRequestId_760723(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a merge request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760725 = path.getOrDefault("id")
  valid_760725 = validateParameter(valid_760725, JString, required = true,
                                 default = nil)
  if valid_760725 != nil:
    section.add "id", valid_760725
  var valid_760726 = path.getOrDefault("merge_request_id")
  valid_760726 = validateParameter(valid_760726, JInt, required = true, default = nil)
  if valid_760726 != nil:
    section.add "merge_request_id", valid_760726
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   remove_source_branch: JBool
  ##                       : Remove source branch when merging
  ##   title: JString
  ##        : The title of the merge request
  ##   labels: JString
  ##         : Comma-separated list of label names
  ##   milestone_id: JInt
  ##               : The ID of a milestone to assign the merge request
  ##   assignee_id: JInt
  ##              : The ID of a user to assign the merge request
  ##   target_branch: JString
  ##                : The target branch
  ##   description: JString
  ##              : The description of the merge request
  ##   state_event: JString
  ##              : Status of the merge request
  section = newJObject()
  var valid_760727 = formData.getOrDefault("remove_source_branch")
  valid_760727 = validateParameter(valid_760727, JBool, required = false, default = nil)
  if valid_760727 != nil:
    section.add "remove_source_branch", valid_760727
  var valid_760728 = formData.getOrDefault("title")
  valid_760728 = validateParameter(valid_760728, JString, required = false,
                                 default = nil)
  if valid_760728 != nil:
    section.add "title", valid_760728
  var valid_760729 = formData.getOrDefault("labels")
  valid_760729 = validateParameter(valid_760729, JString, required = false,
                                 default = nil)
  if valid_760729 != nil:
    section.add "labels", valid_760729
  var valid_760730 = formData.getOrDefault("milestone_id")
  valid_760730 = validateParameter(valid_760730, JInt, required = false, default = nil)
  if valid_760730 != nil:
    section.add "milestone_id", valid_760730
  var valid_760731 = formData.getOrDefault("assignee_id")
  valid_760731 = validateParameter(valid_760731, JInt, required = false, default = nil)
  if valid_760731 != nil:
    section.add "assignee_id", valid_760731
  var valid_760732 = formData.getOrDefault("target_branch")
  valid_760732 = validateParameter(valid_760732, JString, required = false,
                                 default = nil)
  if valid_760732 != nil:
    section.add "target_branch", valid_760732
  var valid_760733 = formData.getOrDefault("description")
  valid_760733 = validateParameter(valid_760733, JString, required = false,
                                 default = nil)
  if valid_760733 != nil:
    section.add "description", valid_760733
  var valid_760734 = formData.getOrDefault("state_event")
  valid_760734 = validateParameter(valid_760734, JString, required = false,
                                 default = newJString("close"))
  if valid_760734 != nil:
    section.add "state_event", valid_760734
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760735: Call_PutV3ProjectsIdMergeRequestsMergeRequestId_760722;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a merge request
  ## 
  let valid = call_760735.validator(path, query, header, formData, body)
  let scheme = call_760735.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760735.url(scheme.get, call_760735.host, call_760735.base,
                         call_760735.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760735, url, valid)

proc call*(call_760736: Call_PutV3ProjectsIdMergeRequestsMergeRequestId_760722;
          id: string; mergeRequestId: int; removeSourceBranch: bool = false;
          title: string = ""; labels: string = ""; milestoneId: int = 0;
          assigneeId: int = 0; targetBranch: string = ""; description: string = "";
          stateEvent: string = "close"): Recallable =
  ## putV3ProjectsIdMergeRequestsMergeRequestId
  ## Update a merge request
  ##   removeSourceBranch: bool
  ##                     : Remove source branch when merging
  ##   title: string
  ##        : The title of the merge request
  ##   labels: string
  ##         : Comma-separated list of label names
  ##   id: string (required)
  ##     : The ID of a project
  ##   milestoneId: int
  ##              : The ID of a milestone to assign the merge request
  ##   assigneeId: int
  ##             : The ID of a user to assign the merge request
  ##   targetBranch: string
  ##               : The target branch
  ##   description: string
  ##              : The description of the merge request
  ##   stateEvent: string
  ##             : Status of the merge request
  ##   mergeRequestId: int (required)
  var path_760737 = newJObject()
  var formData_760738 = newJObject()
  add(formData_760738, "remove_source_branch", newJBool(removeSourceBranch))
  add(formData_760738, "title", newJString(title))
  add(formData_760738, "labels", newJString(labels))
  add(path_760737, "id", newJString(id))
  add(formData_760738, "milestone_id", newJInt(milestoneId))
  add(formData_760738, "assignee_id", newJInt(assigneeId))
  add(formData_760738, "target_branch", newJString(targetBranch))
  add(formData_760738, "description", newJString(description))
  add(formData_760738, "state_event", newJString(stateEvent))
  add(path_760737, "merge_request_id", newJInt(mergeRequestId))
  result = call_760736.call(path_760737, nil, nil, formData_760738, nil)

var putV3ProjectsIdMergeRequestsMergeRequestId* = Call_PutV3ProjectsIdMergeRequestsMergeRequestId_760722(
    name: "putV3ProjectsIdMergeRequestsMergeRequestId", meth: HttpMethod.HttpPut,
    host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}",
    validator: validate_PutV3ProjectsIdMergeRequestsMergeRequestId_760723,
    base: "/api", url: url_PutV3ProjectsIdMergeRequestsMergeRequestId_760724,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestId_760714 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestId_760716(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestId_760715(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single merge request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760717 = path.getOrDefault("id")
  valid_760717 = validateParameter(valid_760717, JString, required = true,
                                 default = nil)
  if valid_760717 != nil:
    section.add "id", valid_760717
  var valid_760718 = path.getOrDefault("merge_request_id")
  valid_760718 = validateParameter(valid_760718, JInt, required = true, default = nil)
  if valid_760718 != nil:
    section.add "merge_request_id", valid_760718
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760719: Call_GetV3ProjectsIdMergeRequestsMergeRequestId_760714;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single merge request
  ## 
  let valid = call_760719.validator(path, query, header, formData, body)
  let scheme = call_760719.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760719.url(scheme.get, call_760719.host, call_760719.base,
                         call_760719.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760719, url, valid)

proc call*(call_760720: Call_GetV3ProjectsIdMergeRequestsMergeRequestId_760714;
          id: string; mergeRequestId: int): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestId
  ## Get a single merge request
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  var path_760721 = newJObject()
  add(path_760721, "id", newJString(id))
  add(path_760721, "merge_request_id", newJInt(mergeRequestId))
  result = call_760720.call(path_760721, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestId* = Call_GetV3ProjectsIdMergeRequestsMergeRequestId_760714(
    name: "getV3ProjectsIdMergeRequestsMergeRequestId", meth: HttpMethod.HttpGet,
    host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}",
    validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestId_760715,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsMergeRequestId_760716,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdMergeRequestsMergeRequestId_760739 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdMergeRequestsMergeRequestId_760741(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdMergeRequestsMergeRequestId_760740(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Delete a merge request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  ##                   : The ID of a merge request
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760742 = path.getOrDefault("id")
  valid_760742 = validateParameter(valid_760742, JString, required = true,
                                 default = nil)
  if valid_760742 != nil:
    section.add "id", valid_760742
  var valid_760743 = path.getOrDefault("merge_request_id")
  valid_760743 = validateParameter(valid_760743, JInt, required = true, default = nil)
  if valid_760743 != nil:
    section.add "merge_request_id", valid_760743
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760744: Call_DeleteV3ProjectsIdMergeRequestsMergeRequestId_760739;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a merge request
  ## 
  let valid = call_760744.validator(path, query, header, formData, body)
  let scheme = call_760744.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760744.url(scheme.get, call_760744.host, call_760744.base,
                         call_760744.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760744, url, valid)

proc call*(call_760745: Call_DeleteV3ProjectsIdMergeRequestsMergeRequestId_760739;
          id: string; mergeRequestId: int): Recallable =
  ## deleteV3ProjectsIdMergeRequestsMergeRequestId
  ## Delete a merge request
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  ##                 : The ID of a merge request
  var path_760746 = newJObject()
  add(path_760746, "id", newJString(id))
  add(path_760746, "merge_request_id", newJInt(mergeRequestId))
  result = call_760745.call(path_760746, nil, nil, nil, nil)

var deleteV3ProjectsIdMergeRequestsMergeRequestId* = Call_DeleteV3ProjectsIdMergeRequestsMergeRequestId_760739(
    name: "deleteV3ProjectsIdMergeRequestsMergeRequestId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}",
    validator: validate_DeleteV3ProjectsIdMergeRequestsMergeRequestId_760740,
    base: "/api", url: url_DeleteV3ProjectsIdMergeRequestsMergeRequestId_760741,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime_760747 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime_760749(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/add_spent_time")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime_760748(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Add spent time for a project merge_request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  ##                   : The ID of a project merge_request
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760750 = path.getOrDefault("id")
  valid_760750 = validateParameter(valid_760750, JString, required = true,
                                 default = nil)
  if valid_760750 != nil:
    section.add "id", valid_760750
  var valid_760751 = path.getOrDefault("merge_request_id")
  valid_760751 = validateParameter(valid_760751, JInt, required = true, default = nil)
  if valid_760751 != nil:
    section.add "merge_request_id", valid_760751
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   duration: JString (required)
  ##           : The duration to be parsed
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `duration` field"
  var valid_760752 = formData.getOrDefault("duration")
  valid_760752 = validateParameter(valid_760752, JString, required = true,
                                 default = nil)
  if valid_760752 != nil:
    section.add "duration", valid_760752
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760753: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime_760747;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add spent time for a project merge_request
  ## 
  let valid = call_760753.validator(path, query, header, formData, body)
  let scheme = call_760753.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760753.url(scheme.get, call_760753.host, call_760753.base,
                         call_760753.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760753, url, valid)

proc call*(call_760754: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime_760747;
          id: string; duration: string; mergeRequestId: int): Recallable =
  ## postV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime
  ## Add spent time for a project merge_request
  ##   id: string (required)
  ##     : The ID of a project
  ##   duration: string (required)
  ##           : The duration to be parsed
  ##   mergeRequestId: int (required)
  ##                 : The ID of a project merge_request
  var path_760755 = newJObject()
  var formData_760756 = newJObject()
  add(path_760755, "id", newJString(id))
  add(formData_760756, "duration", newJString(duration))
  add(path_760755, "merge_request_id", newJInt(mergeRequestId))
  result = call_760754.call(path_760755, nil, nil, formData_760756, nil)

var postV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime* = Call_PostV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime_760747(
    name: "postV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/add_spent_time", validator: validate_PostV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime_760748,
    base: "/api",
    url: url_PostV3ProjectsIdMergeRequestsMergeRequestIdAddSpentTime_760749,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760768 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760770(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760769(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760771 = path.getOrDefault("id")
  valid_760771 = validateParameter(valid_760771, JInt, required = true, default = nil)
  if valid_760771 != nil:
    section.add "id", valid_760771
  var valid_760772 = path.getOrDefault("merge_request_id")
  valid_760772 = validateParameter(valid_760772, JInt, required = true, default = nil)
  if valid_760772 != nil:
    section.add "merge_request_id", valid_760772
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   name: JString (required)
  ##       : The name of a award_emoji (without colons)
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `name` field"
  var valid_760773 = formData.getOrDefault("name")
  valid_760773 = validateParameter(valid_760773, JString, required = true,
                                 default = nil)
  if valid_760773 != nil:
    section.add "name", valid_760773
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760774: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760768;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760774.validator(path, query, header, formData, body)
  let scheme = call_760774.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760774.url(scheme.get, call_760774.host, call_760774.base,
                         call_760774.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760774, url, valid)

proc call*(call_760775: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760768;
          id: int; mergeRequestId: int; name: string): Recallable =
  ## postV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   mergeRequestId: int (required)
  ##   name: string (required)
  ##       : The name of a award_emoji (without colons)
  var path_760776 = newJObject()
  var formData_760777 = newJObject()
  add(path_760776, "id", newJInt(id))
  add(path_760776, "merge_request_id", newJInt(mergeRequestId))
  add(formData_760777, "name", newJString(name))
  result = call_760775.call(path_760776, nil, nil, formData_760777, nil)

var postV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji* = Call_PostV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760768(
    name: "postV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/award_emoji",
    validator: validate_PostV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760769,
    base: "/api", url: url_PostV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760770,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760757 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760759(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760758(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  ##                   : The ID of an Issue, Merge Request or Snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760760 = path.getOrDefault("id")
  valid_760760 = validateParameter(valid_760760, JString, required = true,
                                 default = nil)
  if valid_760760 != nil:
    section.add "id", valid_760760
  var valid_760761 = path.getOrDefault("merge_request_id")
  valid_760761 = validateParameter(valid_760761, JInt, required = true, default = nil)
  if valid_760761 != nil:
    section.add "merge_request_id", valid_760761
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760762 = query.getOrDefault("per_page")
  valid_760762 = validateParameter(valid_760762, JInt, required = false, default = nil)
  if valid_760762 != nil:
    section.add "per_page", valid_760762
  var valid_760763 = query.getOrDefault("page")
  valid_760763 = validateParameter(valid_760763, JInt, required = false, default = nil)
  if valid_760763 != nil:
    section.add "page", valid_760763
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760764: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760757;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760764.validator(path, query, header, formData, body)
  let scheme = call_760764.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760764.url(scheme.get, call_760764.host, call_760764.base,
                         call_760764.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760764, url, valid)

proc call*(call_760765: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760757;
          id: string; mergeRequestId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   mergeRequestId: int (required)
  ##                 : The ID of an Issue, Merge Request or Snippet
  var path_760766 = newJObject()
  var query_760767 = newJObject()
  add(path_760766, "id", newJString(id))
  add(query_760767, "per_page", newJInt(perPage))
  add(query_760767, "page", newJInt(page))
  add(path_760766, "merge_request_id", newJInt(mergeRequestId))
  result = call_760765.call(path_760766, query_760767, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760757(
    name: "getV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/award_emoji",
    validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760758,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmoji_760759,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760778 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760780(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760779(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of the award
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760781 = path.getOrDefault("id")
  valid_760781 = validateParameter(valid_760781, JInt, required = true, default = nil)
  if valid_760781 != nil:
    section.add "id", valid_760781
  var valid_760782 = path.getOrDefault("award_id")
  valid_760782 = validateParameter(valid_760782, JInt, required = true, default = nil)
  if valid_760782 != nil:
    section.add "award_id", valid_760782
  var valid_760783 = path.getOrDefault("merge_request_id")
  valid_760783 = validateParameter(valid_760783, JInt, required = true, default = nil)
  if valid_760783 != nil:
    section.add "merge_request_id", valid_760783
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760784: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760778;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760784.validator(path, query, header, formData, body)
  let scheme = call_760784.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760784.url(scheme.get, call_760784.host, call_760784.base,
                         call_760784.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760784, url, valid)

proc call*(call_760785: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760778;
          id: int; awardId: int; mergeRequestId: int): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of the award
  ##   mergeRequestId: int (required)
  var path_760786 = newJObject()
  add(path_760786, "id", newJInt(id))
  add(path_760786, "award_id", newJInt(awardId))
  add(path_760786, "merge_request_id", newJInt(mergeRequestId))
  result = call_760785.call(path_760786, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760778(
    name: "getV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/award_emoji/{award_id}", validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760779,
    base: "/api",
    url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760780,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760787 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760789(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760788(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of an award emoji
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760790 = path.getOrDefault("id")
  valid_760790 = validateParameter(valid_760790, JInt, required = true, default = nil)
  if valid_760790 != nil:
    section.add "id", valid_760790
  var valid_760791 = path.getOrDefault("award_id")
  valid_760791 = validateParameter(valid_760791, JInt, required = true, default = nil)
  if valid_760791 != nil:
    section.add "award_id", valid_760791
  var valid_760792 = path.getOrDefault("merge_request_id")
  valid_760792 = validateParameter(valid_760792, JInt, required = true, default = nil)
  if valid_760792 != nil:
    section.add "merge_request_id", valid_760792
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760793: Call_DeleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760787;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760793.validator(path, query, header, formData, body)
  let scheme = call_760793.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760793.url(scheme.get, call_760793.host, call_760793.base,
                         call_760793.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760793, url, valid)

proc call*(call_760794: Call_DeleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760787;
          id: int; awardId: int; mergeRequestId: int): Recallable =
  ## deleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of an award emoji
  ##   mergeRequestId: int (required)
  var path_760795 = newJObject()
  add(path_760795, "id", newJInt(id))
  add(path_760795, "award_id", newJInt(awardId))
  add(path_760795, "merge_request_id", newJInt(mergeRequestId))
  result = call_760794.call(path_760795, nil, nil, nil, nil)

var deleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId* = Call_DeleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760787(
    name: "deleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/award_emoji/{award_id}", validator: validate_DeleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760788,
    base: "/api",
    url: url_DeleteV3ProjectsIdMergeRequestsMergeRequestIdAwardEmojiAwardId_760789,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds_760796 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds_760798(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"), (
        kind: ConstantSegment, value: "/cancel_merge_when_build_succeeds")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds_760797(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Cancel merge if "Merge When Pipeline Succeeds" is enabled
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760799 = path.getOrDefault("id")
  valid_760799 = validateParameter(valid_760799, JString, required = true,
                                 default = nil)
  if valid_760799 != nil:
    section.add "id", valid_760799
  var valid_760800 = path.getOrDefault("merge_request_id")
  valid_760800 = validateParameter(valid_760800, JInt, required = true, default = nil)
  if valid_760800 != nil:
    section.add "merge_request_id", valid_760800
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760801: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds_760796;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancel merge if "Merge When Pipeline Succeeds" is enabled
  ## 
  let valid = call_760801.validator(path, query, header, formData, body)
  let scheme = call_760801.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760801.url(scheme.get, call_760801.host, call_760801.base,
                         call_760801.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760801, url, valid)

proc call*(call_760802: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds_760796;
          id: string; mergeRequestId: int): Recallable =
  ## postV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds
  ## Cancel merge if "Merge When Pipeline Succeeds" is enabled
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  var path_760803 = newJObject()
  add(path_760803, "id", newJString(id))
  add(path_760803, "merge_request_id", newJInt(mergeRequestId))
  result = call_760802.call(path_760803, nil, nil, nil, nil)

var postV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds* = Call_PostV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds_760796(name: "postV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/cancel_merge_when_build_succeeds", validator: validate_PostV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds_760797,
    base: "/api", url: url_PostV3ProjectsIdMergeRequestsMergeRequestIdCancelMergeWhenBuildSucceeds_760798,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdChanges_760804 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdChanges_760806(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/changes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdChanges_760805(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Show the merge request changes
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760807 = path.getOrDefault("id")
  valid_760807 = validateParameter(valid_760807, JString, required = true,
                                 default = nil)
  if valid_760807 != nil:
    section.add "id", valid_760807
  var valid_760808 = path.getOrDefault("merge_request_id")
  valid_760808 = validateParameter(valid_760808, JInt, required = true, default = nil)
  if valid_760808 != nil:
    section.add "merge_request_id", valid_760808
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760809: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdChanges_760804;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Show the merge request changes
  ## 
  let valid = call_760809.validator(path, query, header, formData, body)
  let scheme = call_760809.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760809.url(scheme.get, call_760809.host, call_760809.base,
                         call_760809.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760809, url, valid)

proc call*(call_760810: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdChanges_760804;
          id: string; mergeRequestId: int): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdChanges
  ## Show the merge request changes
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  var path_760811 = newJObject()
  add(path_760811, "id", newJString(id))
  add(path_760811, "merge_request_id", newJInt(mergeRequestId))
  result = call_760810.call(path_760811, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdChanges* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdChanges_760804(
    name: "getV3ProjectsIdMergeRequestsMergeRequestIdChanges",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/changes",
    validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdChanges_760805,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdChanges_760806,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues_760812 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues_760814(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/closes_issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues_760813(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## List issues that will be closed on merge
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760815 = path.getOrDefault("id")
  valid_760815 = validateParameter(valid_760815, JString, required = true,
                                 default = nil)
  if valid_760815 != nil:
    section.add "id", valid_760815
  var valid_760816 = path.getOrDefault("merge_request_id")
  valid_760816 = validateParameter(valid_760816, JInt, required = true, default = nil)
  if valid_760816 != nil:
    section.add "merge_request_id", valid_760816
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760817 = query.getOrDefault("per_page")
  valid_760817 = validateParameter(valid_760817, JInt, required = false, default = nil)
  if valid_760817 != nil:
    section.add "per_page", valid_760817
  var valid_760818 = query.getOrDefault("page")
  valid_760818 = validateParameter(valid_760818, JInt, required = false, default = nil)
  if valid_760818 != nil:
    section.add "page", valid_760818
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760819: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues_760812;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List issues that will be closed on merge
  ## 
  let valid = call_760819.validator(path, query, header, formData, body)
  let scheme = call_760819.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760819.url(scheme.get, call_760819.host, call_760819.base,
                         call_760819.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760819, url, valid)

proc call*(call_760820: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues_760812;
          id: string; mergeRequestId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues
  ## List issues that will be closed on merge
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   mergeRequestId: int (required)
  var path_760821 = newJObject()
  var query_760822 = newJObject()
  add(path_760821, "id", newJString(id))
  add(query_760822, "per_page", newJInt(perPage))
  add(query_760822, "page", newJInt(page))
  add(path_760821, "merge_request_id", newJInt(mergeRequestId))
  result = call_760820.call(path_760821, query_760822, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues_760812(
    name: "getV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/closes_issues",
    validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues_760813,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdClosesIssues_760814,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsMergeRequestIdComments_760834 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsMergeRequestIdComments_760836(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsMergeRequestIdComments_760835(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760837 = path.getOrDefault("id")
  valid_760837 = validateParameter(valid_760837, JString, required = true,
                                 default = nil)
  if valid_760837 != nil:
    section.add "id", valid_760837
  var valid_760838 = path.getOrDefault("merge_request_id")
  valid_760838 = validateParameter(valid_760838, JInt, required = true, default = nil)
  if valid_760838 != nil:
    section.add "merge_request_id", valid_760838
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   note: JString (required)
  ##       : The text of the comment
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `note` field"
  var valid_760839 = formData.getOrDefault("note")
  valid_760839 = validateParameter(valid_760839, JString, required = true,
                                 default = nil)
  if valid_760839 != nil:
    section.add "note", valid_760839
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760840: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdComments_760834;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ## 
  let valid = call_760840.validator(path, query, header, formData, body)
  let scheme = call_760840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760840.url(scheme.get, call_760840.host, call_760840.base,
                         call_760840.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760840, url, valid)

proc call*(call_760841: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdComments_760834;
          id: string; note: string; mergeRequestId: int): Recallable =
  ## postV3ProjectsIdMergeRequestsMergeRequestIdComments
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ##   id: string (required)
  ##     : The ID of a project
  ##   note: string (required)
  ##       : The text of the comment
  ##   mergeRequestId: int (required)
  var path_760842 = newJObject()
  var formData_760843 = newJObject()
  add(path_760842, "id", newJString(id))
  add(formData_760843, "note", newJString(note))
  add(path_760842, "merge_request_id", newJInt(mergeRequestId))
  result = call_760841.call(path_760842, nil, nil, formData_760843, nil)

var postV3ProjectsIdMergeRequestsMergeRequestIdComments* = Call_PostV3ProjectsIdMergeRequestsMergeRequestIdComments_760834(
    name: "postV3ProjectsIdMergeRequestsMergeRequestIdComments",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/comments",
    validator: validate_PostV3ProjectsIdMergeRequestsMergeRequestIdComments_760835,
    base: "/api", url: url_PostV3ProjectsIdMergeRequestsMergeRequestIdComments_760836,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdComments_760823 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdComments_760825(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdComments_760824(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760826 = path.getOrDefault("id")
  valid_760826 = validateParameter(valid_760826, JString, required = true,
                                 default = nil)
  if valid_760826 != nil:
    section.add "id", valid_760826
  var valid_760827 = path.getOrDefault("merge_request_id")
  valid_760827 = validateParameter(valid_760827, JInt, required = true, default = nil)
  if valid_760827 != nil:
    section.add "merge_request_id", valid_760827
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760828 = query.getOrDefault("per_page")
  valid_760828 = validateParameter(valid_760828, JInt, required = false, default = nil)
  if valid_760828 != nil:
    section.add "per_page", valid_760828
  var valid_760829 = query.getOrDefault("page")
  valid_760829 = validateParameter(valid_760829, JInt, required = false, default = nil)
  if valid_760829 != nil:
    section.add "page", valid_760829
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760830: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdComments_760823;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ## 
  let valid = call_760830.validator(path, query, header, formData, body)
  let scheme = call_760830.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760830.url(scheme.get, call_760830.host, call_760830.base,
                         call_760830.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760830, url, valid)

proc call*(call_760831: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdComments_760823;
          id: string; mergeRequestId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdComments
  ## Duplicate. DEPRECATED and WILL BE REMOVED in 9.0
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   mergeRequestId: int (required)
  var path_760832 = newJObject()
  var query_760833 = newJObject()
  add(path_760832, "id", newJString(id))
  add(query_760833, "per_page", newJInt(perPage))
  add(query_760833, "page", newJInt(page))
  add(path_760832, "merge_request_id", newJInt(mergeRequestId))
  result = call_760831.call(path_760832, query_760833, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdComments* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdComments_760823(
    name: "getV3ProjectsIdMergeRequestsMergeRequestIdComments",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/comments",
    validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdComments_760824,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdComments_760825,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdCommits_760844 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdCommits_760846(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdCommits_760845(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Get the commits of a merge request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760847 = path.getOrDefault("id")
  valid_760847 = validateParameter(valid_760847, JString, required = true,
                                 default = nil)
  if valid_760847 != nil:
    section.add "id", valid_760847
  var valid_760848 = path.getOrDefault("merge_request_id")
  valid_760848 = validateParameter(valid_760848, JInt, required = true, default = nil)
  if valid_760848 != nil:
    section.add "merge_request_id", valid_760848
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760849: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdCommits_760844;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the commits of a merge request
  ## 
  let valid = call_760849.validator(path, query, header, formData, body)
  let scheme = call_760849.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760849.url(scheme.get, call_760849.host, call_760849.base,
                         call_760849.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760849, url, valid)

proc call*(call_760850: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdCommits_760844;
          id: string; mergeRequestId: int): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdCommits
  ## Get the commits of a merge request
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  var path_760851 = newJObject()
  add(path_760851, "id", newJString(id))
  add(path_760851, "merge_request_id", newJInt(mergeRequestId))
  result = call_760850.call(path_760851, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdCommits* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdCommits_760844(
    name: "getV3ProjectsIdMergeRequestsMergeRequestIdCommits",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/commits",
    validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdCommits_760845,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdCommits_760846,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdMergeRequestsMergeRequestIdMerge_760852 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdMergeRequestsMergeRequestIdMerge_760854(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdMergeRequestsMergeRequestIdMerge_760853(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Merge a merge request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760855 = path.getOrDefault("id")
  valid_760855 = validateParameter(valid_760855, JString, required = true,
                                 default = nil)
  if valid_760855 != nil:
    section.add "id", valid_760855
  var valid_760856 = path.getOrDefault("merge_request_id")
  valid_760856 = validateParameter(valid_760856, JInt, required = true, default = nil)
  if valid_760856 != nil:
    section.add "merge_request_id", valid_760856
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   merge_commit_message: JString
  ##                       : Custom merge commit message
  ##   sha: JString
  ##      : When present, must have the HEAD SHA of the source branch
  ##   merge_when_build_succeeds: JBool
  ##                            : When true, this merge request will be merged when the pipeline succeeds
  ##   should_remove_source_branch: JBool
  ##                              : When true, the source branch will be deleted if possible
  section = newJObject()
  var valid_760857 = formData.getOrDefault("merge_commit_message")
  valid_760857 = validateParameter(valid_760857, JString, required = false,
                                 default = nil)
  if valid_760857 != nil:
    section.add "merge_commit_message", valid_760857
  var valid_760858 = formData.getOrDefault("sha")
  valid_760858 = validateParameter(valid_760858, JString, required = false,
                                 default = nil)
  if valid_760858 != nil:
    section.add "sha", valid_760858
  var valid_760859 = formData.getOrDefault("merge_when_build_succeeds")
  valid_760859 = validateParameter(valid_760859, JBool, required = false, default = nil)
  if valid_760859 != nil:
    section.add "merge_when_build_succeeds", valid_760859
  var valid_760860 = formData.getOrDefault("should_remove_source_branch")
  valid_760860 = validateParameter(valid_760860, JBool, required = false, default = nil)
  if valid_760860 != nil:
    section.add "should_remove_source_branch", valid_760860
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760861: Call_PutV3ProjectsIdMergeRequestsMergeRequestIdMerge_760852;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Merge a merge request
  ## 
  let valid = call_760861.validator(path, query, header, formData, body)
  let scheme = call_760861.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760861.url(scheme.get, call_760861.host, call_760861.base,
                         call_760861.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760861, url, valid)

proc call*(call_760862: Call_PutV3ProjectsIdMergeRequestsMergeRequestIdMerge_760852;
          id: string; mergeRequestId: int; mergeCommitMessage: string = "";
          sha: string = ""; mergeWhenBuildSucceeds: bool = false;
          shouldRemoveSourceBranch: bool = false): Recallable =
  ## putV3ProjectsIdMergeRequestsMergeRequestIdMerge
  ## Merge a merge request
  ##   mergeCommitMessage: string
  ##                     : Custom merge commit message
  ##   sha: string
  ##      : When present, must have the HEAD SHA of the source branch
  ##   mergeWhenBuildSucceeds: bool
  ##                         : When true, this merge request will be merged when the pipeline succeeds
  ##   id: string (required)
  ##     : The ID of a project
  ##   shouldRemoveSourceBranch: bool
  ##                           : When true, the source branch will be deleted if possible
  ##   mergeRequestId: int (required)
  var path_760863 = newJObject()
  var formData_760864 = newJObject()
  add(formData_760864, "merge_commit_message", newJString(mergeCommitMessage))
  add(formData_760864, "sha", newJString(sha))
  add(formData_760864, "merge_when_build_succeeds",
      newJBool(mergeWhenBuildSucceeds))
  add(path_760863, "id", newJString(id))
  add(formData_760864, "should_remove_source_branch",
      newJBool(shouldRemoveSourceBranch))
  add(path_760863, "merge_request_id", newJInt(mergeRequestId))
  result = call_760862.call(path_760863, nil, nil, formData_760864, nil)

var putV3ProjectsIdMergeRequestsMergeRequestIdMerge* = Call_PutV3ProjectsIdMergeRequestsMergeRequestIdMerge_760852(
    name: "putV3ProjectsIdMergeRequestsMergeRequestIdMerge",
    meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/merge",
    validator: validate_PutV3ProjectsIdMergeRequestsMergeRequestIdMerge_760853,
    base: "/api", url: url_PutV3ProjectsIdMergeRequestsMergeRequestIdMerge_760854,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760877 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760879(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760878(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   merge_request_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760880 = path.getOrDefault("id")
  valid_760880 = validateParameter(valid_760880, JInt, required = true, default = nil)
  if valid_760880 != nil:
    section.add "id", valid_760880
  var valid_760881 = path.getOrDefault("merge_request_id")
  valid_760881 = validateParameter(valid_760881, JInt, required = true, default = nil)
  if valid_760881 != nil:
    section.add "merge_request_id", valid_760881
  var valid_760882 = path.getOrDefault("note_id")
  valid_760882 = validateParameter(valid_760882, JInt, required = true, default = nil)
  if valid_760882 != nil:
    section.add "note_id", valid_760882
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   name: JString (required)
  ##       : The name of a award_emoji (without colons)
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `name` field"
  var valid_760883 = formData.getOrDefault("name")
  valid_760883 = validateParameter(valid_760883, JString, required = true,
                                 default = nil)
  if valid_760883 != nil:
    section.add "name", valid_760883
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760884: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760877;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760884.validator(path, query, header, formData, body)
  let scheme = call_760884.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760884.url(scheme.get, call_760884.host, call_760884.base,
                         call_760884.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760884, url, valid)

proc call*(call_760885: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760877;
          id: int; mergeRequestId: int; noteId: int; name: string): Recallable =
  ## postV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   mergeRequestId: int (required)
  ##   noteId: int (required)
  ##   name: string (required)
  ##       : The name of a award_emoji (without colons)
  var path_760886 = newJObject()
  var formData_760887 = newJObject()
  add(path_760886, "id", newJInt(id))
  add(path_760886, "merge_request_id", newJInt(mergeRequestId))
  add(path_760886, "note_id", newJInt(noteId))
  add(formData_760887, "name", newJString(name))
  result = call_760885.call(path_760886, nil, nil, formData_760887, nil)

var postV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji* = Call_PostV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760877(
    name: "postV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/notes/{note_id}/award_emoji", validator: validate_PostV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760878,
    base: "/api",
    url: url_PostV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760879,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760865 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760867(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760866(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   merge_request_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760868 = path.getOrDefault("id")
  valid_760868 = validateParameter(valid_760868, JInt, required = true, default = nil)
  if valid_760868 != nil:
    section.add "id", valid_760868
  var valid_760869 = path.getOrDefault("merge_request_id")
  valid_760869 = validateParameter(valid_760869, JInt, required = true, default = nil)
  if valid_760869 != nil:
    section.add "merge_request_id", valid_760869
  var valid_760870 = path.getOrDefault("note_id")
  valid_760870 = validateParameter(valid_760870, JInt, required = true, default = nil)
  if valid_760870 != nil:
    section.add "note_id", valid_760870
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760871 = query.getOrDefault("per_page")
  valid_760871 = validateParameter(valid_760871, JInt, required = false, default = nil)
  if valid_760871 != nil:
    section.add "per_page", valid_760871
  var valid_760872 = query.getOrDefault("page")
  valid_760872 = validateParameter(valid_760872, JInt, required = false, default = nil)
  if valid_760872 != nil:
    section.add "page", valid_760872
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760873: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760865;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760873.validator(path, query, header, formData, body)
  let scheme = call_760873.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760873.url(scheme.get, call_760873.host, call_760873.base,
                         call_760873.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760873, url, valid)

proc call*(call_760874: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760865;
          id: int; mergeRequestId: int; noteId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   mergeRequestId: int (required)
  ##   noteId: int (required)
  var path_760875 = newJObject()
  var query_760876 = newJObject()
  add(path_760875, "id", newJInt(id))
  add(query_760876, "per_page", newJInt(perPage))
  add(query_760876, "page", newJInt(page))
  add(path_760875, "merge_request_id", newJInt(mergeRequestId))
  add(path_760875, "note_id", newJInt(noteId))
  result = call_760874.call(path_760875, query_760876, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760865(
    name: "getV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/notes/{note_id}/award_emoji", validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760866,
    base: "/api",
    url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmoji_760867,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760888 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760890(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760889(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of the award
  ##   merge_request_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760891 = path.getOrDefault("id")
  valid_760891 = validateParameter(valid_760891, JInt, required = true, default = nil)
  if valid_760891 != nil:
    section.add "id", valid_760891
  var valid_760892 = path.getOrDefault("award_id")
  valid_760892 = validateParameter(valid_760892, JInt, required = true, default = nil)
  if valid_760892 != nil:
    section.add "award_id", valid_760892
  var valid_760893 = path.getOrDefault("merge_request_id")
  valid_760893 = validateParameter(valid_760893, JInt, required = true, default = nil)
  if valid_760893 != nil:
    section.add "merge_request_id", valid_760893
  var valid_760894 = path.getOrDefault("note_id")
  valid_760894 = validateParameter(valid_760894, JInt, required = true, default = nil)
  if valid_760894 != nil:
    section.add "note_id", valid_760894
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760895: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760888;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760895.validator(path, query, header, formData, body)
  let scheme = call_760895.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760895.url(scheme.get, call_760895.host, call_760895.base,
                         call_760895.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760895, url, valid)

proc call*(call_760896: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760888;
          id: int; awardId: int; mergeRequestId: int; noteId: int): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of the award
  ##   mergeRequestId: int (required)
  ##   noteId: int (required)
  var path_760897 = newJObject()
  add(path_760897, "id", newJInt(id))
  add(path_760897, "award_id", newJInt(awardId))
  add(path_760897, "merge_request_id", newJInt(mergeRequestId))
  add(path_760897, "note_id", newJInt(noteId))
  result = call_760896.call(path_760897, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760888(name: "getV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/notes/{note_id}/award_emoji/{award_id}", validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760889,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760890,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760898 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760900(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760899(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of an award emoji
  ##   merge_request_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760901 = path.getOrDefault("id")
  valid_760901 = validateParameter(valid_760901, JInt, required = true, default = nil)
  if valid_760901 != nil:
    section.add "id", valid_760901
  var valid_760902 = path.getOrDefault("award_id")
  valid_760902 = validateParameter(valid_760902, JInt, required = true, default = nil)
  if valid_760902 != nil:
    section.add "award_id", valid_760902
  var valid_760903 = path.getOrDefault("merge_request_id")
  valid_760903 = validateParameter(valid_760903, JInt, required = true, default = nil)
  if valid_760903 != nil:
    section.add "merge_request_id", valid_760903
  var valid_760904 = path.getOrDefault("note_id")
  valid_760904 = validateParameter(valid_760904, JInt, required = true, default = nil)
  if valid_760904 != nil:
    section.add "note_id", valid_760904
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760905: Call_DeleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760898;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_760905.validator(path, query, header, formData, body)
  let scheme = call_760905.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760905.url(scheme.get, call_760905.host, call_760905.base,
                         call_760905.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760905, url, valid)

proc call*(call_760906: Call_DeleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760898;
          id: int; awardId: int; mergeRequestId: int; noteId: int): Recallable =
  ## deleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of an award emoji
  ##   mergeRequestId: int (required)
  ##   noteId: int (required)
  var path_760907 = newJObject()
  add(path_760907, "id", newJInt(id))
  add(path_760907, "award_id", newJInt(awardId))
  add(path_760907, "merge_request_id", newJInt(mergeRequestId))
  add(path_760907, "note_id", newJInt(noteId))
  result = call_760906.call(path_760907, nil, nil, nil, nil)

var deleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId* = Call_DeleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760898(name: "deleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/notes/{note_id}/award_emoji/{award_id}", validator: validate_DeleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760899,
    base: "/api", url: url_DeleteV3ProjectsIdMergeRequestsMergeRequestIdNotesNoteIdAwardEmojiAwardId_760900,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime_760908 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime_760910(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/reset_spent_time")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime_760909(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Reset spent time for a project merge_request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  ##                   : The ID of a project merge_request
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760911 = path.getOrDefault("id")
  valid_760911 = validateParameter(valid_760911, JString, required = true,
                                 default = nil)
  if valid_760911 != nil:
    section.add "id", valid_760911
  var valid_760912 = path.getOrDefault("merge_request_id")
  valid_760912 = validateParameter(valid_760912, JInt, required = true, default = nil)
  if valid_760912 != nil:
    section.add "merge_request_id", valid_760912
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760913: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime_760908;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Reset spent time for a project merge_request
  ## 
  let valid = call_760913.validator(path, query, header, formData, body)
  let scheme = call_760913.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760913.url(scheme.get, call_760913.host, call_760913.base,
                         call_760913.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760913, url, valid)

proc call*(call_760914: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime_760908;
          id: string; mergeRequestId: int): Recallable =
  ## postV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime
  ## Reset spent time for a project merge_request
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  ##                 : The ID of a project merge_request
  var path_760915 = newJObject()
  add(path_760915, "id", newJString(id))
  add(path_760915, "merge_request_id", newJInt(mergeRequestId))
  result = call_760914.call(path_760915, nil, nil, nil, nil)

var postV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime* = Call_PostV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime_760908(
    name: "postV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/reset_spent_time", validator: validate_PostV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime_760909,
    base: "/api",
    url: url_PostV3ProjectsIdMergeRequestsMergeRequestIdResetSpentTime_760910,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate_760916 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate_760918(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/reset_time_estimate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate_760917(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Reset the time estimate for a project merge_request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  ##                   : The ID of a project merge_request
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760919 = path.getOrDefault("id")
  valid_760919 = validateParameter(valid_760919, JString, required = true,
                                 default = nil)
  if valid_760919 != nil:
    section.add "id", valid_760919
  var valid_760920 = path.getOrDefault("merge_request_id")
  valid_760920 = validateParameter(valid_760920, JInt, required = true, default = nil)
  if valid_760920 != nil:
    section.add "merge_request_id", valid_760920
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760921: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate_760916;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Reset the time estimate for a project merge_request
  ## 
  let valid = call_760921.validator(path, query, header, formData, body)
  let scheme = call_760921.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760921.url(scheme.get, call_760921.host, call_760921.base,
                         call_760921.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760921, url, valid)

proc call*(call_760922: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate_760916;
          id: string; mergeRequestId: int): Recallable =
  ## postV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate
  ## Reset the time estimate for a project merge_request
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  ##                 : The ID of a project merge_request
  var path_760923 = newJObject()
  add(path_760923, "id", newJString(id))
  add(path_760923, "merge_request_id", newJInt(mergeRequestId))
  result = call_760922.call(path_760923, nil, nil, nil, nil)

var postV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate* = Call_PostV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate_760916(
    name: "postV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/reset_time_estimate", validator: validate_PostV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate_760917,
    base: "/api",
    url: url_PostV3ProjectsIdMergeRequestsMergeRequestIdResetTimeEstimate_760918,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate_760924 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate_760926(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/time_estimate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate_760925(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Set a time estimate for a project merge_request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  ##                   : The ID of a project merge_request
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760927 = path.getOrDefault("id")
  valid_760927 = validateParameter(valid_760927, JString, required = true,
                                 default = nil)
  if valid_760927 != nil:
    section.add "id", valid_760927
  var valid_760928 = path.getOrDefault("merge_request_id")
  valid_760928 = validateParameter(valid_760928, JInt, required = true, default = nil)
  if valid_760928 != nil:
    section.add "merge_request_id", valid_760928
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   duration: JString (required)
  ##           : The duration to be parsed
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `duration` field"
  var valid_760929 = formData.getOrDefault("duration")
  valid_760929 = validateParameter(valid_760929, JString, required = true,
                                 default = nil)
  if valid_760929 != nil:
    section.add "duration", valid_760929
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760930: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate_760924;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set a time estimate for a project merge_request
  ## 
  let valid = call_760930.validator(path, query, header, formData, body)
  let scheme = call_760930.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760930.url(scheme.get, call_760930.host, call_760930.base,
                         call_760930.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760930, url, valid)

proc call*(call_760931: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate_760924;
          id: string; duration: string; mergeRequestId: int): Recallable =
  ## postV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate
  ## Set a time estimate for a project merge_request
  ##   id: string (required)
  ##     : The ID of a project
  ##   duration: string (required)
  ##           : The duration to be parsed
  ##   mergeRequestId: int (required)
  ##                 : The ID of a project merge_request
  var path_760932 = newJObject()
  var formData_760933 = newJObject()
  add(path_760932, "id", newJString(id))
  add(formData_760933, "duration", newJString(duration))
  add(path_760932, "merge_request_id", newJInt(mergeRequestId))
  result = call_760931.call(path_760932, nil, nil, formData_760933, nil)

var postV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate* = Call_PostV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate_760924(
    name: "postV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/time_estimate", validator: validate_PostV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate_760925,
    base: "/api",
    url: url_PostV3ProjectsIdMergeRequestsMergeRequestIdTimeEstimate_760926,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdTimeStats_760934 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdTimeStats_760936(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/time_stats")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdTimeStats_760935(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Show time stats for a project merge_request
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  ##                   : The ID of a project merge_request
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760937 = path.getOrDefault("id")
  valid_760937 = validateParameter(valid_760937, JString, required = true,
                                 default = nil)
  if valid_760937 != nil:
    section.add "id", valid_760937
  var valid_760938 = path.getOrDefault("merge_request_id")
  valid_760938 = validateParameter(valid_760938, JInt, required = true, default = nil)
  if valid_760938 != nil:
    section.add "merge_request_id", valid_760938
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760939: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdTimeStats_760934;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Show time stats for a project merge_request
  ## 
  let valid = call_760939.validator(path, query, header, formData, body)
  let scheme = call_760939.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760939.url(scheme.get, call_760939.host, call_760939.base,
                         call_760939.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760939, url, valid)

proc call*(call_760940: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdTimeStats_760934;
          id: string; mergeRequestId: int): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdTimeStats
  ## Show time stats for a project merge_request
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  ##                 : The ID of a project merge_request
  var path_760941 = newJObject()
  add(path_760941, "id", newJString(id))
  add(path_760941, "merge_request_id", newJInt(mergeRequestId))
  result = call_760940.call(path_760941, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdTimeStats* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdTimeStats_760934(
    name: "getV3ProjectsIdMergeRequestsMergeRequestIdTimeStats",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/time_stats",
    validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdTimeStats_760935,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdTimeStats_760936,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsMergeRequestIdTodo_760942 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsMergeRequestIdTodo_760944(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/todo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsMergeRequestIdTodo_760943(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Create a todo on an issuable
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  ##                   : The ID of an issuable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760945 = path.getOrDefault("id")
  valid_760945 = validateParameter(valid_760945, JString, required = true,
                                 default = nil)
  if valid_760945 != nil:
    section.add "id", valid_760945
  var valid_760946 = path.getOrDefault("merge_request_id")
  valid_760946 = validateParameter(valid_760946, JInt, required = true, default = nil)
  if valid_760946 != nil:
    section.add "merge_request_id", valid_760946
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760947: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdTodo_760942;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a todo on an issuable
  ## 
  let valid = call_760947.validator(path, query, header, formData, body)
  let scheme = call_760947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760947.url(scheme.get, call_760947.host, call_760947.base,
                         call_760947.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760947, url, valid)

proc call*(call_760948: Call_PostV3ProjectsIdMergeRequestsMergeRequestIdTodo_760942;
          id: string; mergeRequestId: int): Recallable =
  ## postV3ProjectsIdMergeRequestsMergeRequestIdTodo
  ## Create a todo on an issuable
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  ##                 : The ID of an issuable
  var path_760949 = newJObject()
  add(path_760949, "id", newJString(id))
  add(path_760949, "merge_request_id", newJInt(mergeRequestId))
  result = call_760948.call(path_760949, nil, nil, nil, nil)

var postV3ProjectsIdMergeRequestsMergeRequestIdTodo* = Call_PostV3ProjectsIdMergeRequestsMergeRequestIdTodo_760942(
    name: "postV3ProjectsIdMergeRequestsMergeRequestIdTodo",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/todo",
    validator: validate_PostV3ProjectsIdMergeRequestsMergeRequestIdTodo_760943,
    base: "/api", url: url_PostV3ProjectsIdMergeRequestsMergeRequestIdTodo_760944,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdVersions_760950 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdVersions_760952(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/versions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdVersions_760951(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.12.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   merge_request_id: JInt (required)
  ##                   : The ID of a merge request
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760953 = path.getOrDefault("id")
  valid_760953 = validateParameter(valid_760953, JString, required = true,
                                 default = nil)
  if valid_760953 != nil:
    section.add "id", valid_760953
  var valid_760954 = path.getOrDefault("merge_request_id")
  valid_760954 = validateParameter(valid_760954, JInt, required = true, default = nil)
  if valid_760954 != nil:
    section.add "merge_request_id", valid_760954
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760955: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdVersions_760950;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.12.
  ## 
  let valid = call_760955.validator(path, query, header, formData, body)
  let scheme = call_760955.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760955.url(scheme.get, call_760955.host, call_760955.base,
                         call_760955.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760955, url, valid)

proc call*(call_760956: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdVersions_760950;
          id: string; mergeRequestId: int): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdVersions
  ## This feature was introduced in GitLab 8.12.
  ##   id: string (required)
  ##     : The ID of a project
  ##   mergeRequestId: int (required)
  ##                 : The ID of a merge request
  var path_760957 = newJObject()
  add(path_760957, "id", newJString(id))
  add(path_760957, "merge_request_id", newJInt(mergeRequestId))
  result = call_760956.call(path_760957, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdVersions* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdVersions_760950(
    name: "getV3ProjectsIdMergeRequestsMergeRequestIdVersions",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{merge_request_id}/versions",
    validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdVersions_760951,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdVersions_760952,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId_760958 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId_760960(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "merge_request_id" in path,
        "`merge_request_id` is a required path parameter"
  assert "version_id" in path, "`version_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "merge_request_id"),
               (kind: ConstantSegment, value: "/versions/"),
               (kind: VariableSegment, value: "version_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId_760959(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.12.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   version_id: JInt (required)
  ##             : The ID of a merge request diff version
  ##   merge_request_id: JInt (required)
  ##                   : The ID of a merge request
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760961 = path.getOrDefault("id")
  valid_760961 = validateParameter(valid_760961, JString, required = true,
                                 default = nil)
  if valid_760961 != nil:
    section.add "id", valid_760961
  var valid_760962 = path.getOrDefault("version_id")
  valid_760962 = validateParameter(valid_760962, JInt, required = true, default = nil)
  if valid_760962 != nil:
    section.add "version_id", valid_760962
  var valid_760963 = path.getOrDefault("merge_request_id")
  valid_760963 = validateParameter(valid_760963, JInt, required = true, default = nil)
  if valid_760963 != nil:
    section.add "merge_request_id", valid_760963
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760964: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId_760958;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.12.
  ## 
  let valid = call_760964.validator(path, query, header, formData, body)
  let scheme = call_760964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760964.url(scheme.get, call_760964.host, call_760964.base,
                         call_760964.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760964, url, valid)

proc call*(call_760965: Call_GetV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId_760958;
          id: string; versionId: int; mergeRequestId: int): Recallable =
  ## getV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId
  ## This feature was introduced in GitLab 8.12.
  ##   id: string (required)
  ##     : The ID of a project
  ##   versionId: int (required)
  ##            : The ID of a merge request diff version
  ##   mergeRequestId: int (required)
  ##                 : The ID of a merge request
  var path_760966 = newJObject()
  add(path_760966, "id", newJString(id))
  add(path_760966, "version_id", newJInt(versionId))
  add(path_760966, "merge_request_id", newJInt(mergeRequestId))
  result = call_760965.call(path_760966, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId* = Call_GetV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId_760958(
    name: "getV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/projects/{id}/merge_requests/{merge_request_id}/versions/{version_id}", validator: validate_GetV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId_760959,
    base: "/api",
    url: url_GetV3ProjectsIdMergeRequestsMergeRequestIdVersionsVersionId_760960,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsNoteableIdNotes_760978 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsNoteableIdNotes_760980(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsNoteableIdNotes_760979(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760981 = path.getOrDefault("id")
  valid_760981 = validateParameter(valid_760981, JString, required = true,
                                 default = nil)
  if valid_760981 != nil:
    section.add "id", valid_760981
  var valid_760982 = path.getOrDefault("noteable_id")
  valid_760982 = validateParameter(valid_760982, JInt, required = true, default = nil)
  if valid_760982 != nil:
    section.add "noteable_id", valid_760982
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   created_at: JString
  ##             : The creation date of the note
  ##   body: JString (required)
  ##       : The content of a note
  section = newJObject()
  var valid_760983 = formData.getOrDefault("created_at")
  valid_760983 = validateParameter(valid_760983, JString, required = false,
                                 default = nil)
  if valid_760983 != nil:
    section.add "created_at", valid_760983
  assert formData != nil,
        "formData argument is necessary due to required `body` field"
  var valid_760984 = formData.getOrDefault("body")
  valid_760984 = validateParameter(valid_760984, JString, required = true,
                                 default = nil)
  if valid_760984 != nil:
    section.add "body", valid_760984
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760985: Call_PostV3ProjectsIdMergeRequestsNoteableIdNotes_760978;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a new +noteable+ note
  ## 
  let valid = call_760985.validator(path, query, header, formData, body)
  let scheme = call_760985.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760985.url(scheme.get, call_760985.host, call_760985.base,
                         call_760985.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760985, url, valid)

proc call*(call_760986: Call_PostV3ProjectsIdMergeRequestsNoteableIdNotes_760978;
          id: string; body: string; noteableId: int; createdAt: string = ""): Recallable =
  ## postV3ProjectsIdMergeRequestsNoteableIdNotes
  ## Create a new +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   createdAt: string
  ##            : The creation date of the note
  ##   body: string (required)
  ##       : The content of a note
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  var path_760987 = newJObject()
  var formData_760988 = newJObject()
  add(path_760987, "id", newJString(id))
  add(formData_760988, "created_at", newJString(createdAt))
  add(formData_760988, "body", newJString(body))
  add(path_760987, "noteable_id", newJInt(noteableId))
  result = call_760986.call(path_760987, nil, nil, formData_760988, nil)

var postV3ProjectsIdMergeRequestsNoteableIdNotes* = Call_PostV3ProjectsIdMergeRequestsNoteableIdNotes_760978(
    name: "postV3ProjectsIdMergeRequestsNoteableIdNotes",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{noteable_id}/notes",
    validator: validate_PostV3ProjectsIdMergeRequestsNoteableIdNotes_760979,
    base: "/api", url: url_PostV3ProjectsIdMergeRequestsNoteableIdNotes_760980,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsNoteableIdNotes_760967 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsNoteableIdNotes_760969(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsNoteableIdNotes_760968(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a list of project +noteable+ notes
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760970 = path.getOrDefault("id")
  valid_760970 = validateParameter(valid_760970, JString, required = true,
                                 default = nil)
  if valid_760970 != nil:
    section.add "id", valid_760970
  var valid_760971 = path.getOrDefault("noteable_id")
  valid_760971 = validateParameter(valid_760971, JInt, required = true, default = nil)
  if valid_760971 != nil:
    section.add "noteable_id", valid_760971
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_760972 = query.getOrDefault("per_page")
  valid_760972 = validateParameter(valid_760972, JInt, required = false, default = nil)
  if valid_760972 != nil:
    section.add "per_page", valid_760972
  var valid_760973 = query.getOrDefault("page")
  valid_760973 = validateParameter(valid_760973, JInt, required = false, default = nil)
  if valid_760973 != nil:
    section.add "page", valid_760973
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760974: Call_GetV3ProjectsIdMergeRequestsNoteableIdNotes_760967;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a list of project +noteable+ notes
  ## 
  let valid = call_760974.validator(path, query, header, formData, body)
  let scheme = call_760974.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760974.url(scheme.get, call_760974.host, call_760974.base,
                         call_760974.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760974, url, valid)

proc call*(call_760975: Call_GetV3ProjectsIdMergeRequestsNoteableIdNotes_760967;
          id: string; noteableId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdMergeRequestsNoteableIdNotes
  ## Get a list of project +noteable+ notes
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  var path_760976 = newJObject()
  var query_760977 = newJObject()
  add(path_760976, "id", newJString(id))
  add(query_760977, "per_page", newJInt(perPage))
  add(query_760977, "page", newJInt(page))
  add(path_760976, "noteable_id", newJInt(noteableId))
  result = call_760975.call(path_760976, query_760977, nil, nil, nil)

var getV3ProjectsIdMergeRequestsNoteableIdNotes* = Call_GetV3ProjectsIdMergeRequestsNoteableIdNotes_760967(
    name: "getV3ProjectsIdMergeRequestsNoteableIdNotes", meth: HttpMethod.HttpGet,
    host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{noteable_id}/notes",
    validator: validate_GetV3ProjectsIdMergeRequestsNoteableIdNotes_760968,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsNoteableIdNotes_760969,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760998 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_761000(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760999(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Update an existing +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  ##   note_id: JInt (required)
  ##          : The ID of a note
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761001 = path.getOrDefault("id")
  valid_761001 = validateParameter(valid_761001, JString, required = true,
                                 default = nil)
  if valid_761001 != nil:
    section.add "id", valid_761001
  var valid_761002 = path.getOrDefault("noteable_id")
  valid_761002 = validateParameter(valid_761002, JInt, required = true, default = nil)
  if valid_761002 != nil:
    section.add "noteable_id", valid_761002
  var valid_761003 = path.getOrDefault("note_id")
  valid_761003 = validateParameter(valid_761003, JInt, required = true, default = nil)
  if valid_761003 != nil:
    section.add "note_id", valid_761003
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   body: JString (required)
  ##       : The content of a note
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `body` field"
  var valid_761004 = formData.getOrDefault("body")
  valid_761004 = validateParameter(valid_761004, JString, required = true,
                                 default = nil)
  if valid_761004 != nil:
    section.add "body", valid_761004
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761005: Call_PutV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760998;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update an existing +noteable+ note
  ## 
  let valid = call_761005.validator(path, query, header, formData, body)
  let scheme = call_761005.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761005.url(scheme.get, call_761005.host, call_761005.base,
                         call_761005.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761005, url, valid)

proc call*(call_761006: Call_PutV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760998;
          id: string; body: string; noteableId: int; noteId: int): Recallable =
  ## putV3ProjectsIdMergeRequestsNoteableIdNotesNoteId
  ## Update an existing +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   body: string (required)
  ##       : The content of a note
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  ##   noteId: int (required)
  ##         : The ID of a note
  var path_761007 = newJObject()
  var formData_761008 = newJObject()
  add(path_761007, "id", newJString(id))
  add(formData_761008, "body", newJString(body))
  add(path_761007, "noteable_id", newJInt(noteableId))
  add(path_761007, "note_id", newJInt(noteId))
  result = call_761006.call(path_761007, nil, nil, formData_761008, nil)

var putV3ProjectsIdMergeRequestsNoteableIdNotesNoteId* = Call_PutV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760998(
    name: "putV3ProjectsIdMergeRequestsNoteableIdNotesNoteId",
    meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{noteable_id}/notes/{note_id}",
    validator: validate_PutV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760999,
    base: "/api", url: url_PutV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_761000,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760989 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760991(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760990(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Get a single +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  ##   note_id: JInt (required)
  ##          : The ID of a note
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_760992 = path.getOrDefault("id")
  valid_760992 = validateParameter(valid_760992, JString, required = true,
                                 default = nil)
  if valid_760992 != nil:
    section.add "id", valid_760992
  var valid_760993 = path.getOrDefault("noteable_id")
  valid_760993 = validateParameter(valid_760993, JInt, required = true, default = nil)
  if valid_760993 != nil:
    section.add "noteable_id", valid_760993
  var valid_760994 = path.getOrDefault("note_id")
  valid_760994 = validateParameter(valid_760994, JInt, required = true, default = nil)
  if valid_760994 != nil:
    section.add "note_id", valid_760994
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_760995: Call_GetV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760989;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single +noteable+ note
  ## 
  let valid = call_760995.validator(path, query, header, formData, body)
  let scheme = call_760995.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_760995.url(scheme.get, call_760995.host, call_760995.base,
                         call_760995.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_760995, url, valid)

proc call*(call_760996: Call_GetV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760989;
          id: string; noteableId: int; noteId: int): Recallable =
  ## getV3ProjectsIdMergeRequestsNoteableIdNotesNoteId
  ## Get a single +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  ##   noteId: int (required)
  ##         : The ID of a note
  var path_760997 = newJObject()
  add(path_760997, "id", newJString(id))
  add(path_760997, "noteable_id", newJInt(noteableId))
  add(path_760997, "note_id", newJInt(noteId))
  result = call_760996.call(path_760997, nil, nil, nil, nil)

var getV3ProjectsIdMergeRequestsNoteableIdNotesNoteId* = Call_GetV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760989(
    name: "getV3ProjectsIdMergeRequestsNoteableIdNotesNoteId",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{noteable_id}/notes/{note_id}",
    validator: validate_GetV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760990,
    base: "/api", url: url_GetV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_760991,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_761009 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_761011(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_761010(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Delete a +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  ##   note_id: JInt (required)
  ##          : The ID of a note
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761012 = path.getOrDefault("id")
  valid_761012 = validateParameter(valid_761012, JString, required = true,
                                 default = nil)
  if valid_761012 != nil:
    section.add "id", valid_761012
  var valid_761013 = path.getOrDefault("noteable_id")
  valid_761013 = validateParameter(valid_761013, JInt, required = true, default = nil)
  if valid_761013 != nil:
    section.add "noteable_id", valid_761013
  var valid_761014 = path.getOrDefault("note_id")
  valid_761014 = validateParameter(valid_761014, JInt, required = true, default = nil)
  if valid_761014 != nil:
    section.add "note_id", valid_761014
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761015: Call_DeleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_761009;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a +noteable+ note
  ## 
  let valid = call_761015.validator(path, query, header, formData, body)
  let scheme = call_761015.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761015.url(scheme.get, call_761015.host, call_761015.base,
                         call_761015.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761015, url, valid)

proc call*(call_761016: Call_DeleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_761009;
          id: string; noteableId: int; noteId: int): Recallable =
  ## deleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId
  ## Delete a +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  ##   noteId: int (required)
  ##         : The ID of a note
  var path_761017 = newJObject()
  add(path_761017, "id", newJString(id))
  add(path_761017, "noteable_id", newJInt(noteableId))
  add(path_761017, "note_id", newJInt(noteId))
  result = call_761016.call(path_761017, nil, nil, nil, nil)

var deleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId* = Call_DeleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_761009(
    name: "deleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{noteable_id}/notes/{note_id}",
    validator: validate_DeleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_761010,
    base: "/api", url: url_DeleteV3ProjectsIdMergeRequestsNoteableIdNotesNoteId_761011,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMergeRequestsSubscribableIdSubscription_761018 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMergeRequestsSubscribableIdSubscription_761020(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "subscribable_id" in path, "`subscribable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "subscribable_id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMergeRequestsSubscribableIdSubscription_761019(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Subscribe to a resource
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   subscribable_id: JString (required)
  ##                  : The ID of a resource
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761021 = path.getOrDefault("id")
  valid_761021 = validateParameter(valid_761021, JString, required = true,
                                 default = nil)
  if valid_761021 != nil:
    section.add "id", valid_761021
  var valid_761022 = path.getOrDefault("subscribable_id")
  valid_761022 = validateParameter(valid_761022, JString, required = true,
                                 default = nil)
  if valid_761022 != nil:
    section.add "subscribable_id", valid_761022
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761023: Call_PostV3ProjectsIdMergeRequestsSubscribableIdSubscription_761018;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Subscribe to a resource
  ## 
  let valid = call_761023.validator(path, query, header, formData, body)
  let scheme = call_761023.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761023.url(scheme.get, call_761023.host, call_761023.base,
                         call_761023.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761023, url, valid)

proc call*(call_761024: Call_PostV3ProjectsIdMergeRequestsSubscribableIdSubscription_761018;
          id: string; subscribableId: string): Recallable =
  ## postV3ProjectsIdMergeRequestsSubscribableIdSubscription
  ## Subscribe to a resource
  ##   id: string (required)
  ##     : The ID of a project
  ##   subscribableId: string (required)
  ##                 : The ID of a resource
  var path_761025 = newJObject()
  add(path_761025, "id", newJString(id))
  add(path_761025, "subscribable_id", newJString(subscribableId))
  result = call_761024.call(path_761025, nil, nil, nil, nil)

var postV3ProjectsIdMergeRequestsSubscribableIdSubscription* = Call_PostV3ProjectsIdMergeRequestsSubscribableIdSubscription_761018(
    name: "postV3ProjectsIdMergeRequestsSubscribableIdSubscription",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{subscribable_id}/subscription", validator: validate_PostV3ProjectsIdMergeRequestsSubscribableIdSubscription_761019,
    base: "/api",
    url: url_PostV3ProjectsIdMergeRequestsSubscribableIdSubscription_761020,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdMergeRequestsSubscribableIdSubscription_761026 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdMergeRequestsSubscribableIdSubscription_761028(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "subscribable_id" in path, "`subscribable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/merge_requests/"),
               (kind: VariableSegment, value: "subscribable_id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdMergeRequestsSubscribableIdSubscription_761027(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Unsubscribe from a resource
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   subscribable_id: JString (required)
  ##                  : The ID of a resource
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761029 = path.getOrDefault("id")
  valid_761029 = validateParameter(valid_761029, JString, required = true,
                                 default = nil)
  if valid_761029 != nil:
    section.add "id", valid_761029
  var valid_761030 = path.getOrDefault("subscribable_id")
  valid_761030 = validateParameter(valid_761030, JString, required = true,
                                 default = nil)
  if valid_761030 != nil:
    section.add "subscribable_id", valid_761030
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761031: Call_DeleteV3ProjectsIdMergeRequestsSubscribableIdSubscription_761026;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Unsubscribe from a resource
  ## 
  let valid = call_761031.validator(path, query, header, formData, body)
  let scheme = call_761031.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761031.url(scheme.get, call_761031.host, call_761031.base,
                         call_761031.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761031, url, valid)

proc call*(call_761032: Call_DeleteV3ProjectsIdMergeRequestsSubscribableIdSubscription_761026;
          id: string; subscribableId: string): Recallable =
  ## deleteV3ProjectsIdMergeRequestsSubscribableIdSubscription
  ## Unsubscribe from a resource
  ##   id: string (required)
  ##     : The ID of a project
  ##   subscribableId: string (required)
  ##                 : The ID of a resource
  var path_761033 = newJObject()
  add(path_761033, "id", newJString(id))
  add(path_761033, "subscribable_id", newJString(subscribableId))
  result = call_761032.call(path_761033, nil, nil, nil, nil)

var deleteV3ProjectsIdMergeRequestsSubscribableIdSubscription* = Call_DeleteV3ProjectsIdMergeRequestsSubscribableIdSubscription_761026(
    name: "deleteV3ProjectsIdMergeRequestsSubscribableIdSubscription",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/merge_requests/{subscribable_id}/subscription", validator: validate_DeleteV3ProjectsIdMergeRequestsSubscribableIdSubscription_761027,
    base: "/api",
    url: url_DeleteV3ProjectsIdMergeRequestsSubscribableIdSubscription_761028,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdMilestones_761047 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdMilestones_761049(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdMilestones_761048(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new project milestone
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761050 = path.getOrDefault("id")
  valid_761050 = validateParameter(valid_761050, JString, required = true,
                                 default = nil)
  if valid_761050 != nil:
    section.add "id", valid_761050
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   title: JString (required)
  ##        : The title of the milestone
  ##   start_date: JString
  ##             : The start date of the milestone. The ISO 8601 date format (%Y-%m-%d)
  ##   due_date: JString
  ##           : The due date of the milestone. The ISO 8601 date format (%Y-%m-%d)
  ##   description: JString
  ##              : The description of the milestone
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `title` field"
  var valid_761051 = formData.getOrDefault("title")
  valid_761051 = validateParameter(valid_761051, JString, required = true,
                                 default = nil)
  if valid_761051 != nil:
    section.add "title", valid_761051
  var valid_761052 = formData.getOrDefault("start_date")
  valid_761052 = validateParameter(valid_761052, JString, required = false,
                                 default = nil)
  if valid_761052 != nil:
    section.add "start_date", valid_761052
  var valid_761053 = formData.getOrDefault("due_date")
  valid_761053 = validateParameter(valid_761053, JString, required = false,
                                 default = nil)
  if valid_761053 != nil:
    section.add "due_date", valid_761053
  var valid_761054 = formData.getOrDefault("description")
  valid_761054 = validateParameter(valid_761054, JString, required = false,
                                 default = nil)
  if valid_761054 != nil:
    section.add "description", valid_761054
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761055: Call_PostV3ProjectsIdMilestones_761047; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new project milestone
  ## 
  let valid = call_761055.validator(path, query, header, formData, body)
  let scheme = call_761055.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761055.url(scheme.get, call_761055.host, call_761055.base,
                         call_761055.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761055, url, valid)

proc call*(call_761056: Call_PostV3ProjectsIdMilestones_761047; title: string;
          id: string; startDate: string = ""; dueDate: string = "";
          description: string = ""): Recallable =
  ## postV3ProjectsIdMilestones
  ## Create a new project milestone
  ##   title: string (required)
  ##        : The title of the milestone
  ##   startDate: string
  ##            : The start date of the milestone. The ISO 8601 date format (%Y-%m-%d)
  ##   id: string (required)
  ##     : The ID of a project
  ##   dueDate: string
  ##          : The due date of the milestone. The ISO 8601 date format (%Y-%m-%d)
  ##   description: string
  ##              : The description of the milestone
  var path_761057 = newJObject()
  var formData_761058 = newJObject()
  add(formData_761058, "title", newJString(title))
  add(formData_761058, "start_date", newJString(startDate))
  add(path_761057, "id", newJString(id))
  add(formData_761058, "due_date", newJString(dueDate))
  add(formData_761058, "description", newJString(description))
  result = call_761056.call(path_761057, nil, nil, formData_761058, nil)

var postV3ProjectsIdMilestones* = Call_PostV3ProjectsIdMilestones_761047(
    name: "postV3ProjectsIdMilestones", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/milestones",
    validator: validate_PostV3ProjectsIdMilestones_761048, base: "/api",
    url: url_PostV3ProjectsIdMilestones_761049, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMilestones_761034 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMilestones_761036(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMilestones_761035(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a list of project milestones
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761037 = path.getOrDefault("id")
  valid_761037 = validateParameter(valid_761037, JString, required = true,
                                 default = nil)
  if valid_761037 != nil:
    section.add "id", valid_761037
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : Return "active", "closed", or "all" milestones
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_761038 = query.getOrDefault("state")
  valid_761038 = validateParameter(valid_761038, JString, required = false,
                                 default = newJString("all"))
  if valid_761038 != nil:
    section.add "state", valid_761038
  var valid_761039 = query.getOrDefault("per_page")
  valid_761039 = validateParameter(valid_761039, JInt, required = false, default = nil)
  if valid_761039 != nil:
    section.add "per_page", valid_761039
  var valid_761040 = query.getOrDefault("page")
  valid_761040 = validateParameter(valid_761040, JInt, required = false, default = nil)
  if valid_761040 != nil:
    section.add "page", valid_761040
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   iid: JArray
  ##      : The IID of the milestone
  section = newJObject()
  var valid_761041 = formData.getOrDefault("iid")
  valid_761041 = validateParameter(valid_761041, JArray, required = false,
                                 default = nil)
  if valid_761041 != nil:
    section.add "iid", valid_761041
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761042: Call_GetV3ProjectsIdMilestones_761034; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a list of project milestones
  ## 
  let valid = call_761042.validator(path, query, header, formData, body)
  let scheme = call_761042.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761042.url(scheme.get, call_761042.host, call_761042.base,
                         call_761042.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761042, url, valid)

proc call*(call_761043: Call_GetV3ProjectsIdMilestones_761034; id: string;
          state: string = "all"; perPage: int = 0; page: int = 0; iid: JsonNode = nil): Recallable =
  ## getV3ProjectsIdMilestones
  ## Get a list of project milestones
  ##   id: string (required)
  ##     : The ID of a project
  ##   state: string
  ##        : Return "active", "closed", or "all" milestones
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   iid: JArray
  ##      : The IID of the milestone
  var path_761044 = newJObject()
  var query_761045 = newJObject()
  var formData_761046 = newJObject()
  add(path_761044, "id", newJString(id))
  add(query_761045, "state", newJString(state))
  add(query_761045, "per_page", newJInt(perPage))
  add(query_761045, "page", newJInt(page))
  if iid != nil:
    formData_761046.add "iid", iid
  result = call_761043.call(path_761044, query_761045, nil, formData_761046, nil)

var getV3ProjectsIdMilestones* = Call_GetV3ProjectsIdMilestones_761034(
    name: "getV3ProjectsIdMilestones", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/milestones",
    validator: validate_GetV3ProjectsIdMilestones_761035, base: "/api",
    url: url_GetV3ProjectsIdMilestones_761036, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdMilestonesMilestoneId_761067 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdMilestonesMilestoneId_761069(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "milestone_id" in path, "`milestone_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "milestone_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdMilestonesMilestoneId_761068(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update an existing project milestone
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   milestone_id: JInt (required)
  ##               : The ID of a project milestone
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `milestone_id` field"
  var valid_761070 = path.getOrDefault("milestone_id")
  valid_761070 = validateParameter(valid_761070, JInt, required = true, default = nil)
  if valid_761070 != nil:
    section.add "milestone_id", valid_761070
  var valid_761071 = path.getOrDefault("id")
  valid_761071 = validateParameter(valid_761071, JString, required = true,
                                 default = nil)
  if valid_761071 != nil:
    section.add "id", valid_761071
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   title: JString
  ##        : The title of the milestone
  ##   start_date: JString
  ##             : The start date of the milestone. The ISO 8601 date format (%Y-%m-%d)
  ##   due_date: JString
  ##           : The due date of the milestone. The ISO 8601 date format (%Y-%m-%d)
  ##   description: JString
  ##              : The description of the milestone
  ##   state_event: JString
  ##              : The state event of the milestone 
  section = newJObject()
  var valid_761072 = formData.getOrDefault("title")
  valid_761072 = validateParameter(valid_761072, JString, required = false,
                                 default = nil)
  if valid_761072 != nil:
    section.add "title", valid_761072
  var valid_761073 = formData.getOrDefault("start_date")
  valid_761073 = validateParameter(valid_761073, JString, required = false,
                                 default = nil)
  if valid_761073 != nil:
    section.add "start_date", valid_761073
  var valid_761074 = formData.getOrDefault("due_date")
  valid_761074 = validateParameter(valid_761074, JString, required = false,
                                 default = nil)
  if valid_761074 != nil:
    section.add "due_date", valid_761074
  var valid_761075 = formData.getOrDefault("description")
  valid_761075 = validateParameter(valid_761075, JString, required = false,
                                 default = nil)
  if valid_761075 != nil:
    section.add "description", valid_761075
  var valid_761076 = formData.getOrDefault("state_event")
  valid_761076 = validateParameter(valid_761076, JString, required = false,
                                 default = newJString("close"))
  if valid_761076 != nil:
    section.add "state_event", valid_761076
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761077: Call_PutV3ProjectsIdMilestonesMilestoneId_761067;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update an existing project milestone
  ## 
  let valid = call_761077.validator(path, query, header, formData, body)
  let scheme = call_761077.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761077.url(scheme.get, call_761077.host, call_761077.base,
                         call_761077.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761077, url, valid)

proc call*(call_761078: Call_PutV3ProjectsIdMilestonesMilestoneId_761067;
          milestoneId: int; id: string; title: string = ""; startDate: string = "";
          dueDate: string = ""; description: string = ""; stateEvent: string = "close"): Recallable =
  ## putV3ProjectsIdMilestonesMilestoneId
  ## Update an existing project milestone
  ##   milestoneId: int (required)
  ##              : The ID of a project milestone
  ##   title: string
  ##        : The title of the milestone
  ##   startDate: string
  ##            : The start date of the milestone. The ISO 8601 date format (%Y-%m-%d)
  ##   id: string (required)
  ##     : The ID of a project
  ##   dueDate: string
  ##          : The due date of the milestone. The ISO 8601 date format (%Y-%m-%d)
  ##   description: string
  ##              : The description of the milestone
  ##   stateEvent: string
  ##             : The state event of the milestone 
  var path_761079 = newJObject()
  var formData_761080 = newJObject()
  add(path_761079, "milestone_id", newJInt(milestoneId))
  add(formData_761080, "title", newJString(title))
  add(formData_761080, "start_date", newJString(startDate))
  add(path_761079, "id", newJString(id))
  add(formData_761080, "due_date", newJString(dueDate))
  add(formData_761080, "description", newJString(description))
  add(formData_761080, "state_event", newJString(stateEvent))
  result = call_761078.call(path_761079, nil, nil, formData_761080, nil)

var putV3ProjectsIdMilestonesMilestoneId* = Call_PutV3ProjectsIdMilestonesMilestoneId_761067(
    name: "putV3ProjectsIdMilestonesMilestoneId", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/milestones/{milestone_id}",
    validator: validate_PutV3ProjectsIdMilestonesMilestoneId_761068, base: "/api",
    url: url_PutV3ProjectsIdMilestonesMilestoneId_761069, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMilestonesMilestoneId_761059 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMilestonesMilestoneId_761061(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "milestone_id" in path, "`milestone_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "milestone_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMilestonesMilestoneId_761060(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single project milestone
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   milestone_id: JInt (required)
  ##               : The ID of a project milestone
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `milestone_id` field"
  var valid_761062 = path.getOrDefault("milestone_id")
  valid_761062 = validateParameter(valid_761062, JInt, required = true, default = nil)
  if valid_761062 != nil:
    section.add "milestone_id", valid_761062
  var valid_761063 = path.getOrDefault("id")
  valid_761063 = validateParameter(valid_761063, JString, required = true,
                                 default = nil)
  if valid_761063 != nil:
    section.add "id", valid_761063
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761064: Call_GetV3ProjectsIdMilestonesMilestoneId_761059;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single project milestone
  ## 
  let valid = call_761064.validator(path, query, header, formData, body)
  let scheme = call_761064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761064.url(scheme.get, call_761064.host, call_761064.base,
                         call_761064.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761064, url, valid)

proc call*(call_761065: Call_GetV3ProjectsIdMilestonesMilestoneId_761059;
          milestoneId: int; id: string): Recallable =
  ## getV3ProjectsIdMilestonesMilestoneId
  ## Get a single project milestone
  ##   milestoneId: int (required)
  ##              : The ID of a project milestone
  ##   id: string (required)
  ##     : The ID of a project
  var path_761066 = newJObject()
  add(path_761066, "milestone_id", newJInt(milestoneId))
  add(path_761066, "id", newJString(id))
  result = call_761065.call(path_761066, nil, nil, nil, nil)

var getV3ProjectsIdMilestonesMilestoneId* = Call_GetV3ProjectsIdMilestonesMilestoneId_761059(
    name: "getV3ProjectsIdMilestonesMilestoneId", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/milestones/{milestone_id}",
    validator: validate_GetV3ProjectsIdMilestonesMilestoneId_761060, base: "/api",
    url: url_GetV3ProjectsIdMilestonesMilestoneId_761061, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdMilestonesMilestoneIdIssues_761081 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdMilestonesMilestoneIdIssues_761083(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "milestone_id" in path, "`milestone_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "milestone_id"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdMilestonesMilestoneIdIssues_761082(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get all issues for a single project milestone
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   milestone_id: JInt (required)
  ##               : The ID of a project milestone
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `milestone_id` field"
  var valid_761084 = path.getOrDefault("milestone_id")
  valid_761084 = validateParameter(valid_761084, JInt, required = true, default = nil)
  if valid_761084 != nil:
    section.add "milestone_id", valid_761084
  var valid_761085 = path.getOrDefault("id")
  valid_761085 = validateParameter(valid_761085, JString, required = true,
                                 default = nil)
  if valid_761085 != nil:
    section.add "id", valid_761085
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_761086 = query.getOrDefault("per_page")
  valid_761086 = validateParameter(valid_761086, JInt, required = false, default = nil)
  if valid_761086 != nil:
    section.add "per_page", valid_761086
  var valid_761087 = query.getOrDefault("page")
  valid_761087 = validateParameter(valid_761087, JInt, required = false, default = nil)
  if valid_761087 != nil:
    section.add "page", valid_761087
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761088: Call_GetV3ProjectsIdMilestonesMilestoneIdIssues_761081;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get all issues for a single project milestone
  ## 
  let valid = call_761088.validator(path, query, header, formData, body)
  let scheme = call_761088.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761088.url(scheme.get, call_761088.host, call_761088.base,
                         call_761088.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761088, url, valid)

proc call*(call_761089: Call_GetV3ProjectsIdMilestonesMilestoneIdIssues_761081;
          milestoneId: int; id: string; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdMilestonesMilestoneIdIssues
  ## Get all issues for a single project milestone
  ##   milestoneId: int (required)
  ##              : The ID of a project milestone
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_761090 = newJObject()
  var query_761091 = newJObject()
  add(path_761090, "milestone_id", newJInt(milestoneId))
  add(path_761090, "id", newJString(id))
  add(query_761091, "per_page", newJInt(perPage))
  add(query_761091, "page", newJInt(page))
  result = call_761089.call(path_761090, query_761091, nil, nil, nil)

var getV3ProjectsIdMilestonesMilestoneIdIssues* = Call_GetV3ProjectsIdMilestonesMilestoneIdIssues_761081(
    name: "getV3ProjectsIdMilestonesMilestoneIdIssues", meth: HttpMethod.HttpGet,
    host: "gitlab.com",
    route: "/v3/projects/{id}/milestones/{milestone_id}/issues",
    validator: validate_GetV3ProjectsIdMilestonesMilestoneIdIssues_761082,
    base: "/api", url: url_GetV3ProjectsIdMilestonesMilestoneIdIssues_761083,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdNotificationSettings_761099 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdNotificationSettings_761101(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/notification_settings")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdNotificationSettings_761100(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.12
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID or project ID or project NAMESPACE/PROJECT_NAME
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761102 = path.getOrDefault("id")
  valid_761102 = validateParameter(valid_761102, JString, required = true,
                                 default = nil)
  if valid_761102 != nil:
    section.add "id", valid_761102
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   failed_pipeline: JBool
  ##                  : Enable/disable this notification
  ##   reopen_issue: JBool
  ##               : Enable/disable this notification
  ##   reassign_issue: JBool
  ##                 : Enable/disable this notification
  ##   reopen_merge_request: JBool
  ##                       : Enable/disable this notification
  ##   new_note: JBool
  ##           : Enable/disable this notification
  ##   success_pipeline: JBool
  ##                   : Enable/disable this notification
  ##   new_issue: JBool
  ##            : Enable/disable this notification
  ##   new_merge_request: JBool
  ##                    : Enable/disable this notification
  ##   level: JString
  ##        : The project notification level
  ##   close_issue: JBool
  ##              : Enable/disable this notification
  ##   reassign_merge_request: JBool
  ##                         : Enable/disable this notification
  ##   close_merge_request: JBool
  ##                      : Enable/disable this notification
  ##   merge_merge_request: JBool
  ##                      : Enable/disable this notification
  section = newJObject()
  var valid_761103 = formData.getOrDefault("failed_pipeline")
  valid_761103 = validateParameter(valid_761103, JBool, required = false, default = nil)
  if valid_761103 != nil:
    section.add "failed_pipeline", valid_761103
  var valid_761104 = formData.getOrDefault("reopen_issue")
  valid_761104 = validateParameter(valid_761104, JBool, required = false, default = nil)
  if valid_761104 != nil:
    section.add "reopen_issue", valid_761104
  var valid_761105 = formData.getOrDefault("reassign_issue")
  valid_761105 = validateParameter(valid_761105, JBool, required = false, default = nil)
  if valid_761105 != nil:
    section.add "reassign_issue", valid_761105
  var valid_761106 = formData.getOrDefault("reopen_merge_request")
  valid_761106 = validateParameter(valid_761106, JBool, required = false, default = nil)
  if valid_761106 != nil:
    section.add "reopen_merge_request", valid_761106
  var valid_761107 = formData.getOrDefault("new_note")
  valid_761107 = validateParameter(valid_761107, JBool, required = false, default = nil)
  if valid_761107 != nil:
    section.add "new_note", valid_761107
  var valid_761108 = formData.getOrDefault("success_pipeline")
  valid_761108 = validateParameter(valid_761108, JBool, required = false, default = nil)
  if valid_761108 != nil:
    section.add "success_pipeline", valid_761108
  var valid_761109 = formData.getOrDefault("new_issue")
  valid_761109 = validateParameter(valid_761109, JBool, required = false, default = nil)
  if valid_761109 != nil:
    section.add "new_issue", valid_761109
  var valid_761110 = formData.getOrDefault("new_merge_request")
  valid_761110 = validateParameter(valid_761110, JBool, required = false, default = nil)
  if valid_761110 != nil:
    section.add "new_merge_request", valid_761110
  var valid_761111 = formData.getOrDefault("level")
  valid_761111 = validateParameter(valid_761111, JString, required = false,
                                 default = nil)
  if valid_761111 != nil:
    section.add "level", valid_761111
  var valid_761112 = formData.getOrDefault("close_issue")
  valid_761112 = validateParameter(valid_761112, JBool, required = false, default = nil)
  if valid_761112 != nil:
    section.add "close_issue", valid_761112
  var valid_761113 = formData.getOrDefault("reassign_merge_request")
  valid_761113 = validateParameter(valid_761113, JBool, required = false, default = nil)
  if valid_761113 != nil:
    section.add "reassign_merge_request", valid_761113
  var valid_761114 = formData.getOrDefault("close_merge_request")
  valid_761114 = validateParameter(valid_761114, JBool, required = false, default = nil)
  if valid_761114 != nil:
    section.add "close_merge_request", valid_761114
  var valid_761115 = formData.getOrDefault("merge_merge_request")
  valid_761115 = validateParameter(valid_761115, JBool, required = false, default = nil)
  if valid_761115 != nil:
    section.add "merge_merge_request", valid_761115
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761116: Call_PutV3ProjectsIdNotificationSettings_761099;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.12
  ## 
  let valid = call_761116.validator(path, query, header, formData, body)
  let scheme = call_761116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761116.url(scheme.get, call_761116.host, call_761116.base,
                         call_761116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761116, url, valid)

proc call*(call_761117: Call_PutV3ProjectsIdNotificationSettings_761099;
          id: string; failedPipeline: bool = false; reopenIssue: bool = false;
          reassignIssue: bool = false; reopenMergeRequest: bool = false;
          newNote: bool = false; successPipeline: bool = false; newIssue: bool = false;
          newMergeRequest: bool = false; level: string = ""; closeIssue: bool = false;
          reassignMergeRequest: bool = false; closeMergeRequest: bool = false;
          mergeMergeRequest: bool = false): Recallable =
  ## putV3ProjectsIdNotificationSettings
  ## This feature was introduced in GitLab 8.12
  ##   failedPipeline: bool
  ##                 : Enable/disable this notification
  ##   id: string (required)
  ##     : The group ID or project ID or project NAMESPACE/PROJECT_NAME
  ##   reopenIssue: bool
  ##              : Enable/disable this notification
  ##   reassignIssue: bool
  ##                : Enable/disable this notification
  ##   reopenMergeRequest: bool
  ##                     : Enable/disable this notification
  ##   newNote: bool
  ##          : Enable/disable this notification
  ##   successPipeline: bool
  ##                  : Enable/disable this notification
  ##   newIssue: bool
  ##           : Enable/disable this notification
  ##   newMergeRequest: bool
  ##                  : Enable/disable this notification
  ##   level: string
  ##        : The project notification level
  ##   closeIssue: bool
  ##             : Enable/disable this notification
  ##   reassignMergeRequest: bool
  ##                       : Enable/disable this notification
  ##   closeMergeRequest: bool
  ##                    : Enable/disable this notification
  ##   mergeMergeRequest: bool
  ##                    : Enable/disable this notification
  var path_761118 = newJObject()
  var formData_761119 = newJObject()
  add(formData_761119, "failed_pipeline", newJBool(failedPipeline))
  add(path_761118, "id", newJString(id))
  add(formData_761119, "reopen_issue", newJBool(reopenIssue))
  add(formData_761119, "reassign_issue", newJBool(reassignIssue))
  add(formData_761119, "reopen_merge_request", newJBool(reopenMergeRequest))
  add(formData_761119, "new_note", newJBool(newNote))
  add(formData_761119, "success_pipeline", newJBool(successPipeline))
  add(formData_761119, "new_issue", newJBool(newIssue))
  add(formData_761119, "new_merge_request", newJBool(newMergeRequest))
  add(formData_761119, "level", newJString(level))
  add(formData_761119, "close_issue", newJBool(closeIssue))
  add(formData_761119, "reassign_merge_request", newJBool(reassignMergeRequest))
  add(formData_761119, "close_merge_request", newJBool(closeMergeRequest))
  add(formData_761119, "merge_merge_request", newJBool(mergeMergeRequest))
  result = call_761117.call(path_761118, nil, nil, formData_761119, nil)

var putV3ProjectsIdNotificationSettings* = Call_PutV3ProjectsIdNotificationSettings_761099(
    name: "putV3ProjectsIdNotificationSettings", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/notification_settings",
    validator: validate_PutV3ProjectsIdNotificationSettings_761100, base: "/api",
    url: url_PutV3ProjectsIdNotificationSettings_761101, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdNotificationSettings_761092 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdNotificationSettings_761094(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/notification_settings")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdNotificationSettings_761093(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.12
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The group ID or project ID or project NAMESPACE/PROJECT_NAME
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761095 = path.getOrDefault("id")
  valid_761095 = validateParameter(valid_761095, JString, required = true,
                                 default = nil)
  if valid_761095 != nil:
    section.add "id", valid_761095
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761096: Call_GetV3ProjectsIdNotificationSettings_761092;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.12
  ## 
  let valid = call_761096.validator(path, query, header, formData, body)
  let scheme = call_761096.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761096.url(scheme.get, call_761096.host, call_761096.base,
                         call_761096.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761096, url, valid)

proc call*(call_761097: Call_GetV3ProjectsIdNotificationSettings_761092; id: string): Recallable =
  ## getV3ProjectsIdNotificationSettings
  ## This feature was introduced in GitLab 8.12
  ##   id: string (required)
  ##     : The group ID or project ID or project NAMESPACE/PROJECT_NAME
  var path_761098 = newJObject()
  add(path_761098, "id", newJString(id))
  result = call_761097.call(path_761098, nil, nil, nil, nil)

var getV3ProjectsIdNotificationSettings* = Call_GetV3ProjectsIdNotificationSettings_761092(
    name: "getV3ProjectsIdNotificationSettings", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/notification_settings",
    validator: validate_GetV3ProjectsIdNotificationSettings_761093, base: "/api",
    url: url_GetV3ProjectsIdNotificationSettings_761094, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdPipeline_761120 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdPipeline_761122(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/pipeline")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdPipeline_761121(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.14
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761123 = path.getOrDefault("id")
  valid_761123 = validateParameter(valid_761123, JString, required = true,
                                 default = nil)
  if valid_761123 != nil:
    section.add "id", valid_761123
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   ref: JString (required)
  ##      : Reference
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ref` field"
  var valid_761124 = formData.getOrDefault("ref")
  valid_761124 = validateParameter(valid_761124, JString, required = true,
                                 default = nil)
  if valid_761124 != nil:
    section.add "ref", valid_761124
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761125: Call_PostV3ProjectsIdPipeline_761120; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.14
  ## 
  let valid = call_761125.validator(path, query, header, formData, body)
  let scheme = call_761125.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761125.url(scheme.get, call_761125.host, call_761125.base,
                         call_761125.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761125, url, valid)

proc call*(call_761126: Call_PostV3ProjectsIdPipeline_761120; `ref`: string;
          id: string): Recallable =
  ## postV3ProjectsIdPipeline
  ## This feature was introduced in GitLab 8.14
  ##   ref: string (required)
  ##      : Reference
  ##   id: string (required)
  ##     : The project ID
  var path_761127 = newJObject()
  var formData_761128 = newJObject()
  add(formData_761128, "ref", newJString(`ref`))
  add(path_761127, "id", newJString(id))
  result = call_761126.call(path_761127, nil, nil, formData_761128, nil)

var postV3ProjectsIdPipeline* = Call_PostV3ProjectsIdPipeline_761120(
    name: "postV3ProjectsIdPipeline", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/pipeline",
    validator: validate_PostV3ProjectsIdPipeline_761121, base: "/api",
    url: url_PostV3ProjectsIdPipeline_761122, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdPipelines_761129 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdPipelines_761131(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/pipelines")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdPipelines_761130(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761132 = path.getOrDefault("id")
  valid_761132 = validateParameter(valid_761132, JString, required = true,
                                 default = nil)
  if valid_761132 != nil:
    section.add "id", valid_761132
  result.add "path", section
  ## parameters in `query` object:
  ##   scope: JString
  ##        : Either running, branches, or tags
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_761133 = query.getOrDefault("scope")
  valid_761133 = validateParameter(valid_761133, JString, required = false,
                                 default = newJString("running"))
  if valid_761133 != nil:
    section.add "scope", valid_761133
  var valid_761134 = query.getOrDefault("per_page")
  valid_761134 = validateParameter(valid_761134, JInt, required = false, default = nil)
  if valid_761134 != nil:
    section.add "per_page", valid_761134
  var valid_761135 = query.getOrDefault("page")
  valid_761135 = validateParameter(valid_761135, JInt, required = false, default = nil)
  if valid_761135 != nil:
    section.add "page", valid_761135
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761136: Call_GetV3ProjectsIdPipelines_761129; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_761136.validator(path, query, header, formData, body)
  let scheme = call_761136.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761136.url(scheme.get, call_761136.host, call_761136.base,
                         call_761136.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761136, url, valid)

proc call*(call_761137: Call_GetV3ProjectsIdPipelines_761129; id: string;
          scope: string = "running"; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdPipelines
  ## This feature was introduced in GitLab 8.11.
  ##   scope: string
  ##        : Either running, branches, or tags
  ##   id: string (required)
  ##     : The project ID
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_761138 = newJObject()
  var query_761139 = newJObject()
  add(query_761139, "scope", newJString(scope))
  add(path_761138, "id", newJString(id))
  add(query_761139, "per_page", newJInt(perPage))
  add(query_761139, "page", newJInt(page))
  result = call_761137.call(path_761138, query_761139, nil, nil, nil)

var getV3ProjectsIdPipelines* = Call_GetV3ProjectsIdPipelines_761129(
    name: "getV3ProjectsIdPipelines", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/pipelines",
    validator: validate_GetV3ProjectsIdPipelines_761130, base: "/api",
    url: url_GetV3ProjectsIdPipelines_761131, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdPipelinesPipelineId_761140 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdPipelinesPipelineId_761142(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "pipeline_id" in path, "`pipeline_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/pipelines/"),
               (kind: VariableSegment, value: "pipeline_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdPipelinesPipelineId_761141(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   pipeline_id: JInt (required)
  ##              : The pipeline ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761143 = path.getOrDefault("id")
  valid_761143 = validateParameter(valid_761143, JString, required = true,
                                 default = nil)
  if valid_761143 != nil:
    section.add "id", valid_761143
  var valid_761144 = path.getOrDefault("pipeline_id")
  valid_761144 = validateParameter(valid_761144, JInt, required = true, default = nil)
  if valid_761144 != nil:
    section.add "pipeline_id", valid_761144
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761145: Call_GetV3ProjectsIdPipelinesPipelineId_761140;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11
  ## 
  let valid = call_761145.validator(path, query, header, formData, body)
  let scheme = call_761145.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761145.url(scheme.get, call_761145.host, call_761145.base,
                         call_761145.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761145, url, valid)

proc call*(call_761146: Call_GetV3ProjectsIdPipelinesPipelineId_761140; id: string;
          pipelineId: int): Recallable =
  ## getV3ProjectsIdPipelinesPipelineId
  ## This feature was introduced in GitLab 8.11
  ##   id: string (required)
  ##     : The project ID
  ##   pipelineId: int (required)
  ##             : The pipeline ID
  var path_761147 = newJObject()
  add(path_761147, "id", newJString(id))
  add(path_761147, "pipeline_id", newJInt(pipelineId))
  result = call_761146.call(path_761147, nil, nil, nil, nil)

var getV3ProjectsIdPipelinesPipelineId* = Call_GetV3ProjectsIdPipelinesPipelineId_761140(
    name: "getV3ProjectsIdPipelinesPipelineId", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/pipelines/{pipeline_id}",
    validator: validate_GetV3ProjectsIdPipelinesPipelineId_761141, base: "/api",
    url: url_GetV3ProjectsIdPipelinesPipelineId_761142, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdPipelinesPipelineIdCancel_761148 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdPipelinesPipelineIdCancel_761150(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "pipeline_id" in path, "`pipeline_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/pipelines/"),
               (kind: VariableSegment, value: "pipeline_id"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdPipelinesPipelineIdCancel_761149(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   pipeline_id: JInt (required)
  ##              : The pipeline ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761151 = path.getOrDefault("id")
  valid_761151 = validateParameter(valid_761151, JString, required = true,
                                 default = nil)
  if valid_761151 != nil:
    section.add "id", valid_761151
  var valid_761152 = path.getOrDefault("pipeline_id")
  valid_761152 = validateParameter(valid_761152, JInt, required = true, default = nil)
  if valid_761152 != nil:
    section.add "pipeline_id", valid_761152
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761153: Call_PostV3ProjectsIdPipelinesPipelineIdCancel_761148;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_761153.validator(path, query, header, formData, body)
  let scheme = call_761153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761153.url(scheme.get, call_761153.host, call_761153.base,
                         call_761153.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761153, url, valid)

proc call*(call_761154: Call_PostV3ProjectsIdPipelinesPipelineIdCancel_761148;
          id: string; pipelineId: int): Recallable =
  ## postV3ProjectsIdPipelinesPipelineIdCancel
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The project ID
  ##   pipelineId: int (required)
  ##             : The pipeline ID
  var path_761155 = newJObject()
  add(path_761155, "id", newJString(id))
  add(path_761155, "pipeline_id", newJInt(pipelineId))
  result = call_761154.call(path_761155, nil, nil, nil, nil)

var postV3ProjectsIdPipelinesPipelineIdCancel* = Call_PostV3ProjectsIdPipelinesPipelineIdCancel_761148(
    name: "postV3ProjectsIdPipelinesPipelineIdCancel", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/pipelines/{pipeline_id}/cancel",
    validator: validate_PostV3ProjectsIdPipelinesPipelineIdCancel_761149,
    base: "/api", url: url_PostV3ProjectsIdPipelinesPipelineIdCancel_761150,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdPipelinesPipelineIdRetry_761156 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdPipelinesPipelineIdRetry_761158(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "pipeline_id" in path, "`pipeline_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/pipelines/"),
               (kind: VariableSegment, value: "pipeline_id"),
               (kind: ConstantSegment, value: "/retry")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdPipelinesPipelineIdRetry_761157(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.11.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  ##   pipeline_id: JInt (required)
  ##              : The pipeline ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761159 = path.getOrDefault("id")
  valid_761159 = validateParameter(valid_761159, JString, required = true,
                                 default = nil)
  if valid_761159 != nil:
    section.add "id", valid_761159
  var valid_761160 = path.getOrDefault("pipeline_id")
  valid_761160 = validateParameter(valid_761160, JInt, required = true, default = nil)
  if valid_761160 != nil:
    section.add "pipeline_id", valid_761160
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761161: Call_PostV3ProjectsIdPipelinesPipelineIdRetry_761156;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.11.
  ## 
  let valid = call_761161.validator(path, query, header, formData, body)
  let scheme = call_761161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761161.url(scheme.get, call_761161.host, call_761161.base,
                         call_761161.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761161, url, valid)

proc call*(call_761162: Call_PostV3ProjectsIdPipelinesPipelineIdRetry_761156;
          id: string; pipelineId: int): Recallable =
  ## postV3ProjectsIdPipelinesPipelineIdRetry
  ## This feature was introduced in GitLab 8.11.
  ##   id: string (required)
  ##     : The project ID
  ##   pipelineId: int (required)
  ##             : The pipeline ID
  var path_761163 = newJObject()
  add(path_761163, "id", newJString(id))
  add(path_761163, "pipeline_id", newJInt(pipelineId))
  result = call_761162.call(path_761163, nil, nil, nil, nil)

var postV3ProjectsIdPipelinesPipelineIdRetry* = Call_PostV3ProjectsIdPipelinesPipelineIdRetry_761156(
    name: "postV3ProjectsIdPipelinesPipelineIdRetry", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/pipelines/{pipeline_id}/retry",
    validator: validate_PostV3ProjectsIdPipelinesPipelineIdRetry_761157,
    base: "/api", url: url_PostV3ProjectsIdPipelinesPipelineIdRetry_761158,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryArchive_761164 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryArchive_761166(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/archive")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryArchive_761165(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get an archive of the repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761167 = path.getOrDefault("id")
  valid_761167 = validateParameter(valid_761167, JString, required = true,
                                 default = nil)
  if valid_761167 != nil:
    section.add "id", valid_761167
  result.add "path", section
  ## parameters in `query` object:
  ##   sha: JString
  ##      : The commit sha of the archive to be downloaded
  ##   format: JString
  ##         : The archive format
  section = newJObject()
  var valid_761168 = query.getOrDefault("sha")
  valid_761168 = validateParameter(valid_761168, JString, required = false,
                                 default = nil)
  if valid_761168 != nil:
    section.add "sha", valid_761168
  var valid_761169 = query.getOrDefault("format")
  valid_761169 = validateParameter(valid_761169, JString, required = false,
                                 default = nil)
  if valid_761169 != nil:
    section.add "format", valid_761169
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761170: Call_GetV3ProjectsIdRepositoryArchive_761164;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get an archive of the repository
  ## 
  let valid = call_761170.validator(path, query, header, formData, body)
  let scheme = call_761170.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761170.url(scheme.get, call_761170.host, call_761170.base,
                         call_761170.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761170, url, valid)

proc call*(call_761171: Call_GetV3ProjectsIdRepositoryArchive_761164; id: string;
          sha: string = ""; format: string = ""): Recallable =
  ## getV3ProjectsIdRepositoryArchive
  ## Get an archive of the repository
  ##   id: string (required)
  ##     : The ID of a project
  ##   sha: string
  ##      : The commit sha of the archive to be downloaded
  ##   format: string
  ##         : The archive format
  var path_761172 = newJObject()
  var query_761173 = newJObject()
  add(path_761172, "id", newJString(id))
  add(query_761173, "sha", newJString(sha))
  add(query_761173, "format", newJString(format))
  result = call_761171.call(path_761172, query_761173, nil, nil, nil)

var getV3ProjectsIdRepositoryArchive* = Call_GetV3ProjectsIdRepositoryArchive_761164(
    name: "getV3ProjectsIdRepositoryArchive", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/archive",
    validator: validate_GetV3ProjectsIdRepositoryArchive_761165, base: "/api",
    url: url_GetV3ProjectsIdRepositoryArchive_761166, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryBlobsSha_761174 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryBlobsSha_761176(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/blobs/"),
               (kind: VariableSegment, value: "sha")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryBlobsSha_761175(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a raw file contents
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : The commit, branch name, or tag name
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761177 = path.getOrDefault("id")
  valid_761177 = validateParameter(valid_761177, JString, required = true,
                                 default = nil)
  if valid_761177 != nil:
    section.add "id", valid_761177
  var valid_761178 = path.getOrDefault("sha")
  valid_761178 = validateParameter(valid_761178, JString, required = true,
                                 default = nil)
  if valid_761178 != nil:
    section.add "sha", valid_761178
  result.add "path", section
  ## parameters in `query` object:
  ##   filepath: JString (required)
  ##           : The path to the file to display
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `filepath` field"
  var valid_761179 = query.getOrDefault("filepath")
  valid_761179 = validateParameter(valid_761179, JString, required = true,
                                 default = nil)
  if valid_761179 != nil:
    section.add "filepath", valid_761179
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761180: Call_GetV3ProjectsIdRepositoryBlobsSha_761174;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a raw file contents
  ## 
  let valid = call_761180.validator(path, query, header, formData, body)
  let scheme = call_761180.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761180.url(scheme.get, call_761180.host, call_761180.base,
                         call_761180.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761180, url, valid)

proc call*(call_761181: Call_GetV3ProjectsIdRepositoryBlobsSha_761174; id: string;
          sha: string; filepath: string): Recallable =
  ## getV3ProjectsIdRepositoryBlobsSha
  ## Get a raw file contents
  ##   id: string (required)
  ##     : The ID of a project
  ##   sha: string (required)
  ##      : The commit, branch name, or tag name
  ##   filepath: string (required)
  ##           : The path to the file to display
  var path_761182 = newJObject()
  var query_761183 = newJObject()
  add(path_761182, "id", newJString(id))
  add(path_761182, "sha", newJString(sha))
  add(query_761183, "filepath", newJString(filepath))
  result = call_761181.call(path_761182, query_761183, nil, nil, nil)

var getV3ProjectsIdRepositoryBlobsSha* = Call_GetV3ProjectsIdRepositoryBlobsSha_761174(
    name: "getV3ProjectsIdRepositoryBlobsSha", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/blobs/{sha}",
    validator: validate_GetV3ProjectsIdRepositoryBlobsSha_761175, base: "/api",
    url: url_GetV3ProjectsIdRepositoryBlobsSha_761176, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdRepositoryBranches_761191 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdRepositoryBranches_761193(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdRepositoryBranches_761192(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761194 = path.getOrDefault("id")
  valid_761194 = validateParameter(valid_761194, JString, required = true,
                                 default = nil)
  if valid_761194 != nil:
    section.add "id", valid_761194
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   ref: JString (required)
  ##      : Create branch from commit sha or existing branch
  ##   branch_name: JString (required)
  ##              : The name of the branch
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ref` field"
  var valid_761195 = formData.getOrDefault("ref")
  valid_761195 = validateParameter(valid_761195, JString, required = true,
                                 default = nil)
  if valid_761195 != nil:
    section.add "ref", valid_761195
  var valid_761196 = formData.getOrDefault("branch_name")
  valid_761196 = validateParameter(valid_761196, JString, required = true,
                                 default = nil)
  if valid_761196 != nil:
    section.add "branch_name", valid_761196
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761197: Call_PostV3ProjectsIdRepositoryBranches_761191;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create branch
  ## 
  let valid = call_761197.validator(path, query, header, formData, body)
  let scheme = call_761197.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761197.url(scheme.get, call_761197.host, call_761197.base,
                         call_761197.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761197, url, valid)

proc call*(call_761198: Call_PostV3ProjectsIdRepositoryBranches_761191;
          `ref`: string; id: string; branchName: string): Recallable =
  ## postV3ProjectsIdRepositoryBranches
  ## Create branch
  ##   ref: string (required)
  ##      : Create branch from commit sha or existing branch
  ##   id: string (required)
  ##     : The ID of a project
  ##   branchName: string (required)
  ##             : The name of the branch
  var path_761199 = newJObject()
  var formData_761200 = newJObject()
  add(formData_761200, "ref", newJString(`ref`))
  add(path_761199, "id", newJString(id))
  add(formData_761200, "branch_name", newJString(branchName))
  result = call_761198.call(path_761199, nil, nil, formData_761200, nil)

var postV3ProjectsIdRepositoryBranches* = Call_PostV3ProjectsIdRepositoryBranches_761191(
    name: "postV3ProjectsIdRepositoryBranches", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/branches",
    validator: validate_PostV3ProjectsIdRepositoryBranches_761192, base: "/api",
    url: url_PostV3ProjectsIdRepositoryBranches_761193, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryBranches_761184 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryBranches_761186(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryBranches_761185(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a project repository branches
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761187 = path.getOrDefault("id")
  valid_761187 = validateParameter(valid_761187, JString, required = true,
                                 default = nil)
  if valid_761187 != nil:
    section.add "id", valid_761187
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761188: Call_GetV3ProjectsIdRepositoryBranches_761184;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a project repository branches
  ## 
  let valid = call_761188.validator(path, query, header, formData, body)
  let scheme = call_761188.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761188.url(scheme.get, call_761188.host, call_761188.base,
                         call_761188.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761188, url, valid)

proc call*(call_761189: Call_GetV3ProjectsIdRepositoryBranches_761184; id: string): Recallable =
  ## getV3ProjectsIdRepositoryBranches
  ## Get a project repository branches
  ##   id: string (required)
  ##     : The ID of a project
  var path_761190 = newJObject()
  add(path_761190, "id", newJString(id))
  result = call_761189.call(path_761190, nil, nil, nil, nil)

var getV3ProjectsIdRepositoryBranches* = Call_GetV3ProjectsIdRepositoryBranches_761184(
    name: "getV3ProjectsIdRepositoryBranches", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/branches",
    validator: validate_GetV3ProjectsIdRepositoryBranches_761185, base: "/api",
    url: url_GetV3ProjectsIdRepositoryBranches_761186, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryBranchesBranch_761201 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryBranchesBranch_761203(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/branches/"),
               (kind: VariableSegment, value: "branch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryBranchesBranch_761202(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   branch: JString (required)
  ##         : The name of the branch
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761204 = path.getOrDefault("id")
  valid_761204 = validateParameter(valid_761204, JString, required = true,
                                 default = nil)
  if valid_761204 != nil:
    section.add "id", valid_761204
  var valid_761205 = path.getOrDefault("branch")
  valid_761205 = validateParameter(valid_761205, JString, required = true,
                                 default = nil)
  if valid_761205 != nil:
    section.add "branch", valid_761205
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761206: Call_GetV3ProjectsIdRepositoryBranchesBranch_761201;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single branch
  ## 
  let valid = call_761206.validator(path, query, header, formData, body)
  let scheme = call_761206.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761206.url(scheme.get, call_761206.host, call_761206.base,
                         call_761206.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761206, url, valid)

proc call*(call_761207: Call_GetV3ProjectsIdRepositoryBranchesBranch_761201;
          id: string; branch: string): Recallable =
  ## getV3ProjectsIdRepositoryBranchesBranch
  ## Get a single branch
  ##   id: string (required)
  ##     : The ID of a project
  ##   branch: string (required)
  ##         : The name of the branch
  var path_761208 = newJObject()
  add(path_761208, "id", newJString(id))
  add(path_761208, "branch", newJString(branch))
  result = call_761207.call(path_761208, nil, nil, nil, nil)

var getV3ProjectsIdRepositoryBranchesBranch* = Call_GetV3ProjectsIdRepositoryBranchesBranch_761201(
    name: "getV3ProjectsIdRepositoryBranchesBranch", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/branches/{branch}",
    validator: validate_GetV3ProjectsIdRepositoryBranchesBranch_761202,
    base: "/api", url: url_GetV3ProjectsIdRepositoryBranchesBranch_761203,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdRepositoryBranchesBranch_761209 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdRepositoryBranchesBranch_761211(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/branches/"),
               (kind: VariableSegment, value: "branch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdRepositoryBranchesBranch_761210(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   branch: JString (required)
  ##         : The name of the branch
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761212 = path.getOrDefault("id")
  valid_761212 = validateParameter(valid_761212, JString, required = true,
                                 default = nil)
  if valid_761212 != nil:
    section.add "id", valid_761212
  var valid_761213 = path.getOrDefault("branch")
  valid_761213 = validateParameter(valid_761213, JString, required = true,
                                 default = nil)
  if valid_761213 != nil:
    section.add "branch", valid_761213
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761214: Call_DeleteV3ProjectsIdRepositoryBranchesBranch_761209;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a branch
  ## 
  let valid = call_761214.validator(path, query, header, formData, body)
  let scheme = call_761214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761214.url(scheme.get, call_761214.host, call_761214.base,
                         call_761214.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761214, url, valid)

proc call*(call_761215: Call_DeleteV3ProjectsIdRepositoryBranchesBranch_761209;
          id: string; branch: string): Recallable =
  ## deleteV3ProjectsIdRepositoryBranchesBranch
  ## Delete a branch
  ##   id: string (required)
  ##     : The ID of a project
  ##   branch: string (required)
  ##         : The name of the branch
  var path_761216 = newJObject()
  add(path_761216, "id", newJString(id))
  add(path_761216, "branch", newJString(branch))
  result = call_761215.call(path_761216, nil, nil, nil, nil)

var deleteV3ProjectsIdRepositoryBranchesBranch* = Call_DeleteV3ProjectsIdRepositoryBranchesBranch_761209(
    name: "deleteV3ProjectsIdRepositoryBranchesBranch",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/repository/branches/{branch}",
    validator: validate_DeleteV3ProjectsIdRepositoryBranchesBranch_761210,
    base: "/api", url: url_DeleteV3ProjectsIdRepositoryBranchesBranch_761211,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdRepositoryBranchesBranchProtect_761217 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdRepositoryBranchesBranchProtect_761219(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/branches/"),
               (kind: VariableSegment, value: "branch"),
               (kind: ConstantSegment, value: "/protect")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdRepositoryBranchesBranchProtect_761218(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Protect a single branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   branch: JString (required)
  ##         : The name of the branch
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761220 = path.getOrDefault("id")
  valid_761220 = validateParameter(valid_761220, JString, required = true,
                                 default = nil)
  if valid_761220 != nil:
    section.add "id", valid_761220
  var valid_761221 = path.getOrDefault("branch")
  valid_761221 = validateParameter(valid_761221, JString, required = true,
                                 default = nil)
  if valid_761221 != nil:
    section.add "branch", valid_761221
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   developers_can_merge: JBool
  ##                       : Flag if developers can merge to that branch
  ##   developers_can_push: JBool
  ##                      : Flag if developers can push to that branch
  section = newJObject()
  var valid_761222 = formData.getOrDefault("developers_can_merge")
  valid_761222 = validateParameter(valid_761222, JBool, required = false, default = nil)
  if valid_761222 != nil:
    section.add "developers_can_merge", valid_761222
  var valid_761223 = formData.getOrDefault("developers_can_push")
  valid_761223 = validateParameter(valid_761223, JBool, required = false, default = nil)
  if valid_761223 != nil:
    section.add "developers_can_push", valid_761223
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761224: Call_PutV3ProjectsIdRepositoryBranchesBranchProtect_761217;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Protect a single branch
  ## 
  let valid = call_761224.validator(path, query, header, formData, body)
  let scheme = call_761224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761224.url(scheme.get, call_761224.host, call_761224.base,
                         call_761224.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761224, url, valid)

proc call*(call_761225: Call_PutV3ProjectsIdRepositoryBranchesBranchProtect_761217;
          id: string; branch: string; developersCanMerge: bool = false;
          developersCanPush: bool = false): Recallable =
  ## putV3ProjectsIdRepositoryBranchesBranchProtect
  ## Protect a single branch
  ##   id: string (required)
  ##     : The ID of a project
  ##   developersCanMerge: bool
  ##                     : Flag if developers can merge to that branch
  ##   developersCanPush: bool
  ##                    : Flag if developers can push to that branch
  ##   branch: string (required)
  ##         : The name of the branch
  var path_761226 = newJObject()
  var formData_761227 = newJObject()
  add(path_761226, "id", newJString(id))
  add(formData_761227, "developers_can_merge", newJBool(developersCanMerge))
  add(formData_761227, "developers_can_push", newJBool(developersCanPush))
  add(path_761226, "branch", newJString(branch))
  result = call_761225.call(path_761226, nil, nil, formData_761227, nil)

var putV3ProjectsIdRepositoryBranchesBranchProtect* = Call_PutV3ProjectsIdRepositoryBranchesBranchProtect_761217(
    name: "putV3ProjectsIdRepositoryBranchesBranchProtect",
    meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/projects/{id}/repository/branches/{branch}/protect",
    validator: validate_PutV3ProjectsIdRepositoryBranchesBranchProtect_761218,
    base: "/api", url: url_PutV3ProjectsIdRepositoryBranchesBranchProtect_761219,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdRepositoryBranchesBranchUnprotect_761228 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdRepositoryBranchesBranchUnprotect_761230(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/branches/"),
               (kind: VariableSegment, value: "branch"),
               (kind: ConstantSegment, value: "/unprotect")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdRepositoryBranchesBranchUnprotect_761229(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Unprotect a single branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   branch: JString (required)
  ##         : The name of the branch
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761231 = path.getOrDefault("id")
  valid_761231 = validateParameter(valid_761231, JString, required = true,
                                 default = nil)
  if valid_761231 != nil:
    section.add "id", valid_761231
  var valid_761232 = path.getOrDefault("branch")
  valid_761232 = validateParameter(valid_761232, JString, required = true,
                                 default = nil)
  if valid_761232 != nil:
    section.add "branch", valid_761232
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761233: Call_PutV3ProjectsIdRepositoryBranchesBranchUnprotect_761228;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Unprotect a single branch
  ## 
  let valid = call_761233.validator(path, query, header, formData, body)
  let scheme = call_761233.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761233.url(scheme.get, call_761233.host, call_761233.base,
                         call_761233.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761233, url, valid)

proc call*(call_761234: Call_PutV3ProjectsIdRepositoryBranchesBranchUnprotect_761228;
          id: string; branch: string): Recallable =
  ## putV3ProjectsIdRepositoryBranchesBranchUnprotect
  ## Unprotect a single branch
  ##   id: string (required)
  ##     : The ID of a project
  ##   branch: string (required)
  ##         : The name of the branch
  var path_761235 = newJObject()
  add(path_761235, "id", newJString(id))
  add(path_761235, "branch", newJString(branch))
  result = call_761234.call(path_761235, nil, nil, nil, nil)

var putV3ProjectsIdRepositoryBranchesBranchUnprotect* = Call_PutV3ProjectsIdRepositoryBranchesBranchUnprotect_761228(
    name: "putV3ProjectsIdRepositoryBranchesBranchUnprotect",
    meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/projects/{id}/repository/branches/{branch}/unprotect",
    validator: validate_PutV3ProjectsIdRepositoryBranchesBranchUnprotect_761229,
    base: "/api", url: url_PutV3ProjectsIdRepositoryBranchesBranchUnprotect_761230,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdRepositoryCommits_761251 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdRepositoryCommits_761253(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdRepositoryCommits_761252(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.13
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761254 = path.getOrDefault("id")
  valid_761254 = validateParameter(valid_761254, JString, required = true,
                                 default = nil)
  if valid_761254 != nil:
    section.add "id", valid_761254
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   author_name: JString
  ##              : Author name for commit
  ##   branch_name: JString (required)
  ##              : The name of branch
  ##   actions: JArray (required)
  ##          : Actions to perform in commit
  ##   commit_message: JString (required)
  ##                 : Commit message
  ##   author_email: JString
  ##               : Author email for commit
  section = newJObject()
  var valid_761255 = formData.getOrDefault("author_name")
  valid_761255 = validateParameter(valid_761255, JString, required = false,
                                 default = nil)
  if valid_761255 != nil:
    section.add "author_name", valid_761255
  assert formData != nil,
        "formData argument is necessary due to required `branch_name` field"
  var valid_761256 = formData.getOrDefault("branch_name")
  valid_761256 = validateParameter(valid_761256, JString, required = true,
                                 default = nil)
  if valid_761256 != nil:
    section.add "branch_name", valid_761256
  var valid_761257 = formData.getOrDefault("actions")
  valid_761257 = validateParameter(valid_761257, JArray, required = true, default = nil)
  if valid_761257 != nil:
    section.add "actions", valid_761257
  var valid_761258 = formData.getOrDefault("commit_message")
  valid_761258 = validateParameter(valid_761258, JString, required = true,
                                 default = nil)
  if valid_761258 != nil:
    section.add "commit_message", valid_761258
  var valid_761259 = formData.getOrDefault("author_email")
  valid_761259 = validateParameter(valid_761259, JString, required = false,
                                 default = nil)
  if valid_761259 != nil:
    section.add "author_email", valid_761259
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761260: Call_PostV3ProjectsIdRepositoryCommits_761251;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.13
  ## 
  let valid = call_761260.validator(path, query, header, formData, body)
  let scheme = call_761260.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761260.url(scheme.get, call_761260.host, call_761260.base,
                         call_761260.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761260, url, valid)

proc call*(call_761261: Call_PostV3ProjectsIdRepositoryCommits_761251; id: string;
          branchName: string; actions: JsonNode; commitMessage: string;
          authorName: string = ""; authorEmail: string = ""): Recallable =
  ## postV3ProjectsIdRepositoryCommits
  ## This feature was introduced in GitLab 8.13
  ##   id: string (required)
  ##     : The ID of a project
  ##   authorName: string
  ##             : Author name for commit
  ##   branchName: string (required)
  ##             : The name of branch
  ##   actions: JArray (required)
  ##          : Actions to perform in commit
  ##   commitMessage: string (required)
  ##                : Commit message
  ##   authorEmail: string
  ##              : Author email for commit
  var path_761262 = newJObject()
  var formData_761263 = newJObject()
  add(path_761262, "id", newJString(id))
  add(formData_761263, "author_name", newJString(authorName))
  add(formData_761263, "branch_name", newJString(branchName))
  if actions != nil:
    formData_761263.add "actions", actions
  add(formData_761263, "commit_message", newJString(commitMessage))
  add(formData_761263, "author_email", newJString(authorEmail))
  result = call_761261.call(path_761262, nil, nil, formData_761263, nil)

var postV3ProjectsIdRepositoryCommits* = Call_PostV3ProjectsIdRepositoryCommits_761251(
    name: "postV3ProjectsIdRepositoryCommits", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/commits",
    validator: validate_PostV3ProjectsIdRepositoryCommits_761252, base: "/api",
    url: url_PostV3ProjectsIdRepositoryCommits_761253, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryCommits_761236 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryCommits_761238(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryCommits_761237(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a project repository commits
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761239 = path.getOrDefault("id")
  valid_761239 = validateParameter(valid_761239, JString, required = true,
                                 default = nil)
  if valid_761239 != nil:
    section.add "id", valid_761239
  result.add "path", section
  ## parameters in `query` object:
  ##   ref_name: JString
  ##           : The name of a repository branch or tag, if not given the default branch is used
  ##   since: JString
  ##        : Only commits after or in this date will be returned
  ##   per_page: JInt
  ##           : The number of results per page
  ##   page: JInt
  ##       : The page for pagination
  ##   path: JString
  ##       : The file path
  ##   until: JString
  ##        : Only commits before or in this date will be returned
  section = newJObject()
  var valid_761240 = query.getOrDefault("ref_name")
  valid_761240 = validateParameter(valid_761240, JString, required = false,
                                 default = nil)
  if valid_761240 != nil:
    section.add "ref_name", valid_761240
  var valid_761241 = query.getOrDefault("since")
  valid_761241 = validateParameter(valid_761241, JString, required = false,
                                 default = nil)
  if valid_761241 != nil:
    section.add "since", valid_761241
  var valid_761243 = query.getOrDefault("per_page")
  valid_761243 = validateParameter(valid_761243, JInt, required = false,
                                 default = newJInt(20))
  if valid_761243 != nil:
    section.add "per_page", valid_761243
  var valid_761244 = query.getOrDefault("page")
  valid_761244 = validateParameter(valid_761244, JInt, required = false,
                                 default = newJInt(0))
  if valid_761244 != nil:
    section.add "page", valid_761244
  var valid_761245 = query.getOrDefault("path")
  valid_761245 = validateParameter(valid_761245, JString, required = false,
                                 default = nil)
  if valid_761245 != nil:
    section.add "path", valid_761245
  var valid_761246 = query.getOrDefault("until")
  valid_761246 = validateParameter(valid_761246, JString, required = false,
                                 default = nil)
  if valid_761246 != nil:
    section.add "until", valid_761246
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761247: Call_GetV3ProjectsIdRepositoryCommits_761236;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a project repository commits
  ## 
  let valid = call_761247.validator(path, query, header, formData, body)
  let scheme = call_761247.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761247.url(scheme.get, call_761247.host, call_761247.base,
                         call_761247.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761247, url, valid)

proc call*(call_761248: Call_GetV3ProjectsIdRepositoryCommits_761236; id: string;
          refName: string = ""; since: string = ""; perPage: int = 20; page: int = 0;
          path: string = ""; until: string = ""): Recallable =
  ## getV3ProjectsIdRepositoryCommits
  ## Get a project repository commits
  ##   refName: string
  ##          : The name of a repository branch or tag, if not given the default branch is used
  ##   id: string (required)
  ##     : The ID of a project
  ##   since: string
  ##        : Only commits after or in this date will be returned
  ##   perPage: int
  ##          : The number of results per page
  ##   page: int
  ##       : The page for pagination
  ##   path: string
  ##       : The file path
  ##   until: string
  ##        : Only commits before or in this date will be returned
  var path_761249 = newJObject()
  var query_761250 = newJObject()
  add(query_761250, "ref_name", newJString(refName))
  add(path_761249, "id", newJString(id))
  add(query_761250, "since", newJString(since))
  add(query_761250, "per_page", newJInt(perPage))
  add(query_761250, "page", newJInt(page))
  add(query_761250, "path", newJString(path))
  add(query_761250, "until", newJString(until))
  result = call_761248.call(path_761249, query_761250, nil, nil, nil)

var getV3ProjectsIdRepositoryCommits* = Call_GetV3ProjectsIdRepositoryCommits_761236(
    name: "getV3ProjectsIdRepositoryCommits", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/commits",
    validator: validate_GetV3ProjectsIdRepositoryCommits_761237, base: "/api",
    url: url_GetV3ProjectsIdRepositoryCommits_761238, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryCommitsSha_761264 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryCommitsSha_761266(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/commits/"),
               (kind: VariableSegment, value: "sha")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryCommitsSha_761265(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a specific commit of a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : A commit sha, or the name of a branch or tag
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761267 = path.getOrDefault("id")
  valid_761267 = validateParameter(valid_761267, JString, required = true,
                                 default = nil)
  if valid_761267 != nil:
    section.add "id", valid_761267
  var valid_761268 = path.getOrDefault("sha")
  valid_761268 = validateParameter(valid_761268, JString, required = true,
                                 default = nil)
  if valid_761268 != nil:
    section.add "sha", valid_761268
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761269: Call_GetV3ProjectsIdRepositoryCommitsSha_761264;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a specific commit of a project
  ## 
  let valid = call_761269.validator(path, query, header, formData, body)
  let scheme = call_761269.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761269.url(scheme.get, call_761269.host, call_761269.base,
                         call_761269.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761269, url, valid)

proc call*(call_761270: Call_GetV3ProjectsIdRepositoryCommitsSha_761264;
          id: string; sha: string): Recallable =
  ## getV3ProjectsIdRepositoryCommitsSha
  ## Get a specific commit of a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   sha: string (required)
  ##      : A commit sha, or the name of a branch or tag
  var path_761271 = newJObject()
  add(path_761271, "id", newJString(id))
  add(path_761271, "sha", newJString(sha))
  result = call_761270.call(path_761271, nil, nil, nil, nil)

var getV3ProjectsIdRepositoryCommitsSha* = Call_GetV3ProjectsIdRepositoryCommitsSha_761264(
    name: "getV3ProjectsIdRepositoryCommitsSha", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/commits/{sha}",
    validator: validate_GetV3ProjectsIdRepositoryCommitsSha_761265, base: "/api",
    url: url_GetV3ProjectsIdRepositoryCommitsSha_761266, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryCommitsShaBlob_761272 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryCommitsShaBlob_761274(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/commits/"),
               (kind: VariableSegment, value: "sha"),
               (kind: ConstantSegment, value: "/blob")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryCommitsShaBlob_761273(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a raw file contents
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : The commit, branch name, or tag name
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761275 = path.getOrDefault("id")
  valid_761275 = validateParameter(valid_761275, JString, required = true,
                                 default = nil)
  if valid_761275 != nil:
    section.add "id", valid_761275
  var valid_761276 = path.getOrDefault("sha")
  valid_761276 = validateParameter(valid_761276, JString, required = true,
                                 default = nil)
  if valid_761276 != nil:
    section.add "sha", valid_761276
  result.add "path", section
  ## parameters in `query` object:
  ##   filepath: JString (required)
  ##           : The path to the file to display
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `filepath` field"
  var valid_761277 = query.getOrDefault("filepath")
  valid_761277 = validateParameter(valid_761277, JString, required = true,
                                 default = nil)
  if valid_761277 != nil:
    section.add "filepath", valid_761277
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761278: Call_GetV3ProjectsIdRepositoryCommitsShaBlob_761272;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a raw file contents
  ## 
  let valid = call_761278.validator(path, query, header, formData, body)
  let scheme = call_761278.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761278.url(scheme.get, call_761278.host, call_761278.base,
                         call_761278.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761278, url, valid)

proc call*(call_761279: Call_GetV3ProjectsIdRepositoryCommitsShaBlob_761272;
          id: string; sha: string; filepath: string): Recallable =
  ## getV3ProjectsIdRepositoryCommitsShaBlob
  ## Get a raw file contents
  ##   id: string (required)
  ##     : The ID of a project
  ##   sha: string (required)
  ##      : The commit, branch name, or tag name
  ##   filepath: string (required)
  ##           : The path to the file to display
  var path_761280 = newJObject()
  var query_761281 = newJObject()
  add(path_761280, "id", newJString(id))
  add(path_761280, "sha", newJString(sha))
  add(query_761281, "filepath", newJString(filepath))
  result = call_761279.call(path_761280, query_761281, nil, nil, nil)

var getV3ProjectsIdRepositoryCommitsShaBlob* = Call_GetV3ProjectsIdRepositoryCommitsShaBlob_761272(
    name: "getV3ProjectsIdRepositoryCommitsShaBlob", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/commits/{sha}/blob",
    validator: validate_GetV3ProjectsIdRepositoryCommitsShaBlob_761273,
    base: "/api", url: url_GetV3ProjectsIdRepositoryCommitsShaBlob_761274,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryCommitsShaBuilds_761282 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryCommitsShaBuilds_761284(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/commits/"),
               (kind: VariableSegment, value: "sha"),
               (kind: ConstantSegment, value: "/builds")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryCommitsShaBuilds_761283(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get builds for a specific commit of a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : The SHA id of a commit
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761285 = path.getOrDefault("id")
  valid_761285 = validateParameter(valid_761285, JString, required = true,
                                 default = nil)
  if valid_761285 != nil:
    section.add "id", valid_761285
  var valid_761286 = path.getOrDefault("sha")
  valid_761286 = validateParameter(valid_761286, JString, required = true,
                                 default = nil)
  if valid_761286 != nil:
    section.add "sha", valid_761286
  result.add "path", section
  ## parameters in `query` object:
  ##   scope: JString
  ##        : The scope of builds to show
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_761287 = query.getOrDefault("scope")
  valid_761287 = validateParameter(valid_761287, JString, required = false,
                                 default = newJString("pending"))
  if valid_761287 != nil:
    section.add "scope", valid_761287
  var valid_761288 = query.getOrDefault("per_page")
  valid_761288 = validateParameter(valid_761288, JInt, required = false, default = nil)
  if valid_761288 != nil:
    section.add "per_page", valid_761288
  var valid_761289 = query.getOrDefault("page")
  valid_761289 = validateParameter(valid_761289, JInt, required = false, default = nil)
  if valid_761289 != nil:
    section.add "page", valid_761289
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761290: Call_GetV3ProjectsIdRepositoryCommitsShaBuilds_761282;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get builds for a specific commit of a project
  ## 
  let valid = call_761290.validator(path, query, header, formData, body)
  let scheme = call_761290.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761290.url(scheme.get, call_761290.host, call_761290.base,
                         call_761290.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761290, url, valid)

proc call*(call_761291: Call_GetV3ProjectsIdRepositoryCommitsShaBuilds_761282;
          id: string; sha: string; scope: string = "pending"; perPage: int = 0;
          page: int = 0): Recallable =
  ## getV3ProjectsIdRepositoryCommitsShaBuilds
  ## Get builds for a specific commit of a project
  ##   scope: string
  ##        : The scope of builds to show
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   sha: string (required)
  ##      : The SHA id of a commit
  var path_761292 = newJObject()
  var query_761293 = newJObject()
  add(query_761293, "scope", newJString(scope))
  add(path_761292, "id", newJString(id))
  add(query_761293, "per_page", newJInt(perPage))
  add(query_761293, "page", newJInt(page))
  add(path_761292, "sha", newJString(sha))
  result = call_761291.call(path_761292, query_761293, nil, nil, nil)

var getV3ProjectsIdRepositoryCommitsShaBuilds* = Call_GetV3ProjectsIdRepositoryCommitsShaBuilds_761282(
    name: "getV3ProjectsIdRepositoryCommitsShaBuilds", meth: HttpMethod.HttpGet,
    host: "gitlab.com",
    route: "/v3/projects/{id}/repository/commits/{sha}/builds",
    validator: validate_GetV3ProjectsIdRepositoryCommitsShaBuilds_761283,
    base: "/api", url: url_GetV3ProjectsIdRepositoryCommitsShaBuilds_761284,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdRepositoryCommitsShaCherryPick_761294 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdRepositoryCommitsShaCherryPick_761296(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/commits/"),
               (kind: VariableSegment, value: "sha"),
               (kind: ConstantSegment, value: "/cherry_pick")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdRepositoryCommitsShaCherryPick_761295(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : A commit sha to be cherry picked
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761297 = path.getOrDefault("id")
  valid_761297 = validateParameter(valid_761297, JString, required = true,
                                 default = nil)
  if valid_761297 != nil:
    section.add "id", valid_761297
  var valid_761298 = path.getOrDefault("sha")
  valid_761298 = validateParameter(valid_761298, JString, required = true,
                                 default = nil)
  if valid_761298 != nil:
    section.add "sha", valid_761298
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   branch: JString (required)
  ##         : The name of the branch
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `branch` field"
  var valid_761299 = formData.getOrDefault("branch")
  valid_761299 = validateParameter(valid_761299, JString, required = true,
                                 default = nil)
  if valid_761299 != nil:
    section.add "branch", valid_761299
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761300: Call_PostV3ProjectsIdRepositoryCommitsShaCherryPick_761294;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15
  ## 
  let valid = call_761300.validator(path, query, header, formData, body)
  let scheme = call_761300.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761300.url(scheme.get, call_761300.host, call_761300.base,
                         call_761300.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761300, url, valid)

proc call*(call_761301: Call_PostV3ProjectsIdRepositoryCommitsShaCherryPick_761294;
          branch: string; id: string; sha: string): Recallable =
  ## postV3ProjectsIdRepositoryCommitsShaCherryPick
  ## This feature was introduced in GitLab 8.15
  ##   branch: string (required)
  ##         : The name of the branch
  ##   id: string (required)
  ##     : The ID of a project
  ##   sha: string (required)
  ##      : A commit sha to be cherry picked
  var path_761302 = newJObject()
  var formData_761303 = newJObject()
  add(formData_761303, "branch", newJString(branch))
  add(path_761302, "id", newJString(id))
  add(path_761302, "sha", newJString(sha))
  result = call_761301.call(path_761302, nil, nil, formData_761303, nil)

var postV3ProjectsIdRepositoryCommitsShaCherryPick* = Call_PostV3ProjectsIdRepositoryCommitsShaCherryPick_761294(
    name: "postV3ProjectsIdRepositoryCommitsShaCherryPick",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/repository/commits/{sha}/cherry_pick",
    validator: validate_PostV3ProjectsIdRepositoryCommitsShaCherryPick_761295,
    base: "/api", url: url_PostV3ProjectsIdRepositoryCommitsShaCherryPick_761296,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdRepositoryCommitsShaComments_761315 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdRepositoryCommitsShaComments_761317(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/commits/"),
               (kind: VariableSegment, value: "sha"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdRepositoryCommitsShaComments_761316(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Post comment to commit
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : The commit's SHA
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761318 = path.getOrDefault("id")
  valid_761318 = validateParameter(valid_761318, JString, required = true,
                                 default = nil)
  if valid_761318 != nil:
    section.add "id", valid_761318
  var valid_761319 = path.getOrDefault("sha")
  valid_761319 = validateParameter(valid_761319, JString, required = true,
                                 default = nil)
  if valid_761319 != nil:
    section.add "sha", valid_761319
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   line_type: JString (required)
  ##            : The type of the line
  ##   path: JString
  ##       : The file path
  ##   note: JString (required)
  ##       : The text of the comment
  ##   line: JInt (required)
  ##       : The line number
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `line_type` field"
  var valid_761320 = formData.getOrDefault("line_type")
  valid_761320 = validateParameter(valid_761320, JString, required = true,
                                 default = newJString("new"))
  if valid_761320 != nil:
    section.add "line_type", valid_761320
  var valid_761321 = formData.getOrDefault("path")
  valid_761321 = validateParameter(valid_761321, JString, required = false,
                                 default = nil)
  if valid_761321 != nil:
    section.add "path", valid_761321
  var valid_761322 = formData.getOrDefault("note")
  valid_761322 = validateParameter(valid_761322, JString, required = true,
                                 default = nil)
  if valid_761322 != nil:
    section.add "note", valid_761322
  var valid_761323 = formData.getOrDefault("line")
  valid_761323 = validateParameter(valid_761323, JInt, required = true, default = nil)
  if valid_761323 != nil:
    section.add "line", valid_761323
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761324: Call_PostV3ProjectsIdRepositoryCommitsShaComments_761315;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Post comment to commit
  ## 
  let valid = call_761324.validator(path, query, header, formData, body)
  let scheme = call_761324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761324.url(scheme.get, call_761324.host, call_761324.base,
                         call_761324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761324, url, valid)

proc call*(call_761325: Call_PostV3ProjectsIdRepositoryCommitsShaComments_761315;
          id: string; note: string; line: int; sha: string; lineType: string = "new";
          path: string = ""): Recallable =
  ## postV3ProjectsIdRepositoryCommitsShaComments
  ## Post comment to commit
  ##   id: string (required)
  ##     : The ID of a project
  ##   lineType: string (required)
  ##           : The type of the line
  ##   path: string
  ##       : The file path
  ##   note: string (required)
  ##       : The text of the comment
  ##   line: int (required)
  ##       : The line number
  ##   sha: string (required)
  ##      : The commit's SHA
  var path_761326 = newJObject()
  var formData_761327 = newJObject()
  add(path_761326, "id", newJString(id))
  add(formData_761327, "line_type", newJString(lineType))
  add(formData_761327, "path", newJString(path))
  add(formData_761327, "note", newJString(note))
  add(formData_761327, "line", newJInt(line))
  add(path_761326, "sha", newJString(sha))
  result = call_761325.call(path_761326, nil, nil, formData_761327, nil)

var postV3ProjectsIdRepositoryCommitsShaComments* = Call_PostV3ProjectsIdRepositoryCommitsShaComments_761315(
    name: "postV3ProjectsIdRepositoryCommitsShaComments",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/repository/commits/{sha}/comments",
    validator: validate_PostV3ProjectsIdRepositoryCommitsShaComments_761316,
    base: "/api", url: url_PostV3ProjectsIdRepositoryCommitsShaComments_761317,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryCommitsShaComments_761304 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryCommitsShaComments_761306(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/commits/"),
               (kind: VariableSegment, value: "sha"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryCommitsShaComments_761305(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a commit's comments
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : A commit sha, or the name of a branch or tag
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761307 = path.getOrDefault("id")
  valid_761307 = validateParameter(valid_761307, JString, required = true,
                                 default = nil)
  if valid_761307 != nil:
    section.add "id", valid_761307
  var valid_761308 = path.getOrDefault("sha")
  valid_761308 = validateParameter(valid_761308, JString, required = true,
                                 default = nil)
  if valid_761308 != nil:
    section.add "sha", valid_761308
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_761309 = query.getOrDefault("per_page")
  valid_761309 = validateParameter(valid_761309, JInt, required = false, default = nil)
  if valid_761309 != nil:
    section.add "per_page", valid_761309
  var valid_761310 = query.getOrDefault("page")
  valid_761310 = validateParameter(valid_761310, JInt, required = false, default = nil)
  if valid_761310 != nil:
    section.add "page", valid_761310
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761311: Call_GetV3ProjectsIdRepositoryCommitsShaComments_761304;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a commit's comments
  ## 
  let valid = call_761311.validator(path, query, header, formData, body)
  let scheme = call_761311.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761311.url(scheme.get, call_761311.host, call_761311.base,
                         call_761311.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761311, url, valid)

proc call*(call_761312: Call_GetV3ProjectsIdRepositoryCommitsShaComments_761304;
          id: string; sha: string; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdRepositoryCommitsShaComments
  ## Get a commit's comments
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   sha: string (required)
  ##      : A commit sha, or the name of a branch or tag
  var path_761313 = newJObject()
  var query_761314 = newJObject()
  add(path_761313, "id", newJString(id))
  add(query_761314, "per_page", newJInt(perPage))
  add(query_761314, "page", newJInt(page))
  add(path_761313, "sha", newJString(sha))
  result = call_761312.call(path_761313, query_761314, nil, nil, nil)

var getV3ProjectsIdRepositoryCommitsShaComments* = Call_GetV3ProjectsIdRepositoryCommitsShaComments_761304(
    name: "getV3ProjectsIdRepositoryCommitsShaComments", meth: HttpMethod.HttpGet,
    host: "gitlab.com",
    route: "/v3/projects/{id}/repository/commits/{sha}/comments",
    validator: validate_GetV3ProjectsIdRepositoryCommitsShaComments_761305,
    base: "/api", url: url_GetV3ProjectsIdRepositoryCommitsShaComments_761306,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryCommitsShaDiff_761328 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryCommitsShaDiff_761330(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/commits/"),
               (kind: VariableSegment, value: "sha"),
               (kind: ConstantSegment, value: "/diff")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryCommitsShaDiff_761329(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the diff for a specific commit of a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : A commit sha, or the name of a branch or tag
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761331 = path.getOrDefault("id")
  valid_761331 = validateParameter(valid_761331, JString, required = true,
                                 default = nil)
  if valid_761331 != nil:
    section.add "id", valid_761331
  var valid_761332 = path.getOrDefault("sha")
  valid_761332 = validateParameter(valid_761332, JString, required = true,
                                 default = nil)
  if valid_761332 != nil:
    section.add "sha", valid_761332
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761333: Call_GetV3ProjectsIdRepositoryCommitsShaDiff_761328;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the diff for a specific commit of a project
  ## 
  let valid = call_761333.validator(path, query, header, formData, body)
  let scheme = call_761333.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761333.url(scheme.get, call_761333.host, call_761333.base,
                         call_761333.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761333, url, valid)

proc call*(call_761334: Call_GetV3ProjectsIdRepositoryCommitsShaDiff_761328;
          id: string; sha: string): Recallable =
  ## getV3ProjectsIdRepositoryCommitsShaDiff
  ## Get the diff for a specific commit of a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   sha: string (required)
  ##      : A commit sha, or the name of a branch or tag
  var path_761335 = newJObject()
  add(path_761335, "id", newJString(id))
  add(path_761335, "sha", newJString(sha))
  result = call_761334.call(path_761335, nil, nil, nil, nil)

var getV3ProjectsIdRepositoryCommitsShaDiff* = Call_GetV3ProjectsIdRepositoryCommitsShaDiff_761328(
    name: "getV3ProjectsIdRepositoryCommitsShaDiff", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/commits/{sha}/diff",
    validator: validate_GetV3ProjectsIdRepositoryCommitsShaDiff_761329,
    base: "/api", url: url_GetV3ProjectsIdRepositoryCommitsShaDiff_761330,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryCommitsShaStatuses_761336 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryCommitsShaStatuses_761338(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/commits/"),
               (kind: VariableSegment, value: "sha"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryCommitsShaStatuses_761337(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a commit's statuses
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : The commit hash
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761339 = path.getOrDefault("id")
  valid_761339 = validateParameter(valid_761339, JString, required = true,
                                 default = nil)
  if valid_761339 != nil:
    section.add "id", valid_761339
  var valid_761340 = path.getOrDefault("sha")
  valid_761340 = validateParameter(valid_761340, JString, required = true,
                                 default = nil)
  if valid_761340 != nil:
    section.add "sha", valid_761340
  result.add "path", section
  ## parameters in `query` object:
  ##   name: JString
  ##       : The name
  ##   all: JString
  ##      : Show all statuses, default: false
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   stage: JString
  ##        : The stage
  ##   ref: JString
  ##      : The ref
  section = newJObject()
  var valid_761341 = query.getOrDefault("name")
  valid_761341 = validateParameter(valid_761341, JString, required = false,
                                 default = nil)
  if valid_761341 != nil:
    section.add "name", valid_761341
  var valid_761342 = query.getOrDefault("all")
  valid_761342 = validateParameter(valid_761342, JString, required = false,
                                 default = nil)
  if valid_761342 != nil:
    section.add "all", valid_761342
  var valid_761343 = query.getOrDefault("per_page")
  valid_761343 = validateParameter(valid_761343, JInt, required = false, default = nil)
  if valid_761343 != nil:
    section.add "per_page", valid_761343
  var valid_761344 = query.getOrDefault("page")
  valid_761344 = validateParameter(valid_761344, JInt, required = false, default = nil)
  if valid_761344 != nil:
    section.add "page", valid_761344
  var valid_761345 = query.getOrDefault("stage")
  valid_761345 = validateParameter(valid_761345, JString, required = false,
                                 default = nil)
  if valid_761345 != nil:
    section.add "stage", valid_761345
  var valid_761346 = query.getOrDefault("ref")
  valid_761346 = validateParameter(valid_761346, JString, required = false,
                                 default = nil)
  if valid_761346 != nil:
    section.add "ref", valid_761346
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761347: Call_GetV3ProjectsIdRepositoryCommitsShaStatuses_761336;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a commit's statuses
  ## 
  let valid = call_761347.validator(path, query, header, formData, body)
  let scheme = call_761347.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761347.url(scheme.get, call_761347.host, call_761347.base,
                         call_761347.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761347, url, valid)

proc call*(call_761348: Call_GetV3ProjectsIdRepositoryCommitsShaStatuses_761336;
          id: string; sha: string; name: string = ""; all: string = ""; perPage: int = 0;
          page: int = 0; stage: string = ""; `ref`: string = ""): Recallable =
  ## getV3ProjectsIdRepositoryCommitsShaStatuses
  ## Get a commit's statuses
  ##   name: string
  ##       : The name
  ##   all: string
  ##      : Show all statuses, default: false
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   stage: string
  ##        : The stage
  ##   sha: string (required)
  ##      : The commit hash
  ##   ref: string
  ##      : The ref
  var path_761349 = newJObject()
  var query_761350 = newJObject()
  add(query_761350, "name", newJString(name))
  add(query_761350, "all", newJString(all))
  add(path_761349, "id", newJString(id))
  add(query_761350, "per_page", newJInt(perPage))
  add(query_761350, "page", newJInt(page))
  add(query_761350, "stage", newJString(stage))
  add(path_761349, "sha", newJString(sha))
  add(query_761350, "ref", newJString(`ref`))
  result = call_761348.call(path_761349, query_761350, nil, nil, nil)

var getV3ProjectsIdRepositoryCommitsShaStatuses* = Call_GetV3ProjectsIdRepositoryCommitsShaStatuses_761336(
    name: "getV3ProjectsIdRepositoryCommitsShaStatuses", meth: HttpMethod.HttpGet,
    host: "gitlab.com",
    route: "/v3/projects/{id}/repository/commits/{sha}/statuses",
    validator: validate_GetV3ProjectsIdRepositoryCommitsShaStatuses_761337,
    base: "/api", url: url_GetV3ProjectsIdRepositoryCommitsShaStatuses_761338,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryCompare_761351 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryCompare_761353(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/compare")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryCompare_761352(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Compare two branches, tags, or commits
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761354 = path.getOrDefault("id")
  valid_761354 = validateParameter(valid_761354, JString, required = true,
                                 default = nil)
  if valid_761354 != nil:
    section.add "id", valid_761354
  result.add "path", section
  ## parameters in `query` object:
  ##   to: JString (required)
  ##     : The commit, branch name, or tag name to stop comparison
  ##   from: JString (required)
  ##       : The commit, branch name, or tag name to start comparison
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `to` field"
  var valid_761355 = query.getOrDefault("to")
  valid_761355 = validateParameter(valid_761355, JString, required = true,
                                 default = nil)
  if valid_761355 != nil:
    section.add "to", valid_761355
  var valid_761356 = query.getOrDefault("from")
  valid_761356 = validateParameter(valid_761356, JString, required = true,
                                 default = nil)
  if valid_761356 != nil:
    section.add "from", valid_761356
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761357: Call_GetV3ProjectsIdRepositoryCompare_761351;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Compare two branches, tags, or commits
  ## 
  let valid = call_761357.validator(path, query, header, formData, body)
  let scheme = call_761357.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761357.url(scheme.get, call_761357.host, call_761357.base,
                         call_761357.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761357, url, valid)

proc call*(call_761358: Call_GetV3ProjectsIdRepositoryCompare_761351; id: string;
          to: string; `from`: string): Recallable =
  ## getV3ProjectsIdRepositoryCompare
  ## Compare two branches, tags, or commits
  ##   id: string (required)
  ##     : The ID of a project
  ##   to: string (required)
  ##     : The commit, branch name, or tag name to stop comparison
  ##   from: string (required)
  ##       : The commit, branch name, or tag name to start comparison
  var path_761359 = newJObject()
  var query_761360 = newJObject()
  add(path_761359, "id", newJString(id))
  add(query_761360, "to", newJString(to))
  add(query_761360, "from", newJString(`from`))
  result = call_761358.call(path_761359, query_761360, nil, nil, nil)

var getV3ProjectsIdRepositoryCompare* = Call_GetV3ProjectsIdRepositoryCompare_761351(
    name: "getV3ProjectsIdRepositoryCompare", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/compare",
    validator: validate_GetV3ProjectsIdRepositoryCompare_761352, base: "/api",
    url: url_GetV3ProjectsIdRepositoryCompare_761353, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryContributors_761361 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryContributors_761363(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryContributors_761362(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get repository contributors
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761364 = path.getOrDefault("id")
  valid_761364 = validateParameter(valid_761364, JString, required = true,
                                 default = nil)
  if valid_761364 != nil:
    section.add "id", valid_761364
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761365: Call_GetV3ProjectsIdRepositoryContributors_761361;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get repository contributors
  ## 
  let valid = call_761365.validator(path, query, header, formData, body)
  let scheme = call_761365.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761365.url(scheme.get, call_761365.host, call_761365.base,
                         call_761365.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761365, url, valid)

proc call*(call_761366: Call_GetV3ProjectsIdRepositoryContributors_761361;
          id: string): Recallable =
  ## getV3ProjectsIdRepositoryContributors
  ## Get repository contributors
  ##   id: string (required)
  ##     : The ID of a project
  var path_761367 = newJObject()
  add(path_761367, "id", newJString(id))
  result = call_761366.call(path_761367, nil, nil, nil, nil)

var getV3ProjectsIdRepositoryContributors* = Call_GetV3ProjectsIdRepositoryContributors_761361(
    name: "getV3ProjectsIdRepositoryContributors", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/contributors",
    validator: validate_GetV3ProjectsIdRepositoryContributors_761362,
    base: "/api", url: url_GetV3ProjectsIdRepositoryContributors_761363,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdRepositoryFiles_761378 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdRepositoryFiles_761380(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdRepositoryFiles_761379(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update existing file in repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761381 = path.getOrDefault("id")
  valid_761381 = validateParameter(valid_761381, JString, required = true,
                                 default = nil)
  if valid_761381 != nil:
    section.add "id", valid_761381
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   content: JString (required)
  ##          : File content
  ##   author_name: JString
  ##              : The name of the author
  ##   branch_name: JString (required)
  ##              : The name of branch
  ##   file_path: JString (required)
  ##            : The path to new file. Ex. lib/class.rb
  ##   encoding: JString
  ##           : File encoding
  ##   commit_message: JString (required)
  ##                 : Commit Message
  ##   author_email: JString
  ##               : The email of the author
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `content` field"
  var valid_761382 = formData.getOrDefault("content")
  valid_761382 = validateParameter(valid_761382, JString, required = true,
                                 default = nil)
  if valid_761382 != nil:
    section.add "content", valid_761382
  var valid_761383 = formData.getOrDefault("author_name")
  valid_761383 = validateParameter(valid_761383, JString, required = false,
                                 default = nil)
  if valid_761383 != nil:
    section.add "author_name", valid_761383
  var valid_761384 = formData.getOrDefault("branch_name")
  valid_761384 = validateParameter(valid_761384, JString, required = true,
                                 default = nil)
  if valid_761384 != nil:
    section.add "branch_name", valid_761384
  var valid_761385 = formData.getOrDefault("file_path")
  valid_761385 = validateParameter(valid_761385, JString, required = true,
                                 default = nil)
  if valid_761385 != nil:
    section.add "file_path", valid_761385
  var valid_761386 = formData.getOrDefault("encoding")
  valid_761386 = validateParameter(valid_761386, JString, required = false,
                                 default = newJString("base64"))
  if valid_761386 != nil:
    section.add "encoding", valid_761386
  var valid_761387 = formData.getOrDefault("commit_message")
  valid_761387 = validateParameter(valid_761387, JString, required = true,
                                 default = nil)
  if valid_761387 != nil:
    section.add "commit_message", valid_761387
  var valid_761388 = formData.getOrDefault("author_email")
  valid_761388 = validateParameter(valid_761388, JString, required = false,
                                 default = nil)
  if valid_761388 != nil:
    section.add "author_email", valid_761388
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761389: Call_PutV3ProjectsIdRepositoryFiles_761378; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update existing file in repository
  ## 
  let valid = call_761389.validator(path, query, header, formData, body)
  let scheme = call_761389.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761389.url(scheme.get, call_761389.host, call_761389.base,
                         call_761389.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761389, url, valid)

proc call*(call_761390: Call_PutV3ProjectsIdRepositoryFiles_761378;
          content: string; id: string; branchName: string; filePath: string;
          commitMessage: string; authorName: string = ""; encoding: string = "base64";
          authorEmail: string = ""): Recallable =
  ## putV3ProjectsIdRepositoryFiles
  ## Update existing file in repository
  ##   content: string (required)
  ##          : File content
  ##   id: string (required)
  ##     : The project ID
  ##   authorName: string
  ##             : The name of the author
  ##   branchName: string (required)
  ##             : The name of branch
  ##   filePath: string (required)
  ##           : The path to new file. Ex. lib/class.rb
  ##   encoding: string
  ##           : File encoding
  ##   commitMessage: string (required)
  ##                : Commit Message
  ##   authorEmail: string
  ##              : The email of the author
  var path_761391 = newJObject()
  var formData_761392 = newJObject()
  add(formData_761392, "content", newJString(content))
  add(path_761391, "id", newJString(id))
  add(formData_761392, "author_name", newJString(authorName))
  add(formData_761392, "branch_name", newJString(branchName))
  add(formData_761392, "file_path", newJString(filePath))
  add(formData_761392, "encoding", newJString(encoding))
  add(formData_761392, "commit_message", newJString(commitMessage))
  add(formData_761392, "author_email", newJString(authorEmail))
  result = call_761390.call(path_761391, nil, nil, formData_761392, nil)

var putV3ProjectsIdRepositoryFiles* = Call_PutV3ProjectsIdRepositoryFiles_761378(
    name: "putV3ProjectsIdRepositoryFiles", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/files",
    validator: validate_PutV3ProjectsIdRepositoryFiles_761379, base: "/api",
    url: url_PutV3ProjectsIdRepositoryFiles_761380, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdRepositoryFiles_761393 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdRepositoryFiles_761395(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdRepositoryFiles_761394(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create new file in repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761396 = path.getOrDefault("id")
  valid_761396 = validateParameter(valid_761396, JString, required = true,
                                 default = nil)
  if valid_761396 != nil:
    section.add "id", valid_761396
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   content: JString (required)
  ##          : File content
  ##   author_name: JString
  ##              : The name of the author
  ##   branch_name: JString (required)
  ##              : The name of branch
  ##   file_path: JString (required)
  ##            : The path to new file. Ex. lib/class.rb
  ##   encoding: JString
  ##           : File encoding
  ##   commit_message: JString (required)
  ##                 : Commit Message
  ##   author_email: JString
  ##               : The email of the author
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `content` field"
  var valid_761397 = formData.getOrDefault("content")
  valid_761397 = validateParameter(valid_761397, JString, required = true,
                                 default = nil)
  if valid_761397 != nil:
    section.add "content", valid_761397
  var valid_761398 = formData.getOrDefault("author_name")
  valid_761398 = validateParameter(valid_761398, JString, required = false,
                                 default = nil)
  if valid_761398 != nil:
    section.add "author_name", valid_761398
  var valid_761399 = formData.getOrDefault("branch_name")
  valid_761399 = validateParameter(valid_761399, JString, required = true,
                                 default = nil)
  if valid_761399 != nil:
    section.add "branch_name", valid_761399
  var valid_761400 = formData.getOrDefault("file_path")
  valid_761400 = validateParameter(valid_761400, JString, required = true,
                                 default = nil)
  if valid_761400 != nil:
    section.add "file_path", valid_761400
  var valid_761401 = formData.getOrDefault("encoding")
  valid_761401 = validateParameter(valid_761401, JString, required = false,
                                 default = newJString("base64"))
  if valid_761401 != nil:
    section.add "encoding", valid_761401
  var valid_761402 = formData.getOrDefault("commit_message")
  valid_761402 = validateParameter(valid_761402, JString, required = true,
                                 default = nil)
  if valid_761402 != nil:
    section.add "commit_message", valid_761402
  var valid_761403 = formData.getOrDefault("author_email")
  valid_761403 = validateParameter(valid_761403, JString, required = false,
                                 default = nil)
  if valid_761403 != nil:
    section.add "author_email", valid_761403
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761404: Call_PostV3ProjectsIdRepositoryFiles_761393;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create new file in repository
  ## 
  let valid = call_761404.validator(path, query, header, formData, body)
  let scheme = call_761404.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761404.url(scheme.get, call_761404.host, call_761404.base,
                         call_761404.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761404, url, valid)

proc call*(call_761405: Call_PostV3ProjectsIdRepositoryFiles_761393;
          content: string; id: string; branchName: string; filePath: string;
          commitMessage: string; authorName: string = ""; encoding: string = "base64";
          authorEmail: string = ""): Recallable =
  ## postV3ProjectsIdRepositoryFiles
  ## Create new file in repository
  ##   content: string (required)
  ##          : File content
  ##   id: string (required)
  ##     : The project ID
  ##   authorName: string
  ##             : The name of the author
  ##   branchName: string (required)
  ##             : The name of branch
  ##   filePath: string (required)
  ##           : The path to new file. Ex. lib/class.rb
  ##   encoding: string
  ##           : File encoding
  ##   commitMessage: string (required)
  ##                : Commit Message
  ##   authorEmail: string
  ##              : The email of the author
  var path_761406 = newJObject()
  var formData_761407 = newJObject()
  add(formData_761407, "content", newJString(content))
  add(path_761406, "id", newJString(id))
  add(formData_761407, "author_name", newJString(authorName))
  add(formData_761407, "branch_name", newJString(branchName))
  add(formData_761407, "file_path", newJString(filePath))
  add(formData_761407, "encoding", newJString(encoding))
  add(formData_761407, "commit_message", newJString(commitMessage))
  add(formData_761407, "author_email", newJString(authorEmail))
  result = call_761405.call(path_761406, nil, nil, formData_761407, nil)

var postV3ProjectsIdRepositoryFiles* = Call_PostV3ProjectsIdRepositoryFiles_761393(
    name: "postV3ProjectsIdRepositoryFiles", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/files",
    validator: validate_PostV3ProjectsIdRepositoryFiles_761394, base: "/api",
    url: url_PostV3ProjectsIdRepositoryFiles_761395, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryFiles_761368 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryFiles_761370(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryFiles_761369(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a file from repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761371 = path.getOrDefault("id")
  valid_761371 = validateParameter(valid_761371, JString, required = true,
                                 default = nil)
  if valid_761371 != nil:
    section.add "id", valid_761371
  result.add "path", section
  ## parameters in `query` object:
  ##   file_path: JString (required)
  ##            : The path to the file. Ex. lib/class.rb
  ##   ref: JString (required)
  ##      : The name of branch, tag, or commit
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `file_path` field"
  var valid_761372 = query.getOrDefault("file_path")
  valid_761372 = validateParameter(valid_761372, JString, required = true,
                                 default = nil)
  if valid_761372 != nil:
    section.add "file_path", valid_761372
  var valid_761373 = query.getOrDefault("ref")
  valid_761373 = validateParameter(valid_761373, JString, required = true,
                                 default = nil)
  if valid_761373 != nil:
    section.add "ref", valid_761373
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761374: Call_GetV3ProjectsIdRepositoryFiles_761368; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a file from repository
  ## 
  let valid = call_761374.validator(path, query, header, formData, body)
  let scheme = call_761374.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761374.url(scheme.get, call_761374.host, call_761374.base,
                         call_761374.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761374, url, valid)

proc call*(call_761375: Call_GetV3ProjectsIdRepositoryFiles_761368;
          filePath: string; id: string; `ref`: string): Recallable =
  ## getV3ProjectsIdRepositoryFiles
  ## Get a file from repository
  ##   filePath: string (required)
  ##           : The path to the file. Ex. lib/class.rb
  ##   id: string (required)
  ##     : The project ID
  ##   ref: string (required)
  ##      : The name of branch, tag, or commit
  var path_761376 = newJObject()
  var query_761377 = newJObject()
  add(query_761377, "file_path", newJString(filePath))
  add(path_761376, "id", newJString(id))
  add(query_761377, "ref", newJString(`ref`))
  result = call_761375.call(path_761376, query_761377, nil, nil, nil)

var getV3ProjectsIdRepositoryFiles* = Call_GetV3ProjectsIdRepositoryFiles_761368(
    name: "getV3ProjectsIdRepositoryFiles", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/files",
    validator: validate_GetV3ProjectsIdRepositoryFiles_761369, base: "/api",
    url: url_GetV3ProjectsIdRepositoryFiles_761370, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdRepositoryFiles_761408 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdRepositoryFiles_761410(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdRepositoryFiles_761409(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete an existing file in repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The project ID
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761411 = path.getOrDefault("id")
  valid_761411 = validateParameter(valid_761411, JString, required = true,
                                 default = nil)
  if valid_761411 != nil:
    section.add "id", valid_761411
  result.add "path", section
  ## parameters in `query` object:
  ##   file_path: JString (required)
  ##            : The path to new file. Ex. lib/class.rb
  ##   author_name: JString
  ##              : The name of the author
  ##   commit_message: JString (required)
  ##                 : Commit Message
  ##   branch_name: JString (required)
  ##              : The name of branch
  ##   author_email: JString
  ##               : The email of the author
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `file_path` field"
  var valid_761412 = query.getOrDefault("file_path")
  valid_761412 = validateParameter(valid_761412, JString, required = true,
                                 default = nil)
  if valid_761412 != nil:
    section.add "file_path", valid_761412
  var valid_761413 = query.getOrDefault("author_name")
  valid_761413 = validateParameter(valid_761413, JString, required = false,
                                 default = nil)
  if valid_761413 != nil:
    section.add "author_name", valid_761413
  var valid_761414 = query.getOrDefault("commit_message")
  valid_761414 = validateParameter(valid_761414, JString, required = true,
                                 default = nil)
  if valid_761414 != nil:
    section.add "commit_message", valid_761414
  var valid_761415 = query.getOrDefault("branch_name")
  valid_761415 = validateParameter(valid_761415, JString, required = true,
                                 default = nil)
  if valid_761415 != nil:
    section.add "branch_name", valid_761415
  var valid_761416 = query.getOrDefault("author_email")
  valid_761416 = validateParameter(valid_761416, JString, required = false,
                                 default = nil)
  if valid_761416 != nil:
    section.add "author_email", valid_761416
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761417: Call_DeleteV3ProjectsIdRepositoryFiles_761408;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete an existing file in repository
  ## 
  let valid = call_761417.validator(path, query, header, formData, body)
  let scheme = call_761417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761417.url(scheme.get, call_761417.host, call_761417.base,
                         call_761417.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761417, url, valid)

proc call*(call_761418: Call_DeleteV3ProjectsIdRepositoryFiles_761408;
          filePath: string; id: string; commitMessage: string; branchName: string;
          authorName: string = ""; authorEmail: string = ""): Recallable =
  ## deleteV3ProjectsIdRepositoryFiles
  ## Delete an existing file in repository
  ##   filePath: string (required)
  ##           : The path to new file. Ex. lib/class.rb
  ##   authorName: string
  ##             : The name of the author
  ##   id: string (required)
  ##     : The project ID
  ##   commitMessage: string (required)
  ##                : Commit Message
  ##   branchName: string (required)
  ##             : The name of branch
  ##   authorEmail: string
  ##              : The email of the author
  var path_761419 = newJObject()
  var query_761420 = newJObject()
  add(query_761420, "file_path", newJString(filePath))
  add(query_761420, "author_name", newJString(authorName))
  add(path_761419, "id", newJString(id))
  add(query_761420, "commit_message", newJString(commitMessage))
  add(query_761420, "branch_name", newJString(branchName))
  add(query_761420, "author_email", newJString(authorEmail))
  result = call_761418.call(path_761419, query_761420, nil, nil, nil)

var deleteV3ProjectsIdRepositoryFiles* = Call_DeleteV3ProjectsIdRepositoryFiles_761408(
    name: "deleteV3ProjectsIdRepositoryFiles", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/files",
    validator: validate_DeleteV3ProjectsIdRepositoryFiles_761409, base: "/api",
    url: url_DeleteV3ProjectsIdRepositoryFiles_761410, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdRepositoryMergedBranches_761421 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdRepositoryMergedBranches_761423(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/merged_branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdRepositoryMergedBranches_761422(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761424 = path.getOrDefault("id")
  valid_761424 = validateParameter(valid_761424, JString, required = true,
                                 default = nil)
  if valid_761424 != nil:
    section.add "id", valid_761424
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761425: Call_DeleteV3ProjectsIdRepositoryMergedBranches_761421;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  let valid = call_761425.validator(path, query, header, formData, body)
  let scheme = call_761425.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761425.url(scheme.get, call_761425.host, call_761425.base,
                         call_761425.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761425, url, valid)

proc call*(call_761426: Call_DeleteV3ProjectsIdRepositoryMergedBranches_761421;
          id: string): Recallable =
  ## deleteV3ProjectsIdRepositoryMergedBranches
  ##   id: string (required)
  ##     : The ID of a project
  var path_761427 = newJObject()
  add(path_761427, "id", newJString(id))
  result = call_761426.call(path_761427, nil, nil, nil, nil)

var deleteV3ProjectsIdRepositoryMergedBranches* = Call_DeleteV3ProjectsIdRepositoryMergedBranches_761421(
    name: "deleteV3ProjectsIdRepositoryMergedBranches",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/repository/merged_branches",
    validator: validate_DeleteV3ProjectsIdRepositoryMergedBranches_761422,
    base: "/api", url: url_DeleteV3ProjectsIdRepositoryMergedBranches_761423,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryRawBlobsSha_761428 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryRawBlobsSha_761430(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/raw_blobs/"),
               (kind: VariableSegment, value: "sha")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryRawBlobsSha_761429(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a raw blob contents by blob sha
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : The commit, branch name, or tag name
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761431 = path.getOrDefault("id")
  valid_761431 = validateParameter(valid_761431, JString, required = true,
                                 default = nil)
  if valid_761431 != nil:
    section.add "id", valid_761431
  var valid_761432 = path.getOrDefault("sha")
  valid_761432 = validateParameter(valid_761432, JString, required = true,
                                 default = nil)
  if valid_761432 != nil:
    section.add "sha", valid_761432
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761433: Call_GetV3ProjectsIdRepositoryRawBlobsSha_761428;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a raw blob contents by blob sha
  ## 
  let valid = call_761433.validator(path, query, header, formData, body)
  let scheme = call_761433.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761433.url(scheme.get, call_761433.host, call_761433.base,
                         call_761433.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761433, url, valid)

proc call*(call_761434: Call_GetV3ProjectsIdRepositoryRawBlobsSha_761428;
          id: string; sha: string): Recallable =
  ## getV3ProjectsIdRepositoryRawBlobsSha
  ## Get a raw blob contents by blob sha
  ##   id: string (required)
  ##     : The ID of a project
  ##   sha: string (required)
  ##      : The commit, branch name, or tag name
  var path_761435 = newJObject()
  add(path_761435, "id", newJString(id))
  add(path_761435, "sha", newJString(sha))
  result = call_761434.call(path_761435, nil, nil, nil, nil)

var getV3ProjectsIdRepositoryRawBlobsSha* = Call_GetV3ProjectsIdRepositoryRawBlobsSha_761428(
    name: "getV3ProjectsIdRepositoryRawBlobsSha", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/raw_blobs/{sha}",
    validator: validate_GetV3ProjectsIdRepositoryRawBlobsSha_761429, base: "/api",
    url: url_GetV3ProjectsIdRepositoryRawBlobsSha_761430, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdRepositoryTags_761443 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdRepositoryTags_761445(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdRepositoryTags_761444(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new repository tag
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761446 = path.getOrDefault("id")
  valid_761446 = validateParameter(valid_761446, JString, required = true,
                                 default = nil)
  if valid_761446 != nil:
    section.add "id", valid_761446
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   ref: JString (required)
  ##      : The commit sha or branch name
  ##   release_description: JString
  ##                      : Specifying release notes stored in the GitLab database
  ##   message: JString
  ##          : Specifying a message creates an annotated tag
  ##   tag_name: JString (required)
  ##           : The name of the tag
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ref` field"
  var valid_761447 = formData.getOrDefault("ref")
  valid_761447 = validateParameter(valid_761447, JString, required = true,
                                 default = nil)
  if valid_761447 != nil:
    section.add "ref", valid_761447
  var valid_761448 = formData.getOrDefault("release_description")
  valid_761448 = validateParameter(valid_761448, JString, required = false,
                                 default = nil)
  if valid_761448 != nil:
    section.add "release_description", valid_761448
  var valid_761449 = formData.getOrDefault("message")
  valid_761449 = validateParameter(valid_761449, JString, required = false,
                                 default = nil)
  if valid_761449 != nil:
    section.add "message", valid_761449
  var valid_761450 = formData.getOrDefault("tag_name")
  valid_761450 = validateParameter(valid_761450, JString, required = true,
                                 default = nil)
  if valid_761450 != nil:
    section.add "tag_name", valid_761450
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761451: Call_PostV3ProjectsIdRepositoryTags_761443; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new repository tag
  ## 
  let valid = call_761451.validator(path, query, header, formData, body)
  let scheme = call_761451.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761451.url(scheme.get, call_761451.host, call_761451.base,
                         call_761451.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761451, url, valid)

proc call*(call_761452: Call_PostV3ProjectsIdRepositoryTags_761443; `ref`: string;
          id: string; tagName: string; releaseDescription: string = "";
          message: string = ""): Recallable =
  ## postV3ProjectsIdRepositoryTags
  ## Create a new repository tag
  ##   ref: string (required)
  ##      : The commit sha or branch name
  ##   id: string (required)
  ##     : The ID of a project
  ##   releaseDescription: string
  ##                     : Specifying release notes stored in the GitLab database
  ##   message: string
  ##          : Specifying a message creates an annotated tag
  ##   tagName: string (required)
  ##          : The name of the tag
  var path_761453 = newJObject()
  var formData_761454 = newJObject()
  add(formData_761454, "ref", newJString(`ref`))
  add(path_761453, "id", newJString(id))
  add(formData_761454, "release_description", newJString(releaseDescription))
  add(formData_761454, "message", newJString(message))
  add(formData_761454, "tag_name", newJString(tagName))
  result = call_761452.call(path_761453, nil, nil, formData_761454, nil)

var postV3ProjectsIdRepositoryTags* = Call_PostV3ProjectsIdRepositoryTags_761443(
    name: "postV3ProjectsIdRepositoryTags", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/tags",
    validator: validate_PostV3ProjectsIdRepositoryTags_761444, base: "/api",
    url: url_PostV3ProjectsIdRepositoryTags_761445, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryTags_761436 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryTags_761438(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryTags_761437(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a project repository tags
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761439 = path.getOrDefault("id")
  valid_761439 = validateParameter(valid_761439, JString, required = true,
                                 default = nil)
  if valid_761439 != nil:
    section.add "id", valid_761439
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761440: Call_GetV3ProjectsIdRepositoryTags_761436; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a project repository tags
  ## 
  let valid = call_761440.validator(path, query, header, formData, body)
  let scheme = call_761440.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761440.url(scheme.get, call_761440.host, call_761440.base,
                         call_761440.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761440, url, valid)

proc call*(call_761441: Call_GetV3ProjectsIdRepositoryTags_761436; id: string): Recallable =
  ## getV3ProjectsIdRepositoryTags
  ## Get a project repository tags
  ##   id: string (required)
  ##     : The ID of a project
  var path_761442 = newJObject()
  add(path_761442, "id", newJString(id))
  result = call_761441.call(path_761442, nil, nil, nil, nil)

var getV3ProjectsIdRepositoryTags* = Call_GetV3ProjectsIdRepositoryTags_761436(
    name: "getV3ProjectsIdRepositoryTags", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/tags",
    validator: validate_GetV3ProjectsIdRepositoryTags_761437, base: "/api",
    url: url_GetV3ProjectsIdRepositoryTags_761438, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryTagsTagName_761455 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryTagsTagName_761457(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "tag_name" in path, "`tag_name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/tags/"),
               (kind: VariableSegment, value: "tag_name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryTagsTagName_761456(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single repository tag
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   tag_name: JString (required)
  ##           : The name of the tag
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761458 = path.getOrDefault("id")
  valid_761458 = validateParameter(valid_761458, JString, required = true,
                                 default = nil)
  if valid_761458 != nil:
    section.add "id", valid_761458
  var valid_761459 = path.getOrDefault("tag_name")
  valid_761459 = validateParameter(valid_761459, JString, required = true,
                                 default = nil)
  if valid_761459 != nil:
    section.add "tag_name", valid_761459
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761460: Call_GetV3ProjectsIdRepositoryTagsTagName_761455;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single repository tag
  ## 
  let valid = call_761460.validator(path, query, header, formData, body)
  let scheme = call_761460.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761460.url(scheme.get, call_761460.host, call_761460.base,
                         call_761460.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761460, url, valid)

proc call*(call_761461: Call_GetV3ProjectsIdRepositoryTagsTagName_761455;
          id: string; tagName: string): Recallable =
  ## getV3ProjectsIdRepositoryTagsTagName
  ## Get a single repository tag
  ##   id: string (required)
  ##     : The ID of a project
  ##   tagName: string (required)
  ##          : The name of the tag
  var path_761462 = newJObject()
  add(path_761462, "id", newJString(id))
  add(path_761462, "tag_name", newJString(tagName))
  result = call_761461.call(path_761462, nil, nil, nil, nil)

var getV3ProjectsIdRepositoryTagsTagName* = Call_GetV3ProjectsIdRepositoryTagsTagName_761455(
    name: "getV3ProjectsIdRepositoryTagsTagName", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/tags/{tag_name}",
    validator: validate_GetV3ProjectsIdRepositoryTagsTagName_761456, base: "/api",
    url: url_GetV3ProjectsIdRepositoryTagsTagName_761457, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdRepositoryTagsTagName_761463 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdRepositoryTagsTagName_761465(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "tag_name" in path, "`tag_name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/tags/"),
               (kind: VariableSegment, value: "tag_name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdRepositoryTagsTagName_761464(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a repository tag
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   tag_name: JString (required)
  ##           : The name of the tag
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761466 = path.getOrDefault("id")
  valid_761466 = validateParameter(valid_761466, JString, required = true,
                                 default = nil)
  if valid_761466 != nil:
    section.add "id", valid_761466
  var valid_761467 = path.getOrDefault("tag_name")
  valid_761467 = validateParameter(valid_761467, JString, required = true,
                                 default = nil)
  if valid_761467 != nil:
    section.add "tag_name", valid_761467
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761468: Call_DeleteV3ProjectsIdRepositoryTagsTagName_761463;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a repository tag
  ## 
  let valid = call_761468.validator(path, query, header, formData, body)
  let scheme = call_761468.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761468.url(scheme.get, call_761468.host, call_761468.base,
                         call_761468.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761468, url, valid)

proc call*(call_761469: Call_DeleteV3ProjectsIdRepositoryTagsTagName_761463;
          id: string; tagName: string): Recallable =
  ## deleteV3ProjectsIdRepositoryTagsTagName
  ## Delete a repository tag
  ##   id: string (required)
  ##     : The ID of a project
  ##   tagName: string (required)
  ##          : The name of the tag
  var path_761470 = newJObject()
  add(path_761470, "id", newJString(id))
  add(path_761470, "tag_name", newJString(tagName))
  result = call_761469.call(path_761470, nil, nil, nil, nil)

var deleteV3ProjectsIdRepositoryTagsTagName* = Call_DeleteV3ProjectsIdRepositoryTagsTagName_761463(
    name: "deleteV3ProjectsIdRepositoryTagsTagName", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/tags/{tag_name}",
    validator: validate_DeleteV3ProjectsIdRepositoryTagsTagName_761464,
    base: "/api", url: url_DeleteV3ProjectsIdRepositoryTagsTagName_761465,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdRepositoryTagsTagNameRelease_761471 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdRepositoryTagsTagNameRelease_761473(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "tag_name" in path, "`tag_name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/tags/"),
               (kind: VariableSegment, value: "tag_name"),
               (kind: ConstantSegment, value: "/release")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdRepositoryTagsTagNameRelease_761472(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a tag's release note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   tag_name: JString (required)
  ##           : The name of the tag
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761474 = path.getOrDefault("id")
  valid_761474 = validateParameter(valid_761474, JString, required = true,
                                 default = nil)
  if valid_761474 != nil:
    section.add "id", valid_761474
  var valid_761475 = path.getOrDefault("tag_name")
  valid_761475 = validateParameter(valid_761475, JString, required = true,
                                 default = nil)
  if valid_761475 != nil:
    section.add "tag_name", valid_761475
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   description: JString (required)
  ##              : Release notes with markdown support
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `description` field"
  var valid_761476 = formData.getOrDefault("description")
  valid_761476 = validateParameter(valid_761476, JString, required = true,
                                 default = nil)
  if valid_761476 != nil:
    section.add "description", valid_761476
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761477: Call_PutV3ProjectsIdRepositoryTagsTagNameRelease_761471;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a tag's release note
  ## 
  let valid = call_761477.validator(path, query, header, formData, body)
  let scheme = call_761477.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761477.url(scheme.get, call_761477.host, call_761477.base,
                         call_761477.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761477, url, valid)

proc call*(call_761478: Call_PutV3ProjectsIdRepositoryTagsTagNameRelease_761471;
          id: string; description: string; tagName: string): Recallable =
  ## putV3ProjectsIdRepositoryTagsTagNameRelease
  ## Update a tag's release note
  ##   id: string (required)
  ##     : The ID of a project
  ##   description: string (required)
  ##              : Release notes with markdown support
  ##   tagName: string (required)
  ##          : The name of the tag
  var path_761479 = newJObject()
  var formData_761480 = newJObject()
  add(path_761479, "id", newJString(id))
  add(formData_761480, "description", newJString(description))
  add(path_761479, "tag_name", newJString(tagName))
  result = call_761478.call(path_761479, nil, nil, formData_761480, nil)

var putV3ProjectsIdRepositoryTagsTagNameRelease* = Call_PutV3ProjectsIdRepositoryTagsTagNameRelease_761471(
    name: "putV3ProjectsIdRepositoryTagsTagNameRelease", meth: HttpMethod.HttpPut,
    host: "gitlab.com",
    route: "/v3/projects/{id}/repository/tags/{tag_name}/release",
    validator: validate_PutV3ProjectsIdRepositoryTagsTagNameRelease_761472,
    base: "/api", url: url_PutV3ProjectsIdRepositoryTagsTagNameRelease_761473,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdRepositoryTagsTagNameRelease_761481 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdRepositoryTagsTagNameRelease_761483(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "tag_name" in path, "`tag_name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/tags/"),
               (kind: VariableSegment, value: "tag_name"),
               (kind: ConstantSegment, value: "/release")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdRepositoryTagsTagNameRelease_761482(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add a release note to a tag
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   tag_name: JString (required)
  ##           : The name of the tag
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761484 = path.getOrDefault("id")
  valid_761484 = validateParameter(valid_761484, JString, required = true,
                                 default = nil)
  if valid_761484 != nil:
    section.add "id", valid_761484
  var valid_761485 = path.getOrDefault("tag_name")
  valid_761485 = validateParameter(valid_761485, JString, required = true,
                                 default = nil)
  if valid_761485 != nil:
    section.add "tag_name", valid_761485
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   description: JString (required)
  ##              : Release notes with markdown support
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `description` field"
  var valid_761486 = formData.getOrDefault("description")
  valid_761486 = validateParameter(valid_761486, JString, required = true,
                                 default = nil)
  if valid_761486 != nil:
    section.add "description", valid_761486
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761487: Call_PostV3ProjectsIdRepositoryTagsTagNameRelease_761481;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add a release note to a tag
  ## 
  let valid = call_761487.validator(path, query, header, formData, body)
  let scheme = call_761487.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761487.url(scheme.get, call_761487.host, call_761487.base,
                         call_761487.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761487, url, valid)

proc call*(call_761488: Call_PostV3ProjectsIdRepositoryTagsTagNameRelease_761481;
          id: string; description: string; tagName: string): Recallable =
  ## postV3ProjectsIdRepositoryTagsTagNameRelease
  ## Add a release note to a tag
  ##   id: string (required)
  ##     : The ID of a project
  ##   description: string (required)
  ##              : Release notes with markdown support
  ##   tagName: string (required)
  ##          : The name of the tag
  var path_761489 = newJObject()
  var formData_761490 = newJObject()
  add(path_761489, "id", newJString(id))
  add(formData_761490, "description", newJString(description))
  add(path_761489, "tag_name", newJString(tagName))
  result = call_761488.call(path_761489, nil, nil, formData_761490, nil)

var postV3ProjectsIdRepositoryTagsTagNameRelease* = Call_PostV3ProjectsIdRepositoryTagsTagNameRelease_761481(
    name: "postV3ProjectsIdRepositoryTagsTagNameRelease",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/repository/tags/{tag_name}/release",
    validator: validate_PostV3ProjectsIdRepositoryTagsTagNameRelease_761482,
    base: "/api", url: url_PostV3ProjectsIdRepositoryTagsTagNameRelease_761483,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRepositoryTree_761491 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRepositoryTree_761493(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/repository/tree")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRepositoryTree_761492(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a project repository tree
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761494 = path.getOrDefault("id")
  valid_761494 = validateParameter(valid_761494, JString, required = true,
                                 default = nil)
  if valid_761494 != nil:
    section.add "id", valid_761494
  result.add "path", section
  ## parameters in `query` object:
  ##   ref_name: JString
  ##           : The name of a repository branch or tag, if not given the default branch is used
  ##   recursive: JBool
  ##            : Used to get a recursive tree
  ##   path: JString
  ##       : The path of the tree
  section = newJObject()
  var valid_761495 = query.getOrDefault("ref_name")
  valid_761495 = validateParameter(valid_761495, JString, required = false,
                                 default = nil)
  if valid_761495 != nil:
    section.add "ref_name", valid_761495
  var valid_761496 = query.getOrDefault("recursive")
  valid_761496 = validateParameter(valid_761496, JBool, required = false, default = nil)
  if valid_761496 != nil:
    section.add "recursive", valid_761496
  var valid_761497 = query.getOrDefault("path")
  valid_761497 = validateParameter(valid_761497, JString, required = false,
                                 default = nil)
  if valid_761497 != nil:
    section.add "path", valid_761497
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761498: Call_GetV3ProjectsIdRepositoryTree_761491; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a project repository tree
  ## 
  let valid = call_761498.validator(path, query, header, formData, body)
  let scheme = call_761498.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761498.url(scheme.get, call_761498.host, call_761498.base,
                         call_761498.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761498, url, valid)

proc call*(call_761499: Call_GetV3ProjectsIdRepositoryTree_761491; id: string;
          refName: string = ""; recursive: bool = false; path: string = ""): Recallable =
  ## getV3ProjectsIdRepositoryTree
  ## Get a project repository tree
  ##   refName: string
  ##          : The name of a repository branch or tag, if not given the default branch is used
  ##   id: string (required)
  ##     : The ID of a project
  ##   recursive: bool
  ##            : Used to get a recursive tree
  ##   path: string
  ##       : The path of the tree
  var path_761500 = newJObject()
  var query_761501 = newJObject()
  add(query_761501, "ref_name", newJString(refName))
  add(path_761500, "id", newJString(id))
  add(query_761501, "recursive", newJBool(recursive))
  add(query_761501, "path", newJString(path))
  result = call_761499.call(path_761500, query_761501, nil, nil, nil)

var getV3ProjectsIdRepositoryTree* = Call_GetV3ProjectsIdRepositoryTree_761491(
    name: "getV3ProjectsIdRepositoryTree", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/repository/tree",
    validator: validate_GetV3ProjectsIdRepositoryTree_761492, base: "/api",
    url: url_GetV3ProjectsIdRepositoryTree_761493, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdRunners_761513 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdRunners_761515(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/runners")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdRunners_761514(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enable a runner for a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761516 = path.getOrDefault("id")
  valid_761516 = validateParameter(valid_761516, JString, required = true,
                                 default = nil)
  if valid_761516 != nil:
    section.add "id", valid_761516
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   runner_id: JInt (required)
  ##            : The ID of the runner
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `runner_id` field"
  var valid_761517 = formData.getOrDefault("runner_id")
  valid_761517 = validateParameter(valid_761517, JInt, required = true, default = nil)
  if valid_761517 != nil:
    section.add "runner_id", valid_761517
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761518: Call_PostV3ProjectsIdRunners_761513; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enable a runner for a project
  ## 
  let valid = call_761518.validator(path, query, header, formData, body)
  let scheme = call_761518.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761518.url(scheme.get, call_761518.host, call_761518.base,
                         call_761518.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761518, url, valid)

proc call*(call_761519: Call_PostV3ProjectsIdRunners_761513; id: string;
          runnerId: int): Recallable =
  ## postV3ProjectsIdRunners
  ## Enable a runner for a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   runnerId: int (required)
  ##           : The ID of the runner
  var path_761520 = newJObject()
  var formData_761521 = newJObject()
  add(path_761520, "id", newJString(id))
  add(formData_761521, "runner_id", newJInt(runnerId))
  result = call_761519.call(path_761520, nil, nil, formData_761521, nil)

var postV3ProjectsIdRunners* = Call_PostV3ProjectsIdRunners_761513(
    name: "postV3ProjectsIdRunners", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/runners",
    validator: validate_PostV3ProjectsIdRunners_761514, base: "/api",
    url: url_PostV3ProjectsIdRunners_761515, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdRunners_761502 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdRunners_761504(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/runners")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdRunners_761503(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get runners available for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761505 = path.getOrDefault("id")
  valid_761505 = validateParameter(valid_761505, JString, required = true,
                                 default = nil)
  if valid_761505 != nil:
    section.add "id", valid_761505
  result.add "path", section
  ## parameters in `query` object:
  ##   scope: JString
  ##        : The scope of specific runners to show
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_761506 = query.getOrDefault("scope")
  valid_761506 = validateParameter(valid_761506, JString, required = false,
                                 default = newJString("active"))
  if valid_761506 != nil:
    section.add "scope", valid_761506
  var valid_761507 = query.getOrDefault("per_page")
  valid_761507 = validateParameter(valid_761507, JInt, required = false, default = nil)
  if valid_761507 != nil:
    section.add "per_page", valid_761507
  var valid_761508 = query.getOrDefault("page")
  valid_761508 = validateParameter(valid_761508, JInt, required = false, default = nil)
  if valid_761508 != nil:
    section.add "page", valid_761508
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761509: Call_GetV3ProjectsIdRunners_761502; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get runners available for project
  ## 
  let valid = call_761509.validator(path, query, header, formData, body)
  let scheme = call_761509.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761509.url(scheme.get, call_761509.host, call_761509.base,
                         call_761509.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761509, url, valid)

proc call*(call_761510: Call_GetV3ProjectsIdRunners_761502; id: string;
          scope: string = "active"; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdRunners
  ## Get runners available for project
  ##   scope: string
  ##        : The scope of specific runners to show
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_761511 = newJObject()
  var query_761512 = newJObject()
  add(query_761512, "scope", newJString(scope))
  add(path_761511, "id", newJString(id))
  add(query_761512, "per_page", newJInt(perPage))
  add(query_761512, "page", newJInt(page))
  result = call_761510.call(path_761511, query_761512, nil, nil, nil)

var getV3ProjectsIdRunners* = Call_GetV3ProjectsIdRunners_761502(
    name: "getV3ProjectsIdRunners", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/runners",
    validator: validate_GetV3ProjectsIdRunners_761503, base: "/api",
    url: url_GetV3ProjectsIdRunners_761504, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdRunnersRunnerId_761522 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdRunnersRunnerId_761524(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "runner_id" in path, "`runner_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/runners/"),
               (kind: VariableSegment, value: "runner_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdRunnersRunnerId_761523(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Disable project's runner
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   runner_id: JInt (required)
  ##            : The ID of the runner
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761525 = path.getOrDefault("id")
  valid_761525 = validateParameter(valid_761525, JString, required = true,
                                 default = nil)
  if valid_761525 != nil:
    section.add "id", valid_761525
  var valid_761526 = path.getOrDefault("runner_id")
  valid_761526 = validateParameter(valid_761526, JInt, required = true, default = nil)
  if valid_761526 != nil:
    section.add "runner_id", valid_761526
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761527: Call_DeleteV3ProjectsIdRunnersRunnerId_761522;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Disable project's runner
  ## 
  let valid = call_761527.validator(path, query, header, formData, body)
  let scheme = call_761527.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761527.url(scheme.get, call_761527.host, call_761527.base,
                         call_761527.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761527, url, valid)

proc call*(call_761528: Call_DeleteV3ProjectsIdRunnersRunnerId_761522; id: string;
          runnerId: int): Recallable =
  ## deleteV3ProjectsIdRunnersRunnerId
  ## Disable project's runner
  ##   id: string (required)
  ##     : The ID of a project
  ##   runnerId: int (required)
  ##           : The ID of the runner
  var path_761529 = newJObject()
  add(path_761529, "id", newJString(id))
  add(path_761529, "runner_id", newJInt(runnerId))
  result = call_761528.call(path_761529, nil, nil, nil, nil)

var deleteV3ProjectsIdRunnersRunnerId* = Call_DeleteV3ProjectsIdRunnersRunnerId_761522(
    name: "deleteV3ProjectsIdRunnersRunnerId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/runners/{runner_id}",
    validator: validate_DeleteV3ProjectsIdRunnersRunnerId_761523, base: "/api",
    url: url_DeleteV3ProjectsIdRunnersRunnerId_761524, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesAsana_761530 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesAsana_761532(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/asana")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesAsana_761531(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set asana service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761533 = path.getOrDefault("id")
  valid_761533 = validateParameter(valid_761533, JInt, required = true, default = nil)
  if valid_761533 != nil:
    section.add "id", valid_761533
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   restrict_to_branch: JString
  ##                     : Comma-separated list of branches which will be automatically inspected. Leave blank to include all branches
  ##   api_key: JString (required)
  ##          : User API token
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  section = newJObject()
  var valid_761534 = formData.getOrDefault("restrict_to_branch")
  valid_761534 = validateParameter(valid_761534, JString, required = false,
                                 default = nil)
  if valid_761534 != nil:
    section.add "restrict_to_branch", valid_761534
  assert formData != nil,
        "formData argument is necessary due to required `api_key` field"
  var valid_761535 = formData.getOrDefault("api_key")
  valid_761535 = validateParameter(valid_761535, JString, required = true,
                                 default = nil)
  if valid_761535 != nil:
    section.add "api_key", valid_761535
  var valid_761536 = formData.getOrDefault("push_events")
  valid_761536 = validateParameter(valid_761536, JString, required = false,
                                 default = nil)
  if valid_761536 != nil:
    section.add "push_events", valid_761536
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761537: Call_PutV3ProjectsIdServicesAsana_761530; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Set asana service for project
  ## 
  let valid = call_761537.validator(path, query, header, formData, body)
  let scheme = call_761537.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761537.url(scheme.get, call_761537.host, call_761537.base,
                         call_761537.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761537, url, valid)

proc call*(call_761538: Call_PutV3ProjectsIdServicesAsana_761530; id: int;
          apiKey: string; restrictToBranch: string = ""; pushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesAsana
  ## Set asana service for project
  ##   restrictToBranch: string
  ##                   : Comma-separated list of branches which will be automatically inspected. Leave blank to include all branches
  ##   id: int (required)
  ##   apiKey: string (required)
  ##         : User API token
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  var path_761539 = newJObject()
  var formData_761540 = newJObject()
  add(formData_761540, "restrict_to_branch", newJString(restrictToBranch))
  add(path_761539, "id", newJInt(id))
  add(formData_761540, "api_key", newJString(apiKey))
  add(formData_761540, "push_events", newJString(pushEvents))
  result = call_761538.call(path_761539, nil, nil, formData_761540, nil)

var putV3ProjectsIdServicesAsana* = Call_PutV3ProjectsIdServicesAsana_761530(
    name: "putV3ProjectsIdServicesAsana", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/asana",
    validator: validate_PutV3ProjectsIdServicesAsana_761531, base: "/api",
    url: url_PutV3ProjectsIdServicesAsana_761532, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesAssembla_761541 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesAssembla_761543(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/assembla")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesAssembla_761542(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set assembla service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761544 = path.getOrDefault("id")
  valid_761544 = validateParameter(valid_761544, JInt, required = true, default = nil)
  if valid_761544 != nil:
    section.add "id", valid_761544
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   subdomain: JString
  ##            : Subdomain setting
  ##   token: JString (required)
  ##        : The authentication token
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  section = newJObject()
  var valid_761545 = formData.getOrDefault("subdomain")
  valid_761545 = validateParameter(valid_761545, JString, required = false,
                                 default = nil)
  if valid_761545 != nil:
    section.add "subdomain", valid_761545
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761546 = formData.getOrDefault("token")
  valid_761546 = validateParameter(valid_761546, JString, required = true,
                                 default = nil)
  if valid_761546 != nil:
    section.add "token", valid_761546
  var valid_761547 = formData.getOrDefault("push_events")
  valid_761547 = validateParameter(valid_761547, JString, required = false,
                                 default = nil)
  if valid_761547 != nil:
    section.add "push_events", valid_761547
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761548: Call_PutV3ProjectsIdServicesAssembla_761541;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set assembla service for project
  ## 
  let valid = call_761548.validator(path, query, header, formData, body)
  let scheme = call_761548.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761548.url(scheme.get, call_761548.host, call_761548.base,
                         call_761548.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761548, url, valid)

proc call*(call_761549: Call_PutV3ProjectsIdServicesAssembla_761541; id: int;
          token: string; subdomain: string = ""; pushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesAssembla
  ## Set assembla service for project
  ##   subdomain: string
  ##            : Subdomain setting
  ##   id: int (required)
  ##   token: string (required)
  ##        : The authentication token
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  var path_761550 = newJObject()
  var formData_761551 = newJObject()
  add(formData_761551, "subdomain", newJString(subdomain))
  add(path_761550, "id", newJInt(id))
  add(formData_761551, "token", newJString(token))
  add(formData_761551, "push_events", newJString(pushEvents))
  result = call_761549.call(path_761550, nil, nil, formData_761551, nil)

var putV3ProjectsIdServicesAssembla* = Call_PutV3ProjectsIdServicesAssembla_761541(
    name: "putV3ProjectsIdServicesAssembla", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/assembla",
    validator: validate_PutV3ProjectsIdServicesAssembla_761542, base: "/api",
    url: url_PutV3ProjectsIdServicesAssembla_761543, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesBamboo_761552 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesBamboo_761554(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/bamboo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesBamboo_761553(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set bamboo service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761555 = path.getOrDefault("id")
  valid_761555 = validateParameter(valid_761555, JInt, required = true, default = nil)
  if valid_761555 != nil:
    section.add "id", valid_761555
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   password: JString (required)
  ##           : Passord of the user
  ##   bamboo_url: JString (required)
  ##             : Bamboo root URL like https://bamboo.example.com
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   build_key: JString (required)
  ##            : Bamboo build plan key like
  ##   username: JString (required)
  ##           : A user with API access, if applicable
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `password` field"
  var valid_761556 = formData.getOrDefault("password")
  valid_761556 = validateParameter(valid_761556, JString, required = true,
                                 default = nil)
  if valid_761556 != nil:
    section.add "password", valid_761556
  var valid_761557 = formData.getOrDefault("bamboo_url")
  valid_761557 = validateParameter(valid_761557, JString, required = true,
                                 default = nil)
  if valid_761557 != nil:
    section.add "bamboo_url", valid_761557
  var valid_761558 = formData.getOrDefault("push_events")
  valid_761558 = validateParameter(valid_761558, JString, required = false,
                                 default = nil)
  if valid_761558 != nil:
    section.add "push_events", valid_761558
  var valid_761559 = formData.getOrDefault("build_key")
  valid_761559 = validateParameter(valid_761559, JString, required = true,
                                 default = nil)
  if valid_761559 != nil:
    section.add "build_key", valid_761559
  var valid_761560 = formData.getOrDefault("username")
  valid_761560 = validateParameter(valid_761560, JString, required = true,
                                 default = nil)
  if valid_761560 != nil:
    section.add "username", valid_761560
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761561: Call_PutV3ProjectsIdServicesBamboo_761552; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Set bamboo service for project
  ## 
  let valid = call_761561.validator(path, query, header, formData, body)
  let scheme = call_761561.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761561.url(scheme.get, call_761561.host, call_761561.base,
                         call_761561.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761561, url, valid)

proc call*(call_761562: Call_PutV3ProjectsIdServicesBamboo_761552;
          password: string; bambooUrl: string; id: int; buildKey: string;
          username: string; pushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesBamboo
  ## Set bamboo service for project
  ##   password: string (required)
  ##           : Passord of the user
  ##   bambooUrl: string (required)
  ##            : Bamboo root URL like https://bamboo.example.com
  ##   id: int (required)
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   buildKey: string (required)
  ##           : Bamboo build plan key like
  ##   username: string (required)
  ##           : A user with API access, if applicable
  var path_761563 = newJObject()
  var formData_761564 = newJObject()
  add(formData_761564, "password", newJString(password))
  add(formData_761564, "bamboo_url", newJString(bambooUrl))
  add(path_761563, "id", newJInt(id))
  add(formData_761564, "push_events", newJString(pushEvents))
  add(formData_761564, "build_key", newJString(buildKey))
  add(formData_761564, "username", newJString(username))
  result = call_761562.call(path_761563, nil, nil, formData_761564, nil)

var putV3ProjectsIdServicesBamboo* = Call_PutV3ProjectsIdServicesBamboo_761552(
    name: "putV3ProjectsIdServicesBamboo", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/bamboo",
    validator: validate_PutV3ProjectsIdServicesBamboo_761553, base: "/api",
    url: url_PutV3ProjectsIdServicesBamboo_761554, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesBugzilla_761565 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesBugzilla_761567(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/bugzilla")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesBugzilla_761566(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set bugzilla service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761568 = path.getOrDefault("id")
  valid_761568 = validateParameter(valid_761568, JInt, required = true, default = nil)
  if valid_761568 != nil:
    section.add "id", valid_761568
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   title: JString
  ##        : Title
  ##   issues_url: JString (required)
  ##             : Issues URL
  ##   project_url: JString (required)
  ##              : Project URL
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   description: JString
  ##              : Description
  ##   new_issue_url: JString (required)
  ##                : New issue URL
  section = newJObject()
  var valid_761569 = formData.getOrDefault("title")
  valid_761569 = validateParameter(valid_761569, JString, required = false,
                                 default = nil)
  if valid_761569 != nil:
    section.add "title", valid_761569
  assert formData != nil,
        "formData argument is necessary due to required `issues_url` field"
  var valid_761570 = formData.getOrDefault("issues_url")
  valid_761570 = validateParameter(valid_761570, JString, required = true,
                                 default = nil)
  if valid_761570 != nil:
    section.add "issues_url", valid_761570
  var valid_761571 = formData.getOrDefault("project_url")
  valid_761571 = validateParameter(valid_761571, JString, required = true,
                                 default = nil)
  if valid_761571 != nil:
    section.add "project_url", valid_761571
  var valid_761572 = formData.getOrDefault("push_events")
  valid_761572 = validateParameter(valid_761572, JString, required = false,
                                 default = nil)
  if valid_761572 != nil:
    section.add "push_events", valid_761572
  var valid_761573 = formData.getOrDefault("description")
  valid_761573 = validateParameter(valid_761573, JString, required = false,
                                 default = nil)
  if valid_761573 != nil:
    section.add "description", valid_761573
  var valid_761574 = formData.getOrDefault("new_issue_url")
  valid_761574 = validateParameter(valid_761574, JString, required = true,
                                 default = nil)
  if valid_761574 != nil:
    section.add "new_issue_url", valid_761574
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761575: Call_PutV3ProjectsIdServicesBugzilla_761565;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set bugzilla service for project
  ## 
  let valid = call_761575.validator(path, query, header, formData, body)
  let scheme = call_761575.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761575.url(scheme.get, call_761575.host, call_761575.base,
                         call_761575.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761575, url, valid)

proc call*(call_761576: Call_PutV3ProjectsIdServicesBugzilla_761565; id: int;
          issuesUrl: string; projectUrl: string; newIssueUrl: string;
          title: string = ""; pushEvents: string = ""; description: string = ""): Recallable =
  ## putV3ProjectsIdServicesBugzilla
  ## Set bugzilla service for project
  ##   title: string
  ##        : Title
  ##   id: int (required)
  ##   issuesUrl: string (required)
  ##            : Issues URL
  ##   projectUrl: string (required)
  ##             : Project URL
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   description: string
  ##              : Description
  ##   newIssueUrl: string (required)
  ##              : New issue URL
  var path_761577 = newJObject()
  var formData_761578 = newJObject()
  add(formData_761578, "title", newJString(title))
  add(path_761577, "id", newJInt(id))
  add(formData_761578, "issues_url", newJString(issuesUrl))
  add(formData_761578, "project_url", newJString(projectUrl))
  add(formData_761578, "push_events", newJString(pushEvents))
  add(formData_761578, "description", newJString(description))
  add(formData_761578, "new_issue_url", newJString(newIssueUrl))
  result = call_761576.call(path_761577, nil, nil, formData_761578, nil)

var putV3ProjectsIdServicesBugzilla* = Call_PutV3ProjectsIdServicesBugzilla_761565(
    name: "putV3ProjectsIdServicesBugzilla", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/bugzilla",
    validator: validate_PutV3ProjectsIdServicesBugzilla_761566, base: "/api",
    url: url_PutV3ProjectsIdServicesBugzilla_761567, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesBuildkite_761579 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesBuildkite_761581(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/buildkite")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesBuildkite_761580(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set buildkite service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761582 = path.getOrDefault("id")
  valid_761582 = validateParameter(valid_761582, JInt, required = true, default = nil)
  if valid_761582 != nil:
    section.add "id", valid_761582
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   enable_ssl_verification: JBool
  ##                          : Enable SSL verification for communication
  ##   token: JString (required)
  ##        : Buildkite project GitLab token
  ##   project_url: JString (required)
  ##              : The buildkite project URL
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  section = newJObject()
  var valid_761583 = formData.getOrDefault("enable_ssl_verification")
  valid_761583 = validateParameter(valid_761583, JBool, required = false, default = nil)
  if valid_761583 != nil:
    section.add "enable_ssl_verification", valid_761583
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761584 = formData.getOrDefault("token")
  valid_761584 = validateParameter(valid_761584, JString, required = true,
                                 default = nil)
  if valid_761584 != nil:
    section.add "token", valid_761584
  var valid_761585 = formData.getOrDefault("project_url")
  valid_761585 = validateParameter(valid_761585, JString, required = true,
                                 default = nil)
  if valid_761585 != nil:
    section.add "project_url", valid_761585
  var valid_761586 = formData.getOrDefault("push_events")
  valid_761586 = validateParameter(valid_761586, JString, required = false,
                                 default = nil)
  if valid_761586 != nil:
    section.add "push_events", valid_761586
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761587: Call_PutV3ProjectsIdServicesBuildkite_761579;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set buildkite service for project
  ## 
  let valid = call_761587.validator(path, query, header, formData, body)
  let scheme = call_761587.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761587.url(scheme.get, call_761587.host, call_761587.base,
                         call_761587.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761587, url, valid)

proc call*(call_761588: Call_PutV3ProjectsIdServicesBuildkite_761579; id: int;
          token: string; projectUrl: string; enableSslVerification: bool = false;
          pushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesBuildkite
  ## Set buildkite service for project
  ##   enableSslVerification: bool
  ##                        : Enable SSL verification for communication
  ##   id: int (required)
  ##   token: string (required)
  ##        : Buildkite project GitLab token
  ##   projectUrl: string (required)
  ##             : The buildkite project URL
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  var path_761589 = newJObject()
  var formData_761590 = newJObject()
  add(formData_761590, "enable_ssl_verification", newJBool(enableSslVerification))
  add(path_761589, "id", newJInt(id))
  add(formData_761590, "token", newJString(token))
  add(formData_761590, "project_url", newJString(projectUrl))
  add(formData_761590, "push_events", newJString(pushEvents))
  result = call_761588.call(path_761589, nil, nil, formData_761590, nil)

var putV3ProjectsIdServicesBuildkite* = Call_PutV3ProjectsIdServicesBuildkite_761579(
    name: "putV3ProjectsIdServicesBuildkite", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/buildkite",
    validator: validate_PutV3ProjectsIdServicesBuildkite_761580, base: "/api",
    url: url_PutV3ProjectsIdServicesBuildkite_761581, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesBuildsEmail_761591 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesBuildsEmail_761593(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/builds-email")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesBuildsEmail_761592(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set builds-email service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761594 = path.getOrDefault("id")
  valid_761594 = validateParameter(valid_761594, JInt, required = true, default = nil)
  if valid_761594 != nil:
    section.add "id", valid_761594
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   notify_only_broken_builds: JBool
  ##                            : Notify only broken builds
  ##   recipients: JString (required)
  ##             : Comma-separated list of recipient email addresses
  ##   build_events: JString
  ##               : Event will be triggered when a build status changes
  ##   add_pusher: JBool
  ##             : Add pusher to recipients list
  section = newJObject()
  var valid_761595 = formData.getOrDefault("notify_only_broken_builds")
  valid_761595 = validateParameter(valid_761595, JBool, required = false, default = nil)
  if valid_761595 != nil:
    section.add "notify_only_broken_builds", valid_761595
  assert formData != nil,
        "formData argument is necessary due to required `recipients` field"
  var valid_761596 = formData.getOrDefault("recipients")
  valid_761596 = validateParameter(valid_761596, JString, required = true,
                                 default = nil)
  if valid_761596 != nil:
    section.add "recipients", valid_761596
  var valid_761597 = formData.getOrDefault("build_events")
  valid_761597 = validateParameter(valid_761597, JString, required = false,
                                 default = nil)
  if valid_761597 != nil:
    section.add "build_events", valid_761597
  var valid_761598 = formData.getOrDefault("add_pusher")
  valid_761598 = validateParameter(valid_761598, JBool, required = false, default = nil)
  if valid_761598 != nil:
    section.add "add_pusher", valid_761598
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761599: Call_PutV3ProjectsIdServicesBuildsEmail_761591;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set builds-email service for project
  ## 
  let valid = call_761599.validator(path, query, header, formData, body)
  let scheme = call_761599.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761599.url(scheme.get, call_761599.host, call_761599.base,
                         call_761599.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761599, url, valid)

proc call*(call_761600: Call_PutV3ProjectsIdServicesBuildsEmail_761591; id: int;
          recipients: string; notifyOnlyBrokenBuilds: bool = false;
          buildEvents: string = ""; addPusher: bool = false): Recallable =
  ## putV3ProjectsIdServicesBuildsEmail
  ## Set builds-email service for project
  ##   id: int (required)
  ##   notifyOnlyBrokenBuilds: bool
  ##                         : Notify only broken builds
  ##   recipients: string (required)
  ##             : Comma-separated list of recipient email addresses
  ##   buildEvents: string
  ##              : Event will be triggered when a build status changes
  ##   addPusher: bool
  ##            : Add pusher to recipients list
  var path_761601 = newJObject()
  var formData_761602 = newJObject()
  add(path_761601, "id", newJInt(id))
  add(formData_761602, "notify_only_broken_builds",
      newJBool(notifyOnlyBrokenBuilds))
  add(formData_761602, "recipients", newJString(recipients))
  add(formData_761602, "build_events", newJString(buildEvents))
  add(formData_761602, "add_pusher", newJBool(addPusher))
  result = call_761600.call(path_761601, nil, nil, formData_761602, nil)

var putV3ProjectsIdServicesBuildsEmail* = Call_PutV3ProjectsIdServicesBuildsEmail_761591(
    name: "putV3ProjectsIdServicesBuildsEmail", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/builds-email",
    validator: validate_PutV3ProjectsIdServicesBuildsEmail_761592, base: "/api",
    url: url_PutV3ProjectsIdServicesBuildsEmail_761593, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesCampfire_761603 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesCampfire_761605(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/campfire")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesCampfire_761604(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set campfire service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761606 = path.getOrDefault("id")
  valid_761606 = validateParameter(valid_761606, JInt, required = true, default = nil)
  if valid_761606 != nil:
    section.add "id", valid_761606
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   subdomain: JString
  ##            : Campfire subdomain
  ##   token: JString (required)
  ##        : Campfire token
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   room: JString
  ##       : Campfire room
  section = newJObject()
  var valid_761607 = formData.getOrDefault("subdomain")
  valid_761607 = validateParameter(valid_761607, JString, required = false,
                                 default = nil)
  if valid_761607 != nil:
    section.add "subdomain", valid_761607
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761608 = formData.getOrDefault("token")
  valid_761608 = validateParameter(valid_761608, JString, required = true,
                                 default = nil)
  if valid_761608 != nil:
    section.add "token", valid_761608
  var valid_761609 = formData.getOrDefault("push_events")
  valid_761609 = validateParameter(valid_761609, JString, required = false,
                                 default = nil)
  if valid_761609 != nil:
    section.add "push_events", valid_761609
  var valid_761610 = formData.getOrDefault("room")
  valid_761610 = validateParameter(valid_761610, JString, required = false,
                                 default = nil)
  if valid_761610 != nil:
    section.add "room", valid_761610
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761611: Call_PutV3ProjectsIdServicesCampfire_761603;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set campfire service for project
  ## 
  let valid = call_761611.validator(path, query, header, formData, body)
  let scheme = call_761611.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761611.url(scheme.get, call_761611.host, call_761611.base,
                         call_761611.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761611, url, valid)

proc call*(call_761612: Call_PutV3ProjectsIdServicesCampfire_761603; id: int;
          token: string; subdomain: string = ""; pushEvents: string = "";
          room: string = ""): Recallable =
  ## putV3ProjectsIdServicesCampfire
  ## Set campfire service for project
  ##   subdomain: string
  ##            : Campfire subdomain
  ##   id: int (required)
  ##   token: string (required)
  ##        : Campfire token
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   room: string
  ##       : Campfire room
  var path_761613 = newJObject()
  var formData_761614 = newJObject()
  add(formData_761614, "subdomain", newJString(subdomain))
  add(path_761613, "id", newJInt(id))
  add(formData_761614, "token", newJString(token))
  add(formData_761614, "push_events", newJString(pushEvents))
  add(formData_761614, "room", newJString(room))
  result = call_761612.call(path_761613, nil, nil, formData_761614, nil)

var putV3ProjectsIdServicesCampfire* = Call_PutV3ProjectsIdServicesCampfire_761603(
    name: "putV3ProjectsIdServicesCampfire", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/campfire",
    validator: validate_PutV3ProjectsIdServicesCampfire_761604, base: "/api",
    url: url_PutV3ProjectsIdServicesCampfire_761605, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesCustomIssueTracker_761615 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesCustomIssueTracker_761617(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/custom-issue-tracker")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesCustomIssueTracker_761616(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set custom-issue-tracker service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761618 = path.getOrDefault("id")
  valid_761618 = validateParameter(valid_761618, JInt, required = true, default = nil)
  if valid_761618 != nil:
    section.add "id", valid_761618
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   title: JString
  ##        : Title
  ##   issues_url: JString (required)
  ##             : Issues URL
  ##   project_url: JString (required)
  ##              : Project URL
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   description: JString
  ##              : Description
  ##   new_issue_url: JString (required)
  ##                : New issue URL
  section = newJObject()
  var valid_761619 = formData.getOrDefault("title")
  valid_761619 = validateParameter(valid_761619, JString, required = false,
                                 default = nil)
  if valid_761619 != nil:
    section.add "title", valid_761619
  assert formData != nil,
        "formData argument is necessary due to required `issues_url` field"
  var valid_761620 = formData.getOrDefault("issues_url")
  valid_761620 = validateParameter(valid_761620, JString, required = true,
                                 default = nil)
  if valid_761620 != nil:
    section.add "issues_url", valid_761620
  var valid_761621 = formData.getOrDefault("project_url")
  valid_761621 = validateParameter(valid_761621, JString, required = true,
                                 default = nil)
  if valid_761621 != nil:
    section.add "project_url", valid_761621
  var valid_761622 = formData.getOrDefault("push_events")
  valid_761622 = validateParameter(valid_761622, JString, required = false,
                                 default = nil)
  if valid_761622 != nil:
    section.add "push_events", valid_761622
  var valid_761623 = formData.getOrDefault("description")
  valid_761623 = validateParameter(valid_761623, JString, required = false,
                                 default = nil)
  if valid_761623 != nil:
    section.add "description", valid_761623
  var valid_761624 = formData.getOrDefault("new_issue_url")
  valid_761624 = validateParameter(valid_761624, JString, required = true,
                                 default = nil)
  if valid_761624 != nil:
    section.add "new_issue_url", valid_761624
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761625: Call_PutV3ProjectsIdServicesCustomIssueTracker_761615;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set custom-issue-tracker service for project
  ## 
  let valid = call_761625.validator(path, query, header, formData, body)
  let scheme = call_761625.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761625.url(scheme.get, call_761625.host, call_761625.base,
                         call_761625.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761625, url, valid)

proc call*(call_761626: Call_PutV3ProjectsIdServicesCustomIssueTracker_761615;
          id: int; issuesUrl: string; projectUrl: string; newIssueUrl: string;
          title: string = ""; pushEvents: string = ""; description: string = ""): Recallable =
  ## putV3ProjectsIdServicesCustomIssueTracker
  ## Set custom-issue-tracker service for project
  ##   title: string
  ##        : Title
  ##   id: int (required)
  ##   issuesUrl: string (required)
  ##            : Issues URL
  ##   projectUrl: string (required)
  ##             : Project URL
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   description: string
  ##              : Description
  ##   newIssueUrl: string (required)
  ##              : New issue URL
  var path_761627 = newJObject()
  var formData_761628 = newJObject()
  add(formData_761628, "title", newJString(title))
  add(path_761627, "id", newJInt(id))
  add(formData_761628, "issues_url", newJString(issuesUrl))
  add(formData_761628, "project_url", newJString(projectUrl))
  add(formData_761628, "push_events", newJString(pushEvents))
  add(formData_761628, "description", newJString(description))
  add(formData_761628, "new_issue_url", newJString(newIssueUrl))
  result = call_761626.call(path_761627, nil, nil, formData_761628, nil)

var putV3ProjectsIdServicesCustomIssueTracker* = Call_PutV3ProjectsIdServicesCustomIssueTracker_761615(
    name: "putV3ProjectsIdServicesCustomIssueTracker", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/custom-issue-tracker",
    validator: validate_PutV3ProjectsIdServicesCustomIssueTracker_761616,
    base: "/api", url: url_PutV3ProjectsIdServicesCustomIssueTracker_761617,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesDroneCi_761629 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesDroneCi_761631(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/drone-ci")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesDroneCi_761630(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set drone-ci service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761632 = path.getOrDefault("id")
  valid_761632 = validateParameter(valid_761632, JInt, required = true, default = nil)
  if valid_761632 != nil:
    section.add "id", valid_761632
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   enable_ssl_verification: JBool
  ##                          : Enable SSL verification for communication
  ##   token: JString (required)
  ##        : Drone CI token
  ##   drone_url: JString (required)
  ##            : Drone CI URL
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   merge_request_events: JString
  ##                       : Event will be triggered when a merge request is created/updated/merged
  ##   tag_push_events: JString
  ##                  : Event will be triggered when a new tag is pushed to the repository
  section = newJObject()
  var valid_761633 = formData.getOrDefault("enable_ssl_verification")
  valid_761633 = validateParameter(valid_761633, JBool, required = false, default = nil)
  if valid_761633 != nil:
    section.add "enable_ssl_verification", valid_761633
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761634 = formData.getOrDefault("token")
  valid_761634 = validateParameter(valid_761634, JString, required = true,
                                 default = nil)
  if valid_761634 != nil:
    section.add "token", valid_761634
  var valid_761635 = formData.getOrDefault("drone_url")
  valid_761635 = validateParameter(valid_761635, JString, required = true,
                                 default = nil)
  if valid_761635 != nil:
    section.add "drone_url", valid_761635
  var valid_761636 = formData.getOrDefault("push_events")
  valid_761636 = validateParameter(valid_761636, JString, required = false,
                                 default = nil)
  if valid_761636 != nil:
    section.add "push_events", valid_761636
  var valid_761637 = formData.getOrDefault("merge_request_events")
  valid_761637 = validateParameter(valid_761637, JString, required = false,
                                 default = nil)
  if valid_761637 != nil:
    section.add "merge_request_events", valid_761637
  var valid_761638 = formData.getOrDefault("tag_push_events")
  valid_761638 = validateParameter(valid_761638, JString, required = false,
                                 default = nil)
  if valid_761638 != nil:
    section.add "tag_push_events", valid_761638
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761639: Call_PutV3ProjectsIdServicesDroneCi_761629; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Set drone-ci service for project
  ## 
  let valid = call_761639.validator(path, query, header, formData, body)
  let scheme = call_761639.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761639.url(scheme.get, call_761639.host, call_761639.base,
                         call_761639.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761639, url, valid)

proc call*(call_761640: Call_PutV3ProjectsIdServicesDroneCi_761629; id: int;
          token: string; droneUrl: string; enableSslVerification: bool = false;
          pushEvents: string = ""; mergeRequestEvents: string = "";
          tagPushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesDroneCi
  ## Set drone-ci service for project
  ##   enableSslVerification: bool
  ##                        : Enable SSL verification for communication
  ##   id: int (required)
  ##   token: string (required)
  ##        : Drone CI token
  ##   droneUrl: string (required)
  ##           : Drone CI URL
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   mergeRequestEvents: string
  ##                     : Event will be triggered when a merge request is created/updated/merged
  ##   tagPushEvents: string
  ##                : Event will be triggered when a new tag is pushed to the repository
  var path_761641 = newJObject()
  var formData_761642 = newJObject()
  add(formData_761642, "enable_ssl_verification", newJBool(enableSslVerification))
  add(path_761641, "id", newJInt(id))
  add(formData_761642, "token", newJString(token))
  add(formData_761642, "drone_url", newJString(droneUrl))
  add(formData_761642, "push_events", newJString(pushEvents))
  add(formData_761642, "merge_request_events", newJString(mergeRequestEvents))
  add(formData_761642, "tag_push_events", newJString(tagPushEvents))
  result = call_761640.call(path_761641, nil, nil, formData_761642, nil)

var putV3ProjectsIdServicesDroneCi* = Call_PutV3ProjectsIdServicesDroneCi_761629(
    name: "putV3ProjectsIdServicesDroneCi", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/drone-ci",
    validator: validate_PutV3ProjectsIdServicesDroneCi_761630, base: "/api",
    url: url_PutV3ProjectsIdServicesDroneCi_761631, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesEmailsOnPush_761643 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesEmailsOnPush_761645(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/emails-on-push")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesEmailsOnPush_761644(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set emails-on-push service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761646 = path.getOrDefault("id")
  valid_761646 = validateParameter(valid_761646, JInt, required = true, default = nil)
  if valid_761646 != nil:
    section.add "id", valid_761646
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   recipients: JString (required)
  ##             : Comma-separated list of recipient email addresses
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   disable_diffs: JBool
  ##                : Disable code diffs
  ##   tag_push_events: JString
  ##                  : Event will be triggered when a new tag is pushed to the repository
  ##   send_from_committer_email: JBool
  ##                            : Send from committer
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `recipients` field"
  var valid_761647 = formData.getOrDefault("recipients")
  valid_761647 = validateParameter(valid_761647, JString, required = true,
                                 default = nil)
  if valid_761647 != nil:
    section.add "recipients", valid_761647
  var valid_761648 = formData.getOrDefault("push_events")
  valid_761648 = validateParameter(valid_761648, JString, required = false,
                                 default = nil)
  if valid_761648 != nil:
    section.add "push_events", valid_761648
  var valid_761649 = formData.getOrDefault("disable_diffs")
  valid_761649 = validateParameter(valid_761649, JBool, required = false, default = nil)
  if valid_761649 != nil:
    section.add "disable_diffs", valid_761649
  var valid_761650 = formData.getOrDefault("tag_push_events")
  valid_761650 = validateParameter(valid_761650, JString, required = false,
                                 default = nil)
  if valid_761650 != nil:
    section.add "tag_push_events", valid_761650
  var valid_761651 = formData.getOrDefault("send_from_committer_email")
  valid_761651 = validateParameter(valid_761651, JBool, required = false, default = nil)
  if valid_761651 != nil:
    section.add "send_from_committer_email", valid_761651
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761652: Call_PutV3ProjectsIdServicesEmailsOnPush_761643;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set emails-on-push service for project
  ## 
  let valid = call_761652.validator(path, query, header, formData, body)
  let scheme = call_761652.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761652.url(scheme.get, call_761652.host, call_761652.base,
                         call_761652.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761652, url, valid)

proc call*(call_761653: Call_PutV3ProjectsIdServicesEmailsOnPush_761643; id: int;
          recipients: string; pushEvents: string = ""; disableDiffs: bool = false;
          tagPushEvents: string = ""; sendFromCommitterEmail: bool = false): Recallable =
  ## putV3ProjectsIdServicesEmailsOnPush
  ## Set emails-on-push service for project
  ##   id: int (required)
  ##   recipients: string (required)
  ##             : Comma-separated list of recipient email addresses
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   disableDiffs: bool
  ##               : Disable code diffs
  ##   tagPushEvents: string
  ##                : Event will be triggered when a new tag is pushed to the repository
  ##   sendFromCommitterEmail: bool
  ##                         : Send from committer
  var path_761654 = newJObject()
  var formData_761655 = newJObject()
  add(path_761654, "id", newJInt(id))
  add(formData_761655, "recipients", newJString(recipients))
  add(formData_761655, "push_events", newJString(pushEvents))
  add(formData_761655, "disable_diffs", newJBool(disableDiffs))
  add(formData_761655, "tag_push_events", newJString(tagPushEvents))
  add(formData_761655, "send_from_committer_email",
      newJBool(sendFromCommitterEmail))
  result = call_761653.call(path_761654, nil, nil, formData_761655, nil)

var putV3ProjectsIdServicesEmailsOnPush* = Call_PutV3ProjectsIdServicesEmailsOnPush_761643(
    name: "putV3ProjectsIdServicesEmailsOnPush", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/emails-on-push",
    validator: validate_PutV3ProjectsIdServicesEmailsOnPush_761644, base: "/api",
    url: url_PutV3ProjectsIdServicesEmailsOnPush_761645, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesExternalWiki_761656 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesExternalWiki_761658(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/external-wiki")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesExternalWiki_761657(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set external-wiki service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761659 = path.getOrDefault("id")
  valid_761659 = validateParameter(valid_761659, JInt, required = true, default = nil)
  if valid_761659 != nil:
    section.add "id", valid_761659
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   external_wiki_url: JString (required)
  ##                    : The URL of the external Wiki
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `external_wiki_url` field"
  var valid_761660 = formData.getOrDefault("external_wiki_url")
  valid_761660 = validateParameter(valid_761660, JString, required = true,
                                 default = nil)
  if valid_761660 != nil:
    section.add "external_wiki_url", valid_761660
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761661: Call_PutV3ProjectsIdServicesExternalWiki_761656;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set external-wiki service for project
  ## 
  let valid = call_761661.validator(path, query, header, formData, body)
  let scheme = call_761661.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761661.url(scheme.get, call_761661.host, call_761661.base,
                         call_761661.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761661, url, valid)

proc call*(call_761662: Call_PutV3ProjectsIdServicesExternalWiki_761656; id: int;
          externalWikiUrl: string): Recallable =
  ## putV3ProjectsIdServicesExternalWiki
  ## Set external-wiki service for project
  ##   id: int (required)
  ##   externalWikiUrl: string (required)
  ##                  : The URL of the external Wiki
  var path_761663 = newJObject()
  var formData_761664 = newJObject()
  add(path_761663, "id", newJInt(id))
  add(formData_761664, "external_wiki_url", newJString(externalWikiUrl))
  result = call_761662.call(path_761663, nil, nil, formData_761664, nil)

var putV3ProjectsIdServicesExternalWiki* = Call_PutV3ProjectsIdServicesExternalWiki_761656(
    name: "putV3ProjectsIdServicesExternalWiki", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/external-wiki",
    validator: validate_PutV3ProjectsIdServicesExternalWiki_761657, base: "/api",
    url: url_PutV3ProjectsIdServicesExternalWiki_761658, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesFlowdock_761665 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesFlowdock_761667(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/flowdock")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesFlowdock_761666(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set flowdock service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761668 = path.getOrDefault("id")
  valid_761668 = validateParameter(valid_761668, JInt, required = true, default = nil)
  if valid_761668 != nil:
    section.add "id", valid_761668
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   token: JString (required)
  ##        : Flowdock token
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761669 = formData.getOrDefault("token")
  valid_761669 = validateParameter(valid_761669, JString, required = true,
                                 default = nil)
  if valid_761669 != nil:
    section.add "token", valid_761669
  var valid_761670 = formData.getOrDefault("push_events")
  valid_761670 = validateParameter(valid_761670, JString, required = false,
                                 default = nil)
  if valid_761670 != nil:
    section.add "push_events", valid_761670
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761671: Call_PutV3ProjectsIdServicesFlowdock_761665;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set flowdock service for project
  ## 
  let valid = call_761671.validator(path, query, header, formData, body)
  let scheme = call_761671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761671.url(scheme.get, call_761671.host, call_761671.base,
                         call_761671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761671, url, valid)

proc call*(call_761672: Call_PutV3ProjectsIdServicesFlowdock_761665; id: int;
          token: string; pushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesFlowdock
  ## Set flowdock service for project
  ##   id: int (required)
  ##   token: string (required)
  ##        : Flowdock token
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  var path_761673 = newJObject()
  var formData_761674 = newJObject()
  add(path_761673, "id", newJInt(id))
  add(formData_761674, "token", newJString(token))
  add(formData_761674, "push_events", newJString(pushEvents))
  result = call_761672.call(path_761673, nil, nil, formData_761674, nil)

var putV3ProjectsIdServicesFlowdock* = Call_PutV3ProjectsIdServicesFlowdock_761665(
    name: "putV3ProjectsIdServicesFlowdock", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/flowdock",
    validator: validate_PutV3ProjectsIdServicesFlowdock_761666, base: "/api",
    url: url_PutV3ProjectsIdServicesFlowdock_761667, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesGemnasium_761675 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesGemnasium_761677(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/gemnasium")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesGemnasium_761676(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set gemnasium service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761678 = path.getOrDefault("id")
  valid_761678 = validateParameter(valid_761678, JInt, required = true, default = nil)
  if valid_761678 != nil:
    section.add "id", valid_761678
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   api_key: JString (required)
  ##          : Your personal API key on gemnasium.com
  ##   token: JString (required)
  ##        : The project's slug on gemnasium.com
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `api_key` field"
  var valid_761679 = formData.getOrDefault("api_key")
  valid_761679 = validateParameter(valid_761679, JString, required = true,
                                 default = nil)
  if valid_761679 != nil:
    section.add "api_key", valid_761679
  var valid_761680 = formData.getOrDefault("token")
  valid_761680 = validateParameter(valid_761680, JString, required = true,
                                 default = nil)
  if valid_761680 != nil:
    section.add "token", valid_761680
  var valid_761681 = formData.getOrDefault("push_events")
  valid_761681 = validateParameter(valid_761681, JString, required = false,
                                 default = nil)
  if valid_761681 != nil:
    section.add "push_events", valid_761681
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761682: Call_PutV3ProjectsIdServicesGemnasium_761675;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set gemnasium service for project
  ## 
  let valid = call_761682.validator(path, query, header, formData, body)
  let scheme = call_761682.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761682.url(scheme.get, call_761682.host, call_761682.base,
                         call_761682.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761682, url, valid)

proc call*(call_761683: Call_PutV3ProjectsIdServicesGemnasium_761675; id: int;
          apiKey: string; token: string; pushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesGemnasium
  ## Set gemnasium service for project
  ##   id: int (required)
  ##   apiKey: string (required)
  ##         : Your personal API key on gemnasium.com
  ##   token: string (required)
  ##        : The project's slug on gemnasium.com
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  var path_761684 = newJObject()
  var formData_761685 = newJObject()
  add(path_761684, "id", newJInt(id))
  add(formData_761685, "api_key", newJString(apiKey))
  add(formData_761685, "token", newJString(token))
  add(formData_761685, "push_events", newJString(pushEvents))
  result = call_761683.call(path_761684, nil, nil, formData_761685, nil)

var putV3ProjectsIdServicesGemnasium* = Call_PutV3ProjectsIdServicesGemnasium_761675(
    name: "putV3ProjectsIdServicesGemnasium", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/gemnasium",
    validator: validate_PutV3ProjectsIdServicesGemnasium_761676, base: "/api",
    url: url_PutV3ProjectsIdServicesGemnasium_761677, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesHipchat_761686 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesHipchat_761688(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/hipchat")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesHipchat_761687(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set hipchat service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761689 = path.getOrDefault("id")
  valid_761689 = validateParameter(valid_761689, JInt, required = true, default = nil)
  if valid_761689 != nil:
    section.add "id", valid_761689
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   server: JString
  ##         : Leave blank for default. https://hipchat.example.com
  ##   color: JString
  ##        : The room color
  ##   note_events: JString
  ##              : Event will be triggered when someone adds a comment
  ##   confidential_issue_events: JString
  ##                            : Event will be triggered when a confidential issue is created/updated/closed
  ##   token: JString (required)
  ##        : The room token
  ##   api_version: JString
  ##              : Leave blank for default (v2)
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   room: JString
  ##       : The room name or ID
  ##   merge_request_events: JString
  ##                       : Event will be triggered when a merge request is created/updated/merged
  ##   tag_push_events: JString
  ##                  : Event will be triggered when a new tag is pushed to the repository
  ##   issue_events: JString
  ##               : Event will be triggered when an issue is created/updated/closed
  ##   build_events: JString
  ##               : Event will be triggered when a build status changes
  ##   notify: JBool
  ##         : Enable notifications
  section = newJObject()
  var valid_761690 = formData.getOrDefault("server")
  valid_761690 = validateParameter(valid_761690, JString, required = false,
                                 default = nil)
  if valid_761690 != nil:
    section.add "server", valid_761690
  var valid_761691 = formData.getOrDefault("color")
  valid_761691 = validateParameter(valid_761691, JString, required = false,
                                 default = nil)
  if valid_761691 != nil:
    section.add "color", valid_761691
  var valid_761692 = formData.getOrDefault("note_events")
  valid_761692 = validateParameter(valid_761692, JString, required = false,
                                 default = nil)
  if valid_761692 != nil:
    section.add "note_events", valid_761692
  var valid_761693 = formData.getOrDefault("confidential_issue_events")
  valid_761693 = validateParameter(valid_761693, JString, required = false,
                                 default = nil)
  if valid_761693 != nil:
    section.add "confidential_issue_events", valid_761693
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761694 = formData.getOrDefault("token")
  valid_761694 = validateParameter(valid_761694, JString, required = true,
                                 default = nil)
  if valid_761694 != nil:
    section.add "token", valid_761694
  var valid_761695 = formData.getOrDefault("api_version")
  valid_761695 = validateParameter(valid_761695, JString, required = false,
                                 default = nil)
  if valid_761695 != nil:
    section.add "api_version", valid_761695
  var valid_761696 = formData.getOrDefault("push_events")
  valid_761696 = validateParameter(valid_761696, JString, required = false,
                                 default = nil)
  if valid_761696 != nil:
    section.add "push_events", valid_761696
  var valid_761697 = formData.getOrDefault("room")
  valid_761697 = validateParameter(valid_761697, JString, required = false,
                                 default = nil)
  if valid_761697 != nil:
    section.add "room", valid_761697
  var valid_761698 = formData.getOrDefault("merge_request_events")
  valid_761698 = validateParameter(valid_761698, JString, required = false,
                                 default = nil)
  if valid_761698 != nil:
    section.add "merge_request_events", valid_761698
  var valid_761699 = formData.getOrDefault("tag_push_events")
  valid_761699 = validateParameter(valid_761699, JString, required = false,
                                 default = nil)
  if valid_761699 != nil:
    section.add "tag_push_events", valid_761699
  var valid_761700 = formData.getOrDefault("issue_events")
  valid_761700 = validateParameter(valid_761700, JString, required = false,
                                 default = nil)
  if valid_761700 != nil:
    section.add "issue_events", valid_761700
  var valid_761701 = formData.getOrDefault("build_events")
  valid_761701 = validateParameter(valid_761701, JString, required = false,
                                 default = nil)
  if valid_761701 != nil:
    section.add "build_events", valid_761701
  var valid_761702 = formData.getOrDefault("notify")
  valid_761702 = validateParameter(valid_761702, JBool, required = false, default = nil)
  if valid_761702 != nil:
    section.add "notify", valid_761702
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761703: Call_PutV3ProjectsIdServicesHipchat_761686; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Set hipchat service for project
  ## 
  let valid = call_761703.validator(path, query, header, formData, body)
  let scheme = call_761703.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761703.url(scheme.get, call_761703.host, call_761703.base,
                         call_761703.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761703, url, valid)

proc call*(call_761704: Call_PutV3ProjectsIdServicesHipchat_761686; id: int;
          token: string; server: string = ""; color: string = ""; noteEvents: string = "";
          confidentialIssueEvents: string = ""; apiVersion: string = "";
          pushEvents: string = ""; room: string = ""; mergeRequestEvents: string = "";
          tagPushEvents: string = ""; issueEvents: string = "";
          buildEvents: string = ""; notify: bool = false): Recallable =
  ## putV3ProjectsIdServicesHipchat
  ## Set hipchat service for project
  ##   server: string
  ##         : Leave blank for default. https://hipchat.example.com
  ##   color: string
  ##        : The room color
  ##   id: int (required)
  ##   noteEvents: string
  ##             : Event will be triggered when someone adds a comment
  ##   confidentialIssueEvents: string
  ##                          : Event will be triggered when a confidential issue is created/updated/closed
  ##   token: string (required)
  ##        : The room token
  ##   apiVersion: string
  ##             : Leave blank for default (v2)
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   room: string
  ##       : The room name or ID
  ##   mergeRequestEvents: string
  ##                     : Event will be triggered when a merge request is created/updated/merged
  ##   tagPushEvents: string
  ##                : Event will be triggered when a new tag is pushed to the repository
  ##   issueEvents: string
  ##              : Event will be triggered when an issue is created/updated/closed
  ##   buildEvents: string
  ##              : Event will be triggered when a build status changes
  ##   notify: bool
  ##         : Enable notifications
  var path_761705 = newJObject()
  var formData_761706 = newJObject()
  add(formData_761706, "server", newJString(server))
  add(formData_761706, "color", newJString(color))
  add(path_761705, "id", newJInt(id))
  add(formData_761706, "note_events", newJString(noteEvents))
  add(formData_761706, "confidential_issue_events",
      newJString(confidentialIssueEvents))
  add(formData_761706, "token", newJString(token))
  add(formData_761706, "api_version", newJString(apiVersion))
  add(formData_761706, "push_events", newJString(pushEvents))
  add(formData_761706, "room", newJString(room))
  add(formData_761706, "merge_request_events", newJString(mergeRequestEvents))
  add(formData_761706, "tag_push_events", newJString(tagPushEvents))
  add(formData_761706, "issue_events", newJString(issueEvents))
  add(formData_761706, "build_events", newJString(buildEvents))
  add(formData_761706, "notify", newJBool(notify))
  result = call_761704.call(path_761705, nil, nil, formData_761706, nil)

var putV3ProjectsIdServicesHipchat* = Call_PutV3ProjectsIdServicesHipchat_761686(
    name: "putV3ProjectsIdServicesHipchat", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/hipchat",
    validator: validate_PutV3ProjectsIdServicesHipchat_761687, base: "/api",
    url: url_PutV3ProjectsIdServicesHipchat_761688, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesIrker_761707 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesIrker_761709(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/irker")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesIrker_761708(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set irker service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761710 = path.getOrDefault("id")
  valid_761710 = validateParameter(valid_761710, JInt, required = true, default = nil)
  if valid_761710 != nil:
    section.add "id", valid_761710
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   server_port: JInt
  ##              : Server port. Default 6659
  ##   default_irc_uri: JString
  ##                  : Default: irc://irc.network.net:6697
  ##   colorize_messages: JBool
  ##                    : Colorize messages
  ##   recipients: JString (required)
  ##             : Recipients/channels separated by whitespaces
  ##   server_host: JString
  ##              : Server host. Default localhost
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  section = newJObject()
  var valid_761711 = formData.getOrDefault("server_port")
  valid_761711 = validateParameter(valid_761711, JInt, required = false, default = nil)
  if valid_761711 != nil:
    section.add "server_port", valid_761711
  var valid_761712 = formData.getOrDefault("default_irc_uri")
  valid_761712 = validateParameter(valid_761712, JString, required = false,
                                 default = nil)
  if valid_761712 != nil:
    section.add "default_irc_uri", valid_761712
  var valid_761713 = formData.getOrDefault("colorize_messages")
  valid_761713 = validateParameter(valid_761713, JBool, required = false, default = nil)
  if valid_761713 != nil:
    section.add "colorize_messages", valid_761713
  assert formData != nil,
        "formData argument is necessary due to required `recipients` field"
  var valid_761714 = formData.getOrDefault("recipients")
  valid_761714 = validateParameter(valid_761714, JString, required = true,
                                 default = nil)
  if valid_761714 != nil:
    section.add "recipients", valid_761714
  var valid_761715 = formData.getOrDefault("server_host")
  valid_761715 = validateParameter(valid_761715, JString, required = false,
                                 default = nil)
  if valid_761715 != nil:
    section.add "server_host", valid_761715
  var valid_761716 = formData.getOrDefault("push_events")
  valid_761716 = validateParameter(valid_761716, JString, required = false,
                                 default = nil)
  if valid_761716 != nil:
    section.add "push_events", valid_761716
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761717: Call_PutV3ProjectsIdServicesIrker_761707; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Set irker service for project
  ## 
  let valid = call_761717.validator(path, query, header, formData, body)
  let scheme = call_761717.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761717.url(scheme.get, call_761717.host, call_761717.base,
                         call_761717.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761717, url, valid)

proc call*(call_761718: Call_PutV3ProjectsIdServicesIrker_761707; id: int;
          recipients: string; serverPort: int = 0; defaultIrcUri: string = "";
          colorizeMessages: bool = false; serverHost: string = "";
          pushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesIrker
  ## Set irker service for project
  ##   serverPort: int
  ##             : Server port. Default 6659
  ##   id: int (required)
  ##   defaultIrcUri: string
  ##                : Default: irc://irc.network.net:6697
  ##   colorizeMessages: bool
  ##                   : Colorize messages
  ##   recipients: string (required)
  ##             : Recipients/channels separated by whitespaces
  ##   serverHost: string
  ##             : Server host. Default localhost
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  var path_761719 = newJObject()
  var formData_761720 = newJObject()
  add(formData_761720, "server_port", newJInt(serverPort))
  add(path_761719, "id", newJInt(id))
  add(formData_761720, "default_irc_uri", newJString(defaultIrcUri))
  add(formData_761720, "colorize_messages", newJBool(colorizeMessages))
  add(formData_761720, "recipients", newJString(recipients))
  add(formData_761720, "server_host", newJString(serverHost))
  add(formData_761720, "push_events", newJString(pushEvents))
  result = call_761718.call(path_761719, nil, nil, formData_761720, nil)

var putV3ProjectsIdServicesIrker* = Call_PutV3ProjectsIdServicesIrker_761707(
    name: "putV3ProjectsIdServicesIrker", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/irker",
    validator: validate_PutV3ProjectsIdServicesIrker_761708, base: "/api",
    url: url_PutV3ProjectsIdServicesIrker_761709, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesJira_761721 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesJira_761723(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/jira")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesJira_761722(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set jira service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761724 = path.getOrDefault("id")
  valid_761724 = validateParameter(valid_761724, JInt, required = true, default = nil)
  if valid_761724 != nil:
    section.add "id", valid_761724
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   commit_events: JString
  ##                : Event will be triggered when a commit is created/updated
  ##   password: JString
  ##           : The password of the user created to be used with GitLab/JIRA
  ##   url: JString (required)
  ##      : The URL to the JIRA project which is being linked to this GitLab project, e.g., https://jira.example.com
  ##   merge_request_events: JString
  ##                       : Event will be triggered when a merge request is created/updated/merged
  ##   project_key: JString (required)
  ##              : The short identifier for your JIRA project, all uppercase, e.g., PROJ
  ##   username: JString
  ##           : The username of the user created to be used with GitLab/JIRA
  ##   jira_issue_transition_id: JInt
  ##                           : The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (**Administration > Issues > Workflows**) by selecting **View** under **Operations** of the desired workflow of your project. The ID of each state can be found inside the parenthesis of each transition name under the **Transitions (id)** column ([see screenshot][trans]). By default, this ID is set to `2`
  section = newJObject()
  var valid_761725 = formData.getOrDefault("commit_events")
  valid_761725 = validateParameter(valid_761725, JString, required = false,
                                 default = nil)
  if valid_761725 != nil:
    section.add "commit_events", valid_761725
  var valid_761726 = formData.getOrDefault("password")
  valid_761726 = validateParameter(valid_761726, JString, required = false,
                                 default = nil)
  if valid_761726 != nil:
    section.add "password", valid_761726
  assert formData != nil,
        "formData argument is necessary due to required `url` field"
  var valid_761727 = formData.getOrDefault("url")
  valid_761727 = validateParameter(valid_761727, JString, required = true,
                                 default = nil)
  if valid_761727 != nil:
    section.add "url", valid_761727
  var valid_761728 = formData.getOrDefault("merge_request_events")
  valid_761728 = validateParameter(valid_761728, JString, required = false,
                                 default = nil)
  if valid_761728 != nil:
    section.add "merge_request_events", valid_761728
  var valid_761729 = formData.getOrDefault("project_key")
  valid_761729 = validateParameter(valid_761729, JString, required = true,
                                 default = nil)
  if valid_761729 != nil:
    section.add "project_key", valid_761729
  var valid_761730 = formData.getOrDefault("username")
  valid_761730 = validateParameter(valid_761730, JString, required = false,
                                 default = nil)
  if valid_761730 != nil:
    section.add "username", valid_761730
  var valid_761731 = formData.getOrDefault("jira_issue_transition_id")
  valid_761731 = validateParameter(valid_761731, JInt, required = false, default = nil)
  if valid_761731 != nil:
    section.add "jira_issue_transition_id", valid_761731
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761732: Call_PutV3ProjectsIdServicesJira_761721; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Set jira service for project
  ## 
  let valid = call_761732.validator(path, query, header, formData, body)
  let scheme = call_761732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761732.url(scheme.get, call_761732.host, call_761732.base,
                         call_761732.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761732, url, valid)

proc call*(call_761733: Call_PutV3ProjectsIdServicesJira_761721; id: int;
          url: string; projectKey: string; commitEvents: string = "";
          password: string = ""; mergeRequestEvents: string = ""; username: string = "";
          jiraIssueTransitionId: int = 0): Recallable =
  ## putV3ProjectsIdServicesJira
  ## Set jira service for project
  ##   commitEvents: string
  ##               : Event will be triggered when a commit is created/updated
  ##   password: string
  ##           : The password of the user created to be used with GitLab/JIRA
  ##   id: int (required)
  ##   url: string (required)
  ##      : The URL to the JIRA project which is being linked to this GitLab project, e.g., https://jira.example.com
  ##   mergeRequestEvents: string
  ##                     : Event will be triggered when a merge request is created/updated/merged
  ##   projectKey: string (required)
  ##             : The short identifier for your JIRA project, all uppercase, e.g., PROJ
  ##   username: string
  ##           : The username of the user created to be used with GitLab/JIRA
  ##   jiraIssueTransitionId: int
  ##                        : The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (**Administration > Issues > Workflows**) by selecting **View** under **Operations** of the desired workflow of your project. The ID of each state can be found inside the parenthesis of each transition name under the **Transitions (id)** column ([see screenshot][trans]). By default, this ID is set to `2`
  var path_761734 = newJObject()
  var formData_761735 = newJObject()
  add(formData_761735, "commit_events", newJString(commitEvents))
  add(formData_761735, "password", newJString(password))
  add(path_761734, "id", newJInt(id))
  add(formData_761735, "url", newJString(url))
  add(formData_761735, "merge_request_events", newJString(mergeRequestEvents))
  add(formData_761735, "project_key", newJString(projectKey))
  add(formData_761735, "username", newJString(username))
  add(formData_761735, "jira_issue_transition_id", newJInt(jiraIssueTransitionId))
  result = call_761733.call(path_761734, nil, nil, formData_761735, nil)

var putV3ProjectsIdServicesJira* = Call_PutV3ProjectsIdServicesJira_761721(
    name: "putV3ProjectsIdServicesJira", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/jira",
    validator: validate_PutV3ProjectsIdServicesJira_761722, base: "/api",
    url: url_PutV3ProjectsIdServicesJira_761723, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesKubernetes_761736 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesKubernetes_761738(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/kubernetes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesKubernetes_761737(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set kubernetes service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761739 = path.getOrDefault("id")
  valid_761739 = validateParameter(valid_761739, JInt, required = true, default = nil)
  if valid_761739 != nil:
    section.add "id", valid_761739
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   token: JString (required)
  ##        : The service token to authenticate against the Kubernetes cluster with
  ##   api_url: JString (required)
  ##          : The URL to the Kubernetes cluster API, e.g., https://kubernetes.example.com
  ##   ca_pem: JString
  ##         : A custom certificate authority bundle to verify the Kubernetes cluster with (PEM format)
  ##   namespace: JString (required)
  ##            : The Kubernetes namespace to use
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761740 = formData.getOrDefault("token")
  valid_761740 = validateParameter(valid_761740, JString, required = true,
                                 default = nil)
  if valid_761740 != nil:
    section.add "token", valid_761740
  var valid_761741 = formData.getOrDefault("api_url")
  valid_761741 = validateParameter(valid_761741, JString, required = true,
                                 default = nil)
  if valid_761741 != nil:
    section.add "api_url", valid_761741
  var valid_761742 = formData.getOrDefault("ca_pem")
  valid_761742 = validateParameter(valid_761742, JString, required = false,
                                 default = nil)
  if valid_761742 != nil:
    section.add "ca_pem", valid_761742
  var valid_761743 = formData.getOrDefault("namespace")
  valid_761743 = validateParameter(valid_761743, JString, required = true,
                                 default = nil)
  if valid_761743 != nil:
    section.add "namespace", valid_761743
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761744: Call_PutV3ProjectsIdServicesKubernetes_761736;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set kubernetes service for project
  ## 
  let valid = call_761744.validator(path, query, header, formData, body)
  let scheme = call_761744.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761744.url(scheme.get, call_761744.host, call_761744.base,
                         call_761744.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761744, url, valid)

proc call*(call_761745: Call_PutV3ProjectsIdServicesKubernetes_761736; id: int;
          token: string; apiUrl: string; namespace: string; caPem: string = ""): Recallable =
  ## putV3ProjectsIdServicesKubernetes
  ## Set kubernetes service for project
  ##   id: int (required)
  ##   token: string (required)
  ##        : The service token to authenticate against the Kubernetes cluster with
  ##   apiUrl: string (required)
  ##         : The URL to the Kubernetes cluster API, e.g., https://kubernetes.example.com
  ##   caPem: string
  ##        : A custom certificate authority bundle to verify the Kubernetes cluster with (PEM format)
  ##   namespace: string (required)
  ##            : The Kubernetes namespace to use
  var path_761746 = newJObject()
  var formData_761747 = newJObject()
  add(path_761746, "id", newJInt(id))
  add(formData_761747, "token", newJString(token))
  add(formData_761747, "api_url", newJString(apiUrl))
  add(formData_761747, "ca_pem", newJString(caPem))
  add(formData_761747, "namespace", newJString(namespace))
  result = call_761745.call(path_761746, nil, nil, formData_761747, nil)

var putV3ProjectsIdServicesKubernetes* = Call_PutV3ProjectsIdServicesKubernetes_761736(
    name: "putV3ProjectsIdServicesKubernetes", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/kubernetes",
    validator: validate_PutV3ProjectsIdServicesKubernetes_761737, base: "/api",
    url: url_PutV3ProjectsIdServicesKubernetes_761738, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesMattermost_761748 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesMattermost_761750(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/mattermost")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesMattermost_761749(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set mattermost service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761751 = path.getOrDefault("id")
  valid_761751 = validateParameter(valid_761751, JInt, required = true, default = nil)
  if valid_761751 != nil:
    section.add "id", valid_761751
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   webhook: JString (required)
  ##          : The Mattermost webhook. e.g. http://mattermost_host/hooks/...
  ##   note_events: JString
  ##              : Event will be triggered when someone adds a comment
  ##   confidential_issue_events: JString
  ##                            : Event will be triggered when a confidential issue is created/updated/closed
  ##   pipeline_events: JString
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   wiki_page_events: JString
  ##                   : Event will be triggered when a wiki page is created/updated
  ##   merge_request_events: JString
  ##                       : Event will be triggered when a merge request is created/updated/merged
  ##   tag_push_events: JString
  ##                  : Event will be triggered when a new tag is pushed to the repository
  ##   issue_events: JString
  ##               : Event will be triggered when an issue is created/updated/closed
  ##   build_events: JString
  ##               : Event will be triggered when a build status changes
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `webhook` field"
  var valid_761752 = formData.getOrDefault("webhook")
  valid_761752 = validateParameter(valid_761752, JString, required = true,
                                 default = nil)
  if valid_761752 != nil:
    section.add "webhook", valid_761752
  var valid_761753 = formData.getOrDefault("note_events")
  valid_761753 = validateParameter(valid_761753, JString, required = false,
                                 default = nil)
  if valid_761753 != nil:
    section.add "note_events", valid_761753
  var valid_761754 = formData.getOrDefault("confidential_issue_events")
  valid_761754 = validateParameter(valid_761754, JString, required = false,
                                 default = nil)
  if valid_761754 != nil:
    section.add "confidential_issue_events", valid_761754
  var valid_761755 = formData.getOrDefault("pipeline_events")
  valid_761755 = validateParameter(valid_761755, JString, required = false,
                                 default = nil)
  if valid_761755 != nil:
    section.add "pipeline_events", valid_761755
  var valid_761756 = formData.getOrDefault("push_events")
  valid_761756 = validateParameter(valid_761756, JString, required = false,
                                 default = nil)
  if valid_761756 != nil:
    section.add "push_events", valid_761756
  var valid_761757 = formData.getOrDefault("wiki_page_events")
  valid_761757 = validateParameter(valid_761757, JString, required = false,
                                 default = nil)
  if valid_761757 != nil:
    section.add "wiki_page_events", valid_761757
  var valid_761758 = formData.getOrDefault("merge_request_events")
  valid_761758 = validateParameter(valid_761758, JString, required = false,
                                 default = nil)
  if valid_761758 != nil:
    section.add "merge_request_events", valid_761758
  var valid_761759 = formData.getOrDefault("tag_push_events")
  valid_761759 = validateParameter(valid_761759, JString, required = false,
                                 default = nil)
  if valid_761759 != nil:
    section.add "tag_push_events", valid_761759
  var valid_761760 = formData.getOrDefault("issue_events")
  valid_761760 = validateParameter(valid_761760, JString, required = false,
                                 default = nil)
  if valid_761760 != nil:
    section.add "issue_events", valid_761760
  var valid_761761 = formData.getOrDefault("build_events")
  valid_761761 = validateParameter(valid_761761, JString, required = false,
                                 default = nil)
  if valid_761761 != nil:
    section.add "build_events", valid_761761
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761762: Call_PutV3ProjectsIdServicesMattermost_761748;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set mattermost service for project
  ## 
  let valid = call_761762.validator(path, query, header, formData, body)
  let scheme = call_761762.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761762.url(scheme.get, call_761762.host, call_761762.base,
                         call_761762.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761762, url, valid)

proc call*(call_761763: Call_PutV3ProjectsIdServicesMattermost_761748;
          webhook: string; id: int; noteEvents: string = "";
          confidentialIssueEvents: string = ""; pipelineEvents: string = "";
          pushEvents: string = ""; wikiPageEvents: string = "";
          mergeRequestEvents: string = ""; tagPushEvents: string = "";
          issueEvents: string = ""; buildEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesMattermost
  ## Set mattermost service for project
  ##   webhook: string (required)
  ##          : The Mattermost webhook. e.g. http://mattermost_host/hooks/...
  ##   id: int (required)
  ##   noteEvents: string
  ##             : Event will be triggered when someone adds a comment
  ##   confidentialIssueEvents: string
  ##                          : Event will be triggered when a confidential issue is created/updated/closed
  ##   pipelineEvents: string
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   wikiPageEvents: string
  ##                 : Event will be triggered when a wiki page is created/updated
  ##   mergeRequestEvents: string
  ##                     : Event will be triggered when a merge request is created/updated/merged
  ##   tagPushEvents: string
  ##                : Event will be triggered when a new tag is pushed to the repository
  ##   issueEvents: string
  ##              : Event will be triggered when an issue is created/updated/closed
  ##   buildEvents: string
  ##              : Event will be triggered when a build status changes
  var path_761764 = newJObject()
  var formData_761765 = newJObject()
  add(formData_761765, "webhook", newJString(webhook))
  add(path_761764, "id", newJInt(id))
  add(formData_761765, "note_events", newJString(noteEvents))
  add(formData_761765, "confidential_issue_events",
      newJString(confidentialIssueEvents))
  add(formData_761765, "pipeline_events", newJString(pipelineEvents))
  add(formData_761765, "push_events", newJString(pushEvents))
  add(formData_761765, "wiki_page_events", newJString(wikiPageEvents))
  add(formData_761765, "merge_request_events", newJString(mergeRequestEvents))
  add(formData_761765, "tag_push_events", newJString(tagPushEvents))
  add(formData_761765, "issue_events", newJString(issueEvents))
  add(formData_761765, "build_events", newJString(buildEvents))
  result = call_761763.call(path_761764, nil, nil, formData_761765, nil)

var putV3ProjectsIdServicesMattermost* = Call_PutV3ProjectsIdServicesMattermost_761748(
    name: "putV3ProjectsIdServicesMattermost", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/mattermost",
    validator: validate_PutV3ProjectsIdServicesMattermost_761749, base: "/api",
    url: url_PutV3ProjectsIdServicesMattermost_761750, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesMattermostSlashCommands_761766 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesMattermostSlashCommands_761768(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"), (kind: ConstantSegment,
        value: "/services/mattermost-slash-commands")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesMattermostSlashCommands_761767(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Set mattermost-slash-commands service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761769 = path.getOrDefault("id")
  valid_761769 = validateParameter(valid_761769, JInt, required = true, default = nil)
  if valid_761769 != nil:
    section.add "id", valid_761769
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   token: JString (required)
  ##        : The Mattermost token
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761770 = formData.getOrDefault("token")
  valid_761770 = validateParameter(valid_761770, JString, required = true,
                                 default = nil)
  if valid_761770 != nil:
    section.add "token", valid_761770
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761771: Call_PutV3ProjectsIdServicesMattermostSlashCommands_761766;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set mattermost-slash-commands service for project
  ## 
  let valid = call_761771.validator(path, query, header, formData, body)
  let scheme = call_761771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761771.url(scheme.get, call_761771.host, call_761771.base,
                         call_761771.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761771, url, valid)

proc call*(call_761772: Call_PutV3ProjectsIdServicesMattermostSlashCommands_761766;
          id: int; token: string): Recallable =
  ## putV3ProjectsIdServicesMattermostSlashCommands
  ## Set mattermost-slash-commands service for project
  ##   id: int (required)
  ##   token: string (required)
  ##        : The Mattermost token
  var path_761773 = newJObject()
  var formData_761774 = newJObject()
  add(path_761773, "id", newJInt(id))
  add(formData_761774, "token", newJString(token))
  result = call_761772.call(path_761773, nil, nil, formData_761774, nil)

var putV3ProjectsIdServicesMattermostSlashCommands* = Call_PutV3ProjectsIdServicesMattermostSlashCommands_761766(
    name: "putV3ProjectsIdServicesMattermostSlashCommands",
    meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/projects/{id}/services/mattermost-slash-commands",
    validator: validate_PutV3ProjectsIdServicesMattermostSlashCommands_761767,
    base: "/api", url: url_PutV3ProjectsIdServicesMattermostSlashCommands_761768,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdServicesMattermostSlashCommandsTrigger_761775 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdServicesMattermostSlashCommandsTrigger_761777(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"), (kind: ConstantSegment,
        value: "/services/mattermost_slash_commands/trigger")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdServicesMattermostSlashCommandsTrigger_761776(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Added in GitLab 8.13
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761778 = path.getOrDefault("id")
  valid_761778 = validateParameter(valid_761778, JString, required = true,
                                 default = nil)
  if valid_761778 != nil:
    section.add "id", valid_761778
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   token: JString (required)
  ##        : The Mattermost token
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761779 = formData.getOrDefault("token")
  valid_761779 = validateParameter(valid_761779, JString, required = true,
                                 default = nil)
  if valid_761779 != nil:
    section.add "token", valid_761779
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761780: Call_PostV3ProjectsIdServicesMattermostSlashCommandsTrigger_761775;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Added in GitLab 8.13
  ## 
  let valid = call_761780.validator(path, query, header, formData, body)
  let scheme = call_761780.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761780.url(scheme.get, call_761780.host, call_761780.base,
                         call_761780.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761780, url, valid)

proc call*(call_761781: Call_PostV3ProjectsIdServicesMattermostSlashCommandsTrigger_761775;
          id: string; token: string): Recallable =
  ## postV3ProjectsIdServicesMattermostSlashCommandsTrigger
  ## Added in GitLab 8.13
  ##   id: string (required)
  ##     : The ID of a project
  ##   token: string (required)
  ##        : The Mattermost token
  var path_761782 = newJObject()
  var formData_761783 = newJObject()
  add(path_761782, "id", newJString(id))
  add(formData_761783, "token", newJString(token))
  result = call_761781.call(path_761782, nil, nil, formData_761783, nil)

var postV3ProjectsIdServicesMattermostSlashCommandsTrigger* = Call_PostV3ProjectsIdServicesMattermostSlashCommandsTrigger_761775(
    name: "postV3ProjectsIdServicesMattermostSlashCommandsTrigger",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/services/mattermost_slash_commands/trigger",
    validator: validate_PostV3ProjectsIdServicesMattermostSlashCommandsTrigger_761776,
    base: "/api", url: url_PostV3ProjectsIdServicesMattermostSlashCommandsTrigger_761777,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesPipelinesEmail_761784 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesPipelinesEmail_761786(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/pipelines-email")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesPipelinesEmail_761785(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set pipelines-email service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761787 = path.getOrDefault("id")
  valid_761787 = validateParameter(valid_761787, JInt, required = true, default = nil)
  if valid_761787 != nil:
    section.add "id", valid_761787
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   notify_only_broken_builds: JBool
  ##                            : Notify only broken builds
  ##   recipients: JString (required)
  ##             : Comma-separated list of recipient email addresses
  ##   pipeline_events: JString
  section = newJObject()
  var valid_761788 = formData.getOrDefault("notify_only_broken_builds")
  valid_761788 = validateParameter(valid_761788, JBool, required = false, default = nil)
  if valid_761788 != nil:
    section.add "notify_only_broken_builds", valid_761788
  assert formData != nil,
        "formData argument is necessary due to required `recipients` field"
  var valid_761789 = formData.getOrDefault("recipients")
  valid_761789 = validateParameter(valid_761789, JString, required = true,
                                 default = nil)
  if valid_761789 != nil:
    section.add "recipients", valid_761789
  var valid_761790 = formData.getOrDefault("pipeline_events")
  valid_761790 = validateParameter(valid_761790, JString, required = false,
                                 default = nil)
  if valid_761790 != nil:
    section.add "pipeline_events", valid_761790
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761791: Call_PutV3ProjectsIdServicesPipelinesEmail_761784;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set pipelines-email service for project
  ## 
  let valid = call_761791.validator(path, query, header, formData, body)
  let scheme = call_761791.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761791.url(scheme.get, call_761791.host, call_761791.base,
                         call_761791.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761791, url, valid)

proc call*(call_761792: Call_PutV3ProjectsIdServicesPipelinesEmail_761784; id: int;
          recipients: string; notifyOnlyBrokenBuilds: bool = false;
          pipelineEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesPipelinesEmail
  ## Set pipelines-email service for project
  ##   id: int (required)
  ##   notifyOnlyBrokenBuilds: bool
  ##                         : Notify only broken builds
  ##   recipients: string (required)
  ##             : Comma-separated list of recipient email addresses
  ##   pipelineEvents: string
  var path_761793 = newJObject()
  var formData_761794 = newJObject()
  add(path_761793, "id", newJInt(id))
  add(formData_761794, "notify_only_broken_builds",
      newJBool(notifyOnlyBrokenBuilds))
  add(formData_761794, "recipients", newJString(recipients))
  add(formData_761794, "pipeline_events", newJString(pipelineEvents))
  result = call_761792.call(path_761793, nil, nil, formData_761794, nil)

var putV3ProjectsIdServicesPipelinesEmail* = Call_PutV3ProjectsIdServicesPipelinesEmail_761784(
    name: "putV3ProjectsIdServicesPipelinesEmail", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/pipelines-email",
    validator: validate_PutV3ProjectsIdServicesPipelinesEmail_761785,
    base: "/api", url: url_PutV3ProjectsIdServicesPipelinesEmail_761786,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesPivotaltracker_761795 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesPivotaltracker_761797(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/pivotaltracker")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesPivotaltracker_761796(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set pivotaltracker service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761798 = path.getOrDefault("id")
  valid_761798 = validateParameter(valid_761798, JInt, required = true, default = nil)
  if valid_761798 != nil:
    section.add "id", valid_761798
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   restrict_to_branch: JString
  ##                     : Comma-separated list of branches which will be automatically inspected. Leave blank to include all branches.
  ##   token: JString (required)
  ##        : The Pivotaltracker token
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  section = newJObject()
  var valid_761799 = formData.getOrDefault("restrict_to_branch")
  valid_761799 = validateParameter(valid_761799, JString, required = false,
                                 default = nil)
  if valid_761799 != nil:
    section.add "restrict_to_branch", valid_761799
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761800 = formData.getOrDefault("token")
  valid_761800 = validateParameter(valid_761800, JString, required = true,
                                 default = nil)
  if valid_761800 != nil:
    section.add "token", valid_761800
  var valid_761801 = formData.getOrDefault("push_events")
  valid_761801 = validateParameter(valid_761801, JString, required = false,
                                 default = nil)
  if valid_761801 != nil:
    section.add "push_events", valid_761801
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761802: Call_PutV3ProjectsIdServicesPivotaltracker_761795;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set pivotaltracker service for project
  ## 
  let valid = call_761802.validator(path, query, header, formData, body)
  let scheme = call_761802.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761802.url(scheme.get, call_761802.host, call_761802.base,
                         call_761802.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761802, url, valid)

proc call*(call_761803: Call_PutV3ProjectsIdServicesPivotaltracker_761795; id: int;
          token: string; restrictToBranch: string = ""; pushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesPivotaltracker
  ## Set pivotaltracker service for project
  ##   restrictToBranch: string
  ##                   : Comma-separated list of branches which will be automatically inspected. Leave blank to include all branches.
  ##   id: int (required)
  ##   token: string (required)
  ##        : The Pivotaltracker token
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  var path_761804 = newJObject()
  var formData_761805 = newJObject()
  add(formData_761805, "restrict_to_branch", newJString(restrictToBranch))
  add(path_761804, "id", newJInt(id))
  add(formData_761805, "token", newJString(token))
  add(formData_761805, "push_events", newJString(pushEvents))
  result = call_761803.call(path_761804, nil, nil, formData_761805, nil)

var putV3ProjectsIdServicesPivotaltracker* = Call_PutV3ProjectsIdServicesPivotaltracker_761795(
    name: "putV3ProjectsIdServicesPivotaltracker", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/pivotaltracker",
    validator: validate_PutV3ProjectsIdServicesPivotaltracker_761796,
    base: "/api", url: url_PutV3ProjectsIdServicesPivotaltracker_761797,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesPushover_761806 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesPushover_761808(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/pushover")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesPushover_761807(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set pushover service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761809 = path.getOrDefault("id")
  valid_761809 = validateParameter(valid_761809, JInt, required = true, default = nil)
  if valid_761809 != nil:
    section.add "id", valid_761809
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   sound: JString (required)
  ##        : The sound of the notification
  ##   api_key: JString (required)
  ##          : The application key
  ##   user_key: JString (required)
  ##           : The user key
  ##   device: JString (required)
  ##         : Leave blank for all active devices
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   priority: JString (required)
  ##           : The priority
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `sound` field"
  var valid_761810 = formData.getOrDefault("sound")
  valid_761810 = validateParameter(valid_761810, JString, required = true,
                                 default = nil)
  if valid_761810 != nil:
    section.add "sound", valid_761810
  var valid_761811 = formData.getOrDefault("api_key")
  valid_761811 = validateParameter(valid_761811, JString, required = true,
                                 default = nil)
  if valid_761811 != nil:
    section.add "api_key", valid_761811
  var valid_761812 = formData.getOrDefault("user_key")
  valid_761812 = validateParameter(valid_761812, JString, required = true,
                                 default = nil)
  if valid_761812 != nil:
    section.add "user_key", valid_761812
  var valid_761813 = formData.getOrDefault("device")
  valid_761813 = validateParameter(valid_761813, JString, required = true,
                                 default = nil)
  if valid_761813 != nil:
    section.add "device", valid_761813
  var valid_761814 = formData.getOrDefault("push_events")
  valid_761814 = validateParameter(valid_761814, JString, required = false,
                                 default = nil)
  if valid_761814 != nil:
    section.add "push_events", valid_761814
  var valid_761815 = formData.getOrDefault("priority")
  valid_761815 = validateParameter(valid_761815, JString, required = true,
                                 default = nil)
  if valid_761815 != nil:
    section.add "priority", valid_761815
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761816: Call_PutV3ProjectsIdServicesPushover_761806;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set pushover service for project
  ## 
  let valid = call_761816.validator(path, query, header, formData, body)
  let scheme = call_761816.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761816.url(scheme.get, call_761816.host, call_761816.base,
                         call_761816.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761816, url, valid)

proc call*(call_761817: Call_PutV3ProjectsIdServicesPushover_761806; sound: string;
          id: int; apiKey: string; userKey: string; device: string; priority: string;
          pushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesPushover
  ## Set pushover service for project
  ##   sound: string (required)
  ##        : The sound of the notification
  ##   id: int (required)
  ##   apiKey: string (required)
  ##         : The application key
  ##   userKey: string (required)
  ##          : The user key
  ##   device: string (required)
  ##         : Leave blank for all active devices
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   priority: string (required)
  ##           : The priority
  var path_761818 = newJObject()
  var formData_761819 = newJObject()
  add(formData_761819, "sound", newJString(sound))
  add(path_761818, "id", newJInt(id))
  add(formData_761819, "api_key", newJString(apiKey))
  add(formData_761819, "user_key", newJString(userKey))
  add(formData_761819, "device", newJString(device))
  add(formData_761819, "push_events", newJString(pushEvents))
  add(formData_761819, "priority", newJString(priority))
  result = call_761817.call(path_761818, nil, nil, formData_761819, nil)

var putV3ProjectsIdServicesPushover* = Call_PutV3ProjectsIdServicesPushover_761806(
    name: "putV3ProjectsIdServicesPushover", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/pushover",
    validator: validate_PutV3ProjectsIdServicesPushover_761807, base: "/api",
    url: url_PutV3ProjectsIdServicesPushover_761808, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesRedmine_761820 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesRedmine_761822(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/redmine")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesRedmine_761821(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set redmine service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761823 = path.getOrDefault("id")
  valid_761823 = validateParameter(valid_761823, JInt, required = true, default = nil)
  if valid_761823 != nil:
    section.add "id", valid_761823
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   issues_url: JString (required)
  ##             : The issues URL
  ##   project_url: JString (required)
  ##              : The project URL
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   description: JString
  ##              : The description of the tracker
  ##   new_issue_url: JString (required)
  ##                : The new issue URL
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `issues_url` field"
  var valid_761824 = formData.getOrDefault("issues_url")
  valid_761824 = validateParameter(valid_761824, JString, required = true,
                                 default = nil)
  if valid_761824 != nil:
    section.add "issues_url", valid_761824
  var valid_761825 = formData.getOrDefault("project_url")
  valid_761825 = validateParameter(valid_761825, JString, required = true,
                                 default = nil)
  if valid_761825 != nil:
    section.add "project_url", valid_761825
  var valid_761826 = formData.getOrDefault("push_events")
  valid_761826 = validateParameter(valid_761826, JString, required = false,
                                 default = nil)
  if valid_761826 != nil:
    section.add "push_events", valid_761826
  var valid_761827 = formData.getOrDefault("description")
  valid_761827 = validateParameter(valid_761827, JString, required = false,
                                 default = nil)
  if valid_761827 != nil:
    section.add "description", valid_761827
  var valid_761828 = formData.getOrDefault("new_issue_url")
  valid_761828 = validateParameter(valid_761828, JString, required = true,
                                 default = nil)
  if valid_761828 != nil:
    section.add "new_issue_url", valid_761828
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761829: Call_PutV3ProjectsIdServicesRedmine_761820; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Set redmine service for project
  ## 
  let valid = call_761829.validator(path, query, header, formData, body)
  let scheme = call_761829.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761829.url(scheme.get, call_761829.host, call_761829.base,
                         call_761829.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761829, url, valid)

proc call*(call_761830: Call_PutV3ProjectsIdServicesRedmine_761820; id: int;
          issuesUrl: string; projectUrl: string; newIssueUrl: string;
          pushEvents: string = ""; description: string = ""): Recallable =
  ## putV3ProjectsIdServicesRedmine
  ## Set redmine service for project
  ##   id: int (required)
  ##   issuesUrl: string (required)
  ##            : The issues URL
  ##   projectUrl: string (required)
  ##             : The project URL
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   description: string
  ##              : The description of the tracker
  ##   newIssueUrl: string (required)
  ##              : The new issue URL
  var path_761831 = newJObject()
  var formData_761832 = newJObject()
  add(path_761831, "id", newJInt(id))
  add(formData_761832, "issues_url", newJString(issuesUrl))
  add(formData_761832, "project_url", newJString(projectUrl))
  add(formData_761832, "push_events", newJString(pushEvents))
  add(formData_761832, "description", newJString(description))
  add(formData_761832, "new_issue_url", newJString(newIssueUrl))
  result = call_761830.call(path_761831, nil, nil, formData_761832, nil)

var putV3ProjectsIdServicesRedmine* = Call_PutV3ProjectsIdServicesRedmine_761820(
    name: "putV3ProjectsIdServicesRedmine", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/redmine",
    validator: validate_PutV3ProjectsIdServicesRedmine_761821, base: "/api",
    url: url_PutV3ProjectsIdServicesRedmine_761822, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesSlack_761833 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesSlack_761835(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/slack")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesSlack_761834(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set slack service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761836 = path.getOrDefault("id")
  valid_761836 = validateParameter(valid_761836, JInt, required = true, default = nil)
  if valid_761836 != nil:
    section.add "id", valid_761836
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   webhook: JString (required)
  ##          : The Slack webhook. e.g. https://hooks.slack.com/services/...
  ##   channel: JString
  ##          : The channel name
  ##   note_events: JString
  ##              : Event will be triggered when someone adds a comment
  ##   confidential_issue_events: JString
  ##                            : Event will be triggered when a confidential issue is created/updated/closed
  ##   pipeline_events: JString
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   wiki_page_events: JString
  ##                   : Event will be triggered when a wiki page is created/updated
  ##   merge_request_events: JString
  ##                       : Event will be triggered when a merge request is created/updated/merged
  ##   tag_push_events: JString
  ##                  : Event will be triggered when a new tag is pushed to the repository
  ##   issue_events: JString
  ##               : Event will be triggered when an issue is created/updated/closed
  ##   new_issue_url: JString
  ##                : The user name
  ##   build_events: JString
  ##               : Event will be triggered when a build status changes
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `webhook` field"
  var valid_761837 = formData.getOrDefault("webhook")
  valid_761837 = validateParameter(valid_761837, JString, required = true,
                                 default = nil)
  if valid_761837 != nil:
    section.add "webhook", valid_761837
  var valid_761838 = formData.getOrDefault("channel")
  valid_761838 = validateParameter(valid_761838, JString, required = false,
                                 default = nil)
  if valid_761838 != nil:
    section.add "channel", valid_761838
  var valid_761839 = formData.getOrDefault("note_events")
  valid_761839 = validateParameter(valid_761839, JString, required = false,
                                 default = nil)
  if valid_761839 != nil:
    section.add "note_events", valid_761839
  var valid_761840 = formData.getOrDefault("confidential_issue_events")
  valid_761840 = validateParameter(valid_761840, JString, required = false,
                                 default = nil)
  if valid_761840 != nil:
    section.add "confidential_issue_events", valid_761840
  var valid_761841 = formData.getOrDefault("pipeline_events")
  valid_761841 = validateParameter(valid_761841, JString, required = false,
                                 default = nil)
  if valid_761841 != nil:
    section.add "pipeline_events", valid_761841
  var valid_761842 = formData.getOrDefault("push_events")
  valid_761842 = validateParameter(valid_761842, JString, required = false,
                                 default = nil)
  if valid_761842 != nil:
    section.add "push_events", valid_761842
  var valid_761843 = formData.getOrDefault("wiki_page_events")
  valid_761843 = validateParameter(valid_761843, JString, required = false,
                                 default = nil)
  if valid_761843 != nil:
    section.add "wiki_page_events", valid_761843
  var valid_761844 = formData.getOrDefault("merge_request_events")
  valid_761844 = validateParameter(valid_761844, JString, required = false,
                                 default = nil)
  if valid_761844 != nil:
    section.add "merge_request_events", valid_761844
  var valid_761845 = formData.getOrDefault("tag_push_events")
  valid_761845 = validateParameter(valid_761845, JString, required = false,
                                 default = nil)
  if valid_761845 != nil:
    section.add "tag_push_events", valid_761845
  var valid_761846 = formData.getOrDefault("issue_events")
  valid_761846 = validateParameter(valid_761846, JString, required = false,
                                 default = nil)
  if valid_761846 != nil:
    section.add "issue_events", valid_761846
  var valid_761847 = formData.getOrDefault("new_issue_url")
  valid_761847 = validateParameter(valid_761847, JString, required = false,
                                 default = nil)
  if valid_761847 != nil:
    section.add "new_issue_url", valid_761847
  var valid_761848 = formData.getOrDefault("build_events")
  valid_761848 = validateParameter(valid_761848, JString, required = false,
                                 default = nil)
  if valid_761848 != nil:
    section.add "build_events", valid_761848
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761849: Call_PutV3ProjectsIdServicesSlack_761833; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Set slack service for project
  ## 
  let valid = call_761849.validator(path, query, header, formData, body)
  let scheme = call_761849.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761849.url(scheme.get, call_761849.host, call_761849.base,
                         call_761849.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761849, url, valid)

proc call*(call_761850: Call_PutV3ProjectsIdServicesSlack_761833; webhook: string;
          id: int; channel: string = ""; noteEvents: string = "";
          confidentialIssueEvents: string = ""; pipelineEvents: string = "";
          pushEvents: string = ""; wikiPageEvents: string = "";
          mergeRequestEvents: string = ""; tagPushEvents: string = "";
          issueEvents: string = ""; newIssueUrl: string = ""; buildEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesSlack
  ## Set slack service for project
  ##   webhook: string (required)
  ##          : The Slack webhook. e.g. https://hooks.slack.com/services/...
  ##   channel: string
  ##          : The channel name
  ##   id: int (required)
  ##   noteEvents: string
  ##             : Event will be triggered when someone adds a comment
  ##   confidentialIssueEvents: string
  ##                          : Event will be triggered when a confidential issue is created/updated/closed
  ##   pipelineEvents: string
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   wikiPageEvents: string
  ##                 : Event will be triggered when a wiki page is created/updated
  ##   mergeRequestEvents: string
  ##                     : Event will be triggered when a merge request is created/updated/merged
  ##   tagPushEvents: string
  ##                : Event will be triggered when a new tag is pushed to the repository
  ##   issueEvents: string
  ##              : Event will be triggered when an issue is created/updated/closed
  ##   newIssueUrl: string
  ##              : The user name
  ##   buildEvents: string
  ##              : Event will be triggered when a build status changes
  var path_761851 = newJObject()
  var formData_761852 = newJObject()
  add(formData_761852, "webhook", newJString(webhook))
  add(formData_761852, "channel", newJString(channel))
  add(path_761851, "id", newJInt(id))
  add(formData_761852, "note_events", newJString(noteEvents))
  add(formData_761852, "confidential_issue_events",
      newJString(confidentialIssueEvents))
  add(formData_761852, "pipeline_events", newJString(pipelineEvents))
  add(formData_761852, "push_events", newJString(pushEvents))
  add(formData_761852, "wiki_page_events", newJString(wikiPageEvents))
  add(formData_761852, "merge_request_events", newJString(mergeRequestEvents))
  add(formData_761852, "tag_push_events", newJString(tagPushEvents))
  add(formData_761852, "issue_events", newJString(issueEvents))
  add(formData_761852, "new_issue_url", newJString(newIssueUrl))
  add(formData_761852, "build_events", newJString(buildEvents))
  result = call_761850.call(path_761851, nil, nil, formData_761852, nil)

var putV3ProjectsIdServicesSlack* = Call_PutV3ProjectsIdServicesSlack_761833(
    name: "putV3ProjectsIdServicesSlack", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/slack",
    validator: validate_PutV3ProjectsIdServicesSlack_761834, base: "/api",
    url: url_PutV3ProjectsIdServicesSlack_761835, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesSlackSlashCommands_761853 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesSlackSlashCommands_761855(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/slack-slash-commands")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesSlackSlashCommands_761854(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set slack-slash-commands service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761856 = path.getOrDefault("id")
  valid_761856 = validateParameter(valid_761856, JInt, required = true, default = nil)
  if valid_761856 != nil:
    section.add "id", valid_761856
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   token: JString (required)
  ##        : The Slack token
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761857 = formData.getOrDefault("token")
  valid_761857 = validateParameter(valid_761857, JString, required = true,
                                 default = nil)
  if valid_761857 != nil:
    section.add "token", valid_761857
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761858: Call_PutV3ProjectsIdServicesSlackSlashCommands_761853;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set slack-slash-commands service for project
  ## 
  let valid = call_761858.validator(path, query, header, formData, body)
  let scheme = call_761858.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761858.url(scheme.get, call_761858.host, call_761858.base,
                         call_761858.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761858, url, valid)

proc call*(call_761859: Call_PutV3ProjectsIdServicesSlackSlashCommands_761853;
          id: int; token: string): Recallable =
  ## putV3ProjectsIdServicesSlackSlashCommands
  ## Set slack-slash-commands service for project
  ##   id: int (required)
  ##   token: string (required)
  ##        : The Slack token
  var path_761860 = newJObject()
  var formData_761861 = newJObject()
  add(path_761860, "id", newJInt(id))
  add(formData_761861, "token", newJString(token))
  result = call_761859.call(path_761860, nil, nil, formData_761861, nil)

var putV3ProjectsIdServicesSlackSlashCommands* = Call_PutV3ProjectsIdServicesSlackSlashCommands_761853(
    name: "putV3ProjectsIdServicesSlackSlashCommands", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/slack-slash-commands",
    validator: validate_PutV3ProjectsIdServicesSlackSlashCommands_761854,
    base: "/api", url: url_PutV3ProjectsIdServicesSlackSlashCommands_761855,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdServicesSlackSlashCommandsTrigger_761862 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdServicesSlackSlashCommandsTrigger_761864(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"), (kind: ConstantSegment,
        value: "/services/slack_slash_commands/trigger")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdServicesSlackSlashCommandsTrigger_761863(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Added in GitLab 8.13
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761865 = path.getOrDefault("id")
  valid_761865 = validateParameter(valid_761865, JString, required = true,
                                 default = nil)
  if valid_761865 != nil:
    section.add "id", valid_761865
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   token: JString (required)
  ##        : The Slack token
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `token` field"
  var valid_761866 = formData.getOrDefault("token")
  valid_761866 = validateParameter(valid_761866, JString, required = true,
                                 default = nil)
  if valid_761866 != nil:
    section.add "token", valid_761866
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761867: Call_PostV3ProjectsIdServicesSlackSlashCommandsTrigger_761862;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Added in GitLab 8.13
  ## 
  let valid = call_761867.validator(path, query, header, formData, body)
  let scheme = call_761867.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761867.url(scheme.get, call_761867.host, call_761867.base,
                         call_761867.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761867, url, valid)

proc call*(call_761868: Call_PostV3ProjectsIdServicesSlackSlashCommandsTrigger_761862;
          id: string; token: string): Recallable =
  ## postV3ProjectsIdServicesSlackSlashCommandsTrigger
  ## Added in GitLab 8.13
  ##   id: string (required)
  ##     : The ID of a project
  ##   token: string (required)
  ##        : The Slack token
  var path_761869 = newJObject()
  var formData_761870 = newJObject()
  add(path_761869, "id", newJString(id))
  add(formData_761870, "token", newJString(token))
  result = call_761868.call(path_761869, nil, nil, formData_761870, nil)

var postV3ProjectsIdServicesSlackSlashCommandsTrigger* = Call_PostV3ProjectsIdServicesSlackSlashCommandsTrigger_761862(
    name: "postV3ProjectsIdServicesSlackSlashCommandsTrigger",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/services/slack_slash_commands/trigger",
    validator: validate_PostV3ProjectsIdServicesSlackSlashCommandsTrigger_761863,
    base: "/api", url: url_PostV3ProjectsIdServicesSlackSlashCommandsTrigger_761864,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdServicesTeamcity_761871 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdServicesTeamcity_761873(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/teamcity")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdServicesTeamcity_761872(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set teamcity service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761874 = path.getOrDefault("id")
  valid_761874 = validateParameter(valid_761874, JInt, required = true, default = nil)
  if valid_761874 != nil:
    section.add "id", valid_761874
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   password: JString (required)
  ##           : The password of the user
  ##   teamcity_url: JString (required)
  ##               : TeamCity root URL like https://teamcity.example.com
  ##   build_type: JString (required)
  ##             : Build configuration ID
  ##   push_events: JString
  ##              : Event will be triggered by a push to the repository
  ##   username: JString (required)
  ##           : A user with permissions to trigger a manual build
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `password` field"
  var valid_761875 = formData.getOrDefault("password")
  valid_761875 = validateParameter(valid_761875, JString, required = true,
                                 default = nil)
  if valid_761875 != nil:
    section.add "password", valid_761875
  var valid_761876 = formData.getOrDefault("teamcity_url")
  valid_761876 = validateParameter(valid_761876, JString, required = true,
                                 default = nil)
  if valid_761876 != nil:
    section.add "teamcity_url", valid_761876
  var valid_761877 = formData.getOrDefault("build_type")
  valid_761877 = validateParameter(valid_761877, JString, required = true,
                                 default = nil)
  if valid_761877 != nil:
    section.add "build_type", valid_761877
  var valid_761878 = formData.getOrDefault("push_events")
  valid_761878 = validateParameter(valid_761878, JString, required = false,
                                 default = nil)
  if valid_761878 != nil:
    section.add "push_events", valid_761878
  var valid_761879 = formData.getOrDefault("username")
  valid_761879 = validateParameter(valid_761879, JString, required = true,
                                 default = nil)
  if valid_761879 != nil:
    section.add "username", valid_761879
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761880: Call_PutV3ProjectsIdServicesTeamcity_761871;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set teamcity service for project
  ## 
  let valid = call_761880.validator(path, query, header, formData, body)
  let scheme = call_761880.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761880.url(scheme.get, call_761880.host, call_761880.base,
                         call_761880.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761880, url, valid)

proc call*(call_761881: Call_PutV3ProjectsIdServicesTeamcity_761871;
          password: string; teamcityUrl: string; id: int; buildType: string;
          username: string; pushEvents: string = ""): Recallable =
  ## putV3ProjectsIdServicesTeamcity
  ## Set teamcity service for project
  ##   password: string (required)
  ##           : The password of the user
  ##   teamcityUrl: string (required)
  ##              : TeamCity root URL like https://teamcity.example.com
  ##   id: int (required)
  ##   buildType: string (required)
  ##            : Build configuration ID
  ##   pushEvents: string
  ##             : Event will be triggered by a push to the repository
  ##   username: string (required)
  ##           : A user with permissions to trigger a manual build
  var path_761882 = newJObject()
  var formData_761883 = newJObject()
  add(formData_761883, "password", newJString(password))
  add(formData_761883, "teamcity_url", newJString(teamcityUrl))
  add(path_761882, "id", newJInt(id))
  add(formData_761883, "build_type", newJString(buildType))
  add(formData_761883, "push_events", newJString(pushEvents))
  add(formData_761883, "username", newJString(username))
  result = call_761881.call(path_761882, nil, nil, formData_761883, nil)

var putV3ProjectsIdServicesTeamcity* = Call_PutV3ProjectsIdServicesTeamcity_761871(
    name: "putV3ProjectsIdServicesTeamcity", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/services/teamcity",
    validator: validate_PutV3ProjectsIdServicesTeamcity_761872, base: "/api",
    url: url_PutV3ProjectsIdServicesTeamcity_761873, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdServicesServiceSlug_761884 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdServicesServiceSlug_761886(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "service_slug" in path, "`service_slug` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/"),
               (kind: VariableSegment, value: "service_slug")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdServicesServiceSlug_761885(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the service settings for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   service_slug: JString (required)
  ##               : The name of the service
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761887 = path.getOrDefault("id")
  valid_761887 = validateParameter(valid_761887, JInt, required = true, default = nil)
  if valid_761887 != nil:
    section.add "id", valid_761887
  var valid_761888 = path.getOrDefault("service_slug")
  valid_761888 = validateParameter(valid_761888, JString, required = true,
                                 default = newJString("asana"))
  if valid_761888 != nil:
    section.add "service_slug", valid_761888
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761889: Call_GetV3ProjectsIdServicesServiceSlug_761884;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the service settings for project
  ## 
  let valid = call_761889.validator(path, query, header, formData, body)
  let scheme = call_761889.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761889.url(scheme.get, call_761889.host, call_761889.base,
                         call_761889.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761889, url, valid)

proc call*(call_761890: Call_GetV3ProjectsIdServicesServiceSlug_761884; id: int;
          serviceSlug: string = "asana"): Recallable =
  ## getV3ProjectsIdServicesServiceSlug
  ## Get the service settings for project
  ##   id: int (required)
  ##   serviceSlug: string (required)
  ##              : The name of the service
  var path_761891 = newJObject()
  add(path_761891, "id", newJInt(id))
  add(path_761891, "service_slug", newJString(serviceSlug))
  result = call_761890.call(path_761891, nil, nil, nil, nil)

var getV3ProjectsIdServicesServiceSlug* = Call_GetV3ProjectsIdServicesServiceSlug_761884(
    name: "getV3ProjectsIdServicesServiceSlug", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/services/{service_slug}",
    validator: validate_GetV3ProjectsIdServicesServiceSlug_761885, base: "/api",
    url: url_GetV3ProjectsIdServicesServiceSlug_761886, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdServicesServiceSlug_761892 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdServicesServiceSlug_761894(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "service_slug" in path, "`service_slug` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/services/"),
               (kind: VariableSegment, value: "service_slug")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdServicesServiceSlug_761893(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a service for project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   service_slug: JString (required)
  ##               : The name of the service
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761895 = path.getOrDefault("id")
  valid_761895 = validateParameter(valid_761895, JInt, required = true, default = nil)
  if valid_761895 != nil:
    section.add "id", valid_761895
  var valid_761896 = path.getOrDefault("service_slug")
  valid_761896 = validateParameter(valid_761896, JString, required = true,
                                 default = newJString("asana"))
  if valid_761896 != nil:
    section.add "service_slug", valid_761896
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761897: Call_DeleteV3ProjectsIdServicesServiceSlug_761892;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a service for project
  ## 
  let valid = call_761897.validator(path, query, header, formData, body)
  let scheme = call_761897.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761897.url(scheme.get, call_761897.host, call_761897.base,
                         call_761897.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761897, url, valid)

proc call*(call_761898: Call_DeleteV3ProjectsIdServicesServiceSlug_761892; id: int;
          serviceSlug: string = "asana"): Recallable =
  ## deleteV3ProjectsIdServicesServiceSlug
  ## Delete a service for project
  ##   id: int (required)
  ##   serviceSlug: string (required)
  ##              : The name of the service
  var path_761899 = newJObject()
  add(path_761899, "id", newJInt(id))
  add(path_761899, "service_slug", newJString(serviceSlug))
  result = call_761898.call(path_761899, nil, nil, nil, nil)

var deleteV3ProjectsIdServicesServiceSlug* = Call_DeleteV3ProjectsIdServicesServiceSlug_761892(
    name: "deleteV3ProjectsIdServicesServiceSlug", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/services/{service_slug}",
    validator: validate_DeleteV3ProjectsIdServicesServiceSlug_761893,
    base: "/api", url: url_DeleteV3ProjectsIdServicesServiceSlug_761894,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdShare_761900 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdShare_761902(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/share")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdShare_761901(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Share the project with a group
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761903 = path.getOrDefault("id")
  valid_761903 = validateParameter(valid_761903, JString, required = true,
                                 default = nil)
  if valid_761903 != nil:
    section.add "id", valid_761903
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   group_id: JInt (required)
  ##           : The ID of a group
  ##   expires_at: JString
  ##             : Share expiration date
  ##   group_access: JInt (required)
  ##               : The group access level
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `group_id` field"
  var valid_761904 = formData.getOrDefault("group_id")
  valid_761904 = validateParameter(valid_761904, JInt, required = true, default = nil)
  if valid_761904 != nil:
    section.add "group_id", valid_761904
  var valid_761905 = formData.getOrDefault("expires_at")
  valid_761905 = validateParameter(valid_761905, JString, required = false,
                                 default = nil)
  if valid_761905 != nil:
    section.add "expires_at", valid_761905
  var valid_761906 = formData.getOrDefault("group_access")
  valid_761906 = validateParameter(valid_761906, JInt, required = true, default = nil)
  if valid_761906 != nil:
    section.add "group_access", valid_761906
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761907: Call_PostV3ProjectsIdShare_761900; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Share the project with a group
  ## 
  let valid = call_761907.validator(path, query, header, formData, body)
  let scheme = call_761907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761907.url(scheme.get, call_761907.host, call_761907.base,
                         call_761907.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761907, url, valid)

proc call*(call_761908: Call_PostV3ProjectsIdShare_761900; id: string; groupId: int;
          groupAccess: int; expiresAt: string = ""): Recallable =
  ## postV3ProjectsIdShare
  ## Share the project with a group
  ##   id: string (required)
  ##     : The ID of a project
  ##   groupId: int (required)
  ##          : The ID of a group
  ##   expiresAt: string
  ##            : Share expiration date
  ##   groupAccess: int (required)
  ##              : The group access level
  var path_761909 = newJObject()
  var formData_761910 = newJObject()
  add(path_761909, "id", newJString(id))
  add(formData_761910, "group_id", newJInt(groupId))
  add(formData_761910, "expires_at", newJString(expiresAt))
  add(formData_761910, "group_access", newJInt(groupAccess))
  result = call_761908.call(path_761909, nil, nil, formData_761910, nil)

var postV3ProjectsIdShare* = Call_PostV3ProjectsIdShare_761900(
    name: "postV3ProjectsIdShare", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/share", validator: validate_PostV3ProjectsIdShare_761901,
    base: "/api", url: url_PostV3ProjectsIdShare_761902, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdShareGroupId_761911 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdShareGroupId_761913(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "group_id" in path, "`group_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/share/"),
               (kind: VariableSegment, value: "group_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdShareGroupId_761912(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   group_id: JInt (required)
  ##           : The ID of the group
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761914 = path.getOrDefault("id")
  valid_761914 = validateParameter(valid_761914, JString, required = true,
                                 default = nil)
  if valid_761914 != nil:
    section.add "id", valid_761914
  var valid_761915 = path.getOrDefault("group_id")
  valid_761915 = validateParameter(valid_761915, JInt, required = true, default = nil)
  if valid_761915 != nil:
    section.add "group_id", valid_761915
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761916: Call_DeleteV3ProjectsIdShareGroupId_761911; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  let valid = call_761916.validator(path, query, header, formData, body)
  let scheme = call_761916.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761916.url(scheme.get, call_761916.host, call_761916.base,
                         call_761916.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761916, url, valid)

proc call*(call_761917: Call_DeleteV3ProjectsIdShareGroupId_761911; id: string;
          groupId: int): Recallable =
  ## deleteV3ProjectsIdShareGroupId
  ##   id: string (required)
  ##     : The ID of a project
  ##   groupId: int (required)
  ##          : The ID of the group
  var path_761918 = newJObject()
  add(path_761918, "id", newJString(id))
  add(path_761918, "group_id", newJInt(groupId))
  result = call_761917.call(path_761918, nil, nil, nil, nil)

var deleteV3ProjectsIdShareGroupId* = Call_DeleteV3ProjectsIdShareGroupId_761911(
    name: "deleteV3ProjectsIdShareGroupId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/share/{group_id}",
    validator: validate_DeleteV3ProjectsIdShareGroupId_761912, base: "/api",
    url: url_DeleteV3ProjectsIdShareGroupId_761913, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdSnippets_761929 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdSnippets_761931(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdSnippets_761930(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new project snippet
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761932 = path.getOrDefault("id")
  valid_761932 = validateParameter(valid_761932, JString, required = true,
                                 default = nil)
  if valid_761932 != nil:
    section.add "id", valid_761932
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   file_name: JString (required)
  ##            : The file name of the snippet
  ##   title: JString (required)
  ##        : The title of the snippet
  ##   code: JString (required)
  ##       : The content of the snippet
  ##   visibility_level: JInt (required)
  ##                   : The visibility level of the snippet
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `file_name` field"
  var valid_761933 = formData.getOrDefault("file_name")
  valid_761933 = validateParameter(valid_761933, JString, required = true,
                                 default = nil)
  if valid_761933 != nil:
    section.add "file_name", valid_761933
  var valid_761934 = formData.getOrDefault("title")
  valid_761934 = validateParameter(valid_761934, JString, required = true,
                                 default = nil)
  if valid_761934 != nil:
    section.add "title", valid_761934
  var valid_761935 = formData.getOrDefault("code")
  valid_761935 = validateParameter(valid_761935, JString, required = true,
                                 default = nil)
  if valid_761935 != nil:
    section.add "code", valid_761935
  var valid_761936 = formData.getOrDefault("visibility_level")
  valid_761936 = validateParameter(valid_761936, JInt, required = true, default = nil)
  if valid_761936 != nil:
    section.add "visibility_level", valid_761936
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761937: Call_PostV3ProjectsIdSnippets_761929; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new project snippet
  ## 
  let valid = call_761937.validator(path, query, header, formData, body)
  let scheme = call_761937.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761937.url(scheme.get, call_761937.host, call_761937.base,
                         call_761937.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761937, url, valid)

proc call*(call_761938: Call_PostV3ProjectsIdSnippets_761929; fileName: string;
          title: string; id: string; code: string; visibilityLevel: int): Recallable =
  ## postV3ProjectsIdSnippets
  ## Create a new project snippet
  ##   fileName: string (required)
  ##           : The file name of the snippet
  ##   title: string (required)
  ##        : The title of the snippet
  ##   id: string (required)
  ##     : The ID of a project
  ##   code: string (required)
  ##       : The content of the snippet
  ##   visibilityLevel: int (required)
  ##                  : The visibility level of the snippet
  var path_761939 = newJObject()
  var formData_761940 = newJObject()
  add(formData_761940, "file_name", newJString(fileName))
  add(formData_761940, "title", newJString(title))
  add(path_761939, "id", newJString(id))
  add(formData_761940, "code", newJString(code))
  add(formData_761940, "visibility_level", newJInt(visibilityLevel))
  result = call_761938.call(path_761939, nil, nil, formData_761940, nil)

var postV3ProjectsIdSnippets* = Call_PostV3ProjectsIdSnippets_761929(
    name: "postV3ProjectsIdSnippets", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/snippets",
    validator: validate_PostV3ProjectsIdSnippets_761930, base: "/api",
    url: url_PostV3ProjectsIdSnippets_761931, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdSnippets_761919 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdSnippets_761921(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdSnippets_761920(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get all project snippets
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761922 = path.getOrDefault("id")
  valid_761922 = validateParameter(valid_761922, JString, required = true,
                                 default = nil)
  if valid_761922 != nil:
    section.add "id", valid_761922
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_761923 = query.getOrDefault("per_page")
  valid_761923 = validateParameter(valid_761923, JInt, required = false, default = nil)
  if valid_761923 != nil:
    section.add "per_page", valid_761923
  var valid_761924 = query.getOrDefault("page")
  valid_761924 = validateParameter(valid_761924, JInt, required = false, default = nil)
  if valid_761924 != nil:
    section.add "page", valid_761924
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761925: Call_GetV3ProjectsIdSnippets_761919; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get all project snippets
  ## 
  let valid = call_761925.validator(path, query, header, formData, body)
  let scheme = call_761925.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761925.url(scheme.get, call_761925.host, call_761925.base,
                         call_761925.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761925, url, valid)

proc call*(call_761926: Call_GetV3ProjectsIdSnippets_761919; id: string;
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdSnippets
  ## Get all project snippets
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_761927 = newJObject()
  var query_761928 = newJObject()
  add(path_761927, "id", newJString(id))
  add(query_761928, "per_page", newJInt(perPage))
  add(query_761928, "page", newJInt(page))
  result = call_761926.call(path_761927, query_761928, nil, nil, nil)

var getV3ProjectsIdSnippets* = Call_GetV3ProjectsIdSnippets_761919(
    name: "getV3ProjectsIdSnippets", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/snippets",
    validator: validate_GetV3ProjectsIdSnippets_761920, base: "/api",
    url: url_GetV3ProjectsIdSnippets_761921, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdSnippetsNoteableIdNotes_761952 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdSnippetsNoteableIdNotes_761954(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdSnippetsNoteableIdNotes_761953(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761955 = path.getOrDefault("id")
  valid_761955 = validateParameter(valid_761955, JString, required = true,
                                 default = nil)
  if valid_761955 != nil:
    section.add "id", valid_761955
  var valid_761956 = path.getOrDefault("noteable_id")
  valid_761956 = validateParameter(valid_761956, JInt, required = true, default = nil)
  if valid_761956 != nil:
    section.add "noteable_id", valid_761956
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   created_at: JString
  ##             : The creation date of the note
  ##   body: JString (required)
  ##       : The content of a note
  section = newJObject()
  var valid_761957 = formData.getOrDefault("created_at")
  valid_761957 = validateParameter(valid_761957, JString, required = false,
                                 default = nil)
  if valid_761957 != nil:
    section.add "created_at", valid_761957
  assert formData != nil,
        "formData argument is necessary due to required `body` field"
  var valid_761958 = formData.getOrDefault("body")
  valid_761958 = validateParameter(valid_761958, JString, required = true,
                                 default = nil)
  if valid_761958 != nil:
    section.add "body", valid_761958
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761959: Call_PostV3ProjectsIdSnippetsNoteableIdNotes_761952;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a new +noteable+ note
  ## 
  let valid = call_761959.validator(path, query, header, formData, body)
  let scheme = call_761959.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761959.url(scheme.get, call_761959.host, call_761959.base,
                         call_761959.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761959, url, valid)

proc call*(call_761960: Call_PostV3ProjectsIdSnippetsNoteableIdNotes_761952;
          id: string; body: string; noteableId: int; createdAt: string = ""): Recallable =
  ## postV3ProjectsIdSnippetsNoteableIdNotes
  ## Create a new +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   createdAt: string
  ##            : The creation date of the note
  ##   body: string (required)
  ##       : The content of a note
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  var path_761961 = newJObject()
  var formData_761962 = newJObject()
  add(path_761961, "id", newJString(id))
  add(formData_761962, "created_at", newJString(createdAt))
  add(formData_761962, "body", newJString(body))
  add(path_761961, "noteable_id", newJInt(noteableId))
  result = call_761960.call(path_761961, nil, nil, formData_761962, nil)

var postV3ProjectsIdSnippetsNoteableIdNotes* = Call_PostV3ProjectsIdSnippetsNoteableIdNotes_761952(
    name: "postV3ProjectsIdSnippetsNoteableIdNotes", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/snippets/{noteable_id}/notes",
    validator: validate_PostV3ProjectsIdSnippetsNoteableIdNotes_761953,
    base: "/api", url: url_PostV3ProjectsIdSnippetsNoteableIdNotes_761954,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdSnippetsNoteableIdNotes_761941 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdSnippetsNoteableIdNotes_761943(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdSnippetsNoteableIdNotes_761942(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a list of project +noteable+ notes
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761944 = path.getOrDefault("id")
  valid_761944 = validateParameter(valid_761944, JString, required = true,
                                 default = nil)
  if valid_761944 != nil:
    section.add "id", valid_761944
  var valid_761945 = path.getOrDefault("noteable_id")
  valid_761945 = validateParameter(valid_761945, JInt, required = true, default = nil)
  if valid_761945 != nil:
    section.add "noteable_id", valid_761945
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_761946 = query.getOrDefault("per_page")
  valid_761946 = validateParameter(valid_761946, JInt, required = false, default = nil)
  if valid_761946 != nil:
    section.add "per_page", valid_761946
  var valid_761947 = query.getOrDefault("page")
  valid_761947 = validateParameter(valid_761947, JInt, required = false, default = nil)
  if valid_761947 != nil:
    section.add "page", valid_761947
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761948: Call_GetV3ProjectsIdSnippetsNoteableIdNotes_761941;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a list of project +noteable+ notes
  ## 
  let valid = call_761948.validator(path, query, header, formData, body)
  let scheme = call_761948.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761948.url(scheme.get, call_761948.host, call_761948.base,
                         call_761948.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761948, url, valid)

proc call*(call_761949: Call_GetV3ProjectsIdSnippetsNoteableIdNotes_761941;
          id: string; noteableId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdSnippetsNoteableIdNotes
  ## Get a list of project +noteable+ notes
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  var path_761950 = newJObject()
  var query_761951 = newJObject()
  add(path_761950, "id", newJString(id))
  add(query_761951, "per_page", newJInt(perPage))
  add(query_761951, "page", newJInt(page))
  add(path_761950, "noteable_id", newJInt(noteableId))
  result = call_761949.call(path_761950, query_761951, nil, nil, nil)

var getV3ProjectsIdSnippetsNoteableIdNotes* = Call_GetV3ProjectsIdSnippetsNoteableIdNotes_761941(
    name: "getV3ProjectsIdSnippetsNoteableIdNotes", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/snippets/{noteable_id}/notes",
    validator: validate_GetV3ProjectsIdSnippetsNoteableIdNotes_761942,
    base: "/api", url: url_GetV3ProjectsIdSnippetsNoteableIdNotes_761943,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdSnippetsNoteableIdNotesNoteId_761972 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdSnippetsNoteableIdNotesNoteId_761974(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdSnippetsNoteableIdNotesNoteId_761973(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update an existing +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  ##   note_id: JInt (required)
  ##          : The ID of a note
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761975 = path.getOrDefault("id")
  valid_761975 = validateParameter(valid_761975, JString, required = true,
                                 default = nil)
  if valid_761975 != nil:
    section.add "id", valid_761975
  var valid_761976 = path.getOrDefault("noteable_id")
  valid_761976 = validateParameter(valid_761976, JInt, required = true, default = nil)
  if valid_761976 != nil:
    section.add "noteable_id", valid_761976
  var valid_761977 = path.getOrDefault("note_id")
  valid_761977 = validateParameter(valid_761977, JInt, required = true, default = nil)
  if valid_761977 != nil:
    section.add "note_id", valid_761977
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   body: JString (required)
  ##       : The content of a note
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `body` field"
  var valid_761978 = formData.getOrDefault("body")
  valid_761978 = validateParameter(valid_761978, JString, required = true,
                                 default = nil)
  if valid_761978 != nil:
    section.add "body", valid_761978
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761979: Call_PutV3ProjectsIdSnippetsNoteableIdNotesNoteId_761972;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update an existing +noteable+ note
  ## 
  let valid = call_761979.validator(path, query, header, formData, body)
  let scheme = call_761979.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761979.url(scheme.get, call_761979.host, call_761979.base,
                         call_761979.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761979, url, valid)

proc call*(call_761980: Call_PutV3ProjectsIdSnippetsNoteableIdNotesNoteId_761972;
          id: string; body: string; noteableId: int; noteId: int): Recallable =
  ## putV3ProjectsIdSnippetsNoteableIdNotesNoteId
  ## Update an existing +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   body: string (required)
  ##       : The content of a note
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  ##   noteId: int (required)
  ##         : The ID of a note
  var path_761981 = newJObject()
  var formData_761982 = newJObject()
  add(path_761981, "id", newJString(id))
  add(formData_761982, "body", newJString(body))
  add(path_761981, "noteable_id", newJInt(noteableId))
  add(path_761981, "note_id", newJInt(noteId))
  result = call_761980.call(path_761981, nil, nil, formData_761982, nil)

var putV3ProjectsIdSnippetsNoteableIdNotesNoteId* = Call_PutV3ProjectsIdSnippetsNoteableIdNotesNoteId_761972(
    name: "putV3ProjectsIdSnippetsNoteableIdNotesNoteId",
    meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/projects/{id}/snippets/{noteable_id}/notes/{note_id}",
    validator: validate_PutV3ProjectsIdSnippetsNoteableIdNotesNoteId_761973,
    base: "/api", url: url_PutV3ProjectsIdSnippetsNoteableIdNotesNoteId_761974,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdSnippetsNoteableIdNotesNoteId_761963 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdSnippetsNoteableIdNotesNoteId_761965(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdSnippetsNoteableIdNotesNoteId_761964(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  ##   note_id: JInt (required)
  ##          : The ID of a note
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761966 = path.getOrDefault("id")
  valid_761966 = validateParameter(valid_761966, JString, required = true,
                                 default = nil)
  if valid_761966 != nil:
    section.add "id", valid_761966
  var valid_761967 = path.getOrDefault("noteable_id")
  valid_761967 = validateParameter(valid_761967, JInt, required = true, default = nil)
  if valid_761967 != nil:
    section.add "noteable_id", valid_761967
  var valid_761968 = path.getOrDefault("note_id")
  valid_761968 = validateParameter(valid_761968, JInt, required = true, default = nil)
  if valid_761968 != nil:
    section.add "note_id", valid_761968
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761969: Call_GetV3ProjectsIdSnippetsNoteableIdNotesNoteId_761963;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single +noteable+ note
  ## 
  let valid = call_761969.validator(path, query, header, formData, body)
  let scheme = call_761969.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761969.url(scheme.get, call_761969.host, call_761969.base,
                         call_761969.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761969, url, valid)

proc call*(call_761970: Call_GetV3ProjectsIdSnippetsNoteableIdNotesNoteId_761963;
          id: string; noteableId: int; noteId: int): Recallable =
  ## getV3ProjectsIdSnippetsNoteableIdNotesNoteId
  ## Get a single +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  ##   noteId: int (required)
  ##         : The ID of a note
  var path_761971 = newJObject()
  add(path_761971, "id", newJString(id))
  add(path_761971, "noteable_id", newJInt(noteableId))
  add(path_761971, "note_id", newJInt(noteId))
  result = call_761970.call(path_761971, nil, nil, nil, nil)

var getV3ProjectsIdSnippetsNoteableIdNotesNoteId* = Call_GetV3ProjectsIdSnippetsNoteableIdNotesNoteId_761963(
    name: "getV3ProjectsIdSnippetsNoteableIdNotesNoteId",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/snippets/{noteable_id}/notes/{note_id}",
    validator: validate_GetV3ProjectsIdSnippetsNoteableIdNotesNoteId_761964,
    base: "/api", url: url_GetV3ProjectsIdSnippetsNoteableIdNotesNoteId_761965,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdSnippetsNoteableIdNotesNoteId_761983 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdSnippetsNoteableIdNotesNoteId_761985(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "noteable_id" in path, "`noteable_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "noteable_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdSnippetsNoteableIdNotesNoteId_761984(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Delete a +noteable+ note
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   noteable_id: JInt (required)
  ##              : The ID of the noteable
  ##   note_id: JInt (required)
  ##          : The ID of a note
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761986 = path.getOrDefault("id")
  valid_761986 = validateParameter(valid_761986, JString, required = true,
                                 default = nil)
  if valid_761986 != nil:
    section.add "id", valid_761986
  var valid_761987 = path.getOrDefault("noteable_id")
  valid_761987 = validateParameter(valid_761987, JInt, required = true, default = nil)
  if valid_761987 != nil:
    section.add "noteable_id", valid_761987
  var valid_761988 = path.getOrDefault("note_id")
  valid_761988 = validateParameter(valid_761988, JInt, required = true, default = nil)
  if valid_761988 != nil:
    section.add "note_id", valid_761988
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761989: Call_DeleteV3ProjectsIdSnippetsNoteableIdNotesNoteId_761983;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a +noteable+ note
  ## 
  let valid = call_761989.validator(path, query, header, formData, body)
  let scheme = call_761989.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761989.url(scheme.get, call_761989.host, call_761989.base,
                         call_761989.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761989, url, valid)

proc call*(call_761990: Call_DeleteV3ProjectsIdSnippetsNoteableIdNotesNoteId_761983;
          id: string; noteableId: int; noteId: int): Recallable =
  ## deleteV3ProjectsIdSnippetsNoteableIdNotesNoteId
  ## Delete a +noteable+ note
  ##   id: string (required)
  ##     : The ID of a project
  ##   noteableId: int (required)
  ##             : The ID of the noteable
  ##   noteId: int (required)
  ##         : The ID of a note
  var path_761991 = newJObject()
  add(path_761991, "id", newJString(id))
  add(path_761991, "noteable_id", newJInt(noteableId))
  add(path_761991, "note_id", newJInt(noteId))
  result = call_761990.call(path_761991, nil, nil, nil, nil)

var deleteV3ProjectsIdSnippetsNoteableIdNotesNoteId* = Call_DeleteV3ProjectsIdSnippetsNoteableIdNotesNoteId_761983(
    name: "deleteV3ProjectsIdSnippetsNoteableIdNotesNoteId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/snippets/{noteable_id}/notes/{note_id}",
    validator: validate_DeleteV3ProjectsIdSnippetsNoteableIdNotesNoteId_761984,
    base: "/api", url: url_DeleteV3ProjectsIdSnippetsNoteableIdNotesNoteId_761985,
    schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdSnippetsSnippetId_762000 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdSnippetsSnippetId_762002(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdSnippetsSnippetId_762001(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update an existing project snippet
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   snippet_id: JInt (required)
  ##             : The ID of a project snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762003 = path.getOrDefault("id")
  valid_762003 = validateParameter(valid_762003, JString, required = true,
                                 default = nil)
  if valid_762003 != nil:
    section.add "id", valid_762003
  var valid_762004 = path.getOrDefault("snippet_id")
  valid_762004 = validateParameter(valid_762004, JInt, required = true, default = nil)
  if valid_762004 != nil:
    section.add "snippet_id", valid_762004
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   file_name: JString
  ##            : The file name of the snippet
  ##   title: JString
  ##        : The title of the snippet
  ##   code: JString
  ##       : The content of the snippet
  ##   visibility_level: JInt
  ##                   : The visibility level of the snippet
  section = newJObject()
  var valid_762005 = formData.getOrDefault("file_name")
  valid_762005 = validateParameter(valid_762005, JString, required = false,
                                 default = nil)
  if valid_762005 != nil:
    section.add "file_name", valid_762005
  var valid_762006 = formData.getOrDefault("title")
  valid_762006 = validateParameter(valid_762006, JString, required = false,
                                 default = nil)
  if valid_762006 != nil:
    section.add "title", valid_762006
  var valid_762007 = formData.getOrDefault("code")
  valid_762007 = validateParameter(valid_762007, JString, required = false,
                                 default = nil)
  if valid_762007 != nil:
    section.add "code", valid_762007
  var valid_762008 = formData.getOrDefault("visibility_level")
  valid_762008 = validateParameter(valid_762008, JInt, required = false, default = nil)
  if valid_762008 != nil:
    section.add "visibility_level", valid_762008
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762009: Call_PutV3ProjectsIdSnippetsSnippetId_762000;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update an existing project snippet
  ## 
  let valid = call_762009.validator(path, query, header, formData, body)
  let scheme = call_762009.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762009.url(scheme.get, call_762009.host, call_762009.base,
                         call_762009.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762009, url, valid)

proc call*(call_762010: Call_PutV3ProjectsIdSnippetsSnippetId_762000; id: string;
          snippetId: int; fileName: string = ""; title: string = ""; code: string = "";
          visibilityLevel: int = 0): Recallable =
  ## putV3ProjectsIdSnippetsSnippetId
  ## Update an existing project snippet
  ##   fileName: string
  ##           : The file name of the snippet
  ##   title: string
  ##        : The title of the snippet
  ##   id: string (required)
  ##     : The ID of a project
  ##   code: string
  ##       : The content of the snippet
  ##   snippetId: int (required)
  ##            : The ID of a project snippet
  ##   visibilityLevel: int
  ##                  : The visibility level of the snippet
  var path_762011 = newJObject()
  var formData_762012 = newJObject()
  add(formData_762012, "file_name", newJString(fileName))
  add(formData_762012, "title", newJString(title))
  add(path_762011, "id", newJString(id))
  add(formData_762012, "code", newJString(code))
  add(path_762011, "snippet_id", newJInt(snippetId))
  add(formData_762012, "visibility_level", newJInt(visibilityLevel))
  result = call_762010.call(path_762011, nil, nil, formData_762012, nil)

var putV3ProjectsIdSnippetsSnippetId* = Call_PutV3ProjectsIdSnippetsSnippetId_762000(
    name: "putV3ProjectsIdSnippetsSnippetId", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/snippets/{snippet_id}",
    validator: validate_PutV3ProjectsIdSnippetsSnippetId_762001, base: "/api",
    url: url_PutV3ProjectsIdSnippetsSnippetId_762002, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdSnippetsSnippetId_761992 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdSnippetsSnippetId_761994(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdSnippetsSnippetId_761993(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single project snippet
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   snippet_id: JInt (required)
  ##             : The ID of a project snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_761995 = path.getOrDefault("id")
  valid_761995 = validateParameter(valid_761995, JString, required = true,
                                 default = nil)
  if valid_761995 != nil:
    section.add "id", valid_761995
  var valid_761996 = path.getOrDefault("snippet_id")
  valid_761996 = validateParameter(valid_761996, JInt, required = true, default = nil)
  if valid_761996 != nil:
    section.add "snippet_id", valid_761996
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_761997: Call_GetV3ProjectsIdSnippetsSnippetId_761992;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single project snippet
  ## 
  let valid = call_761997.validator(path, query, header, formData, body)
  let scheme = call_761997.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_761997.url(scheme.get, call_761997.host, call_761997.base,
                         call_761997.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_761997, url, valid)

proc call*(call_761998: Call_GetV3ProjectsIdSnippetsSnippetId_761992; id: string;
          snippetId: int): Recallable =
  ## getV3ProjectsIdSnippetsSnippetId
  ## Get a single project snippet
  ##   id: string (required)
  ##     : The ID of a project
  ##   snippetId: int (required)
  ##            : The ID of a project snippet
  var path_761999 = newJObject()
  add(path_761999, "id", newJString(id))
  add(path_761999, "snippet_id", newJInt(snippetId))
  result = call_761998.call(path_761999, nil, nil, nil, nil)

var getV3ProjectsIdSnippetsSnippetId* = Call_GetV3ProjectsIdSnippetsSnippetId_761992(
    name: "getV3ProjectsIdSnippetsSnippetId", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/snippets/{snippet_id}",
    validator: validate_GetV3ProjectsIdSnippetsSnippetId_761993, base: "/api",
    url: url_GetV3ProjectsIdSnippetsSnippetId_761994, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdSnippetsSnippetId_762013 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdSnippetsSnippetId_762015(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdSnippetsSnippetId_762014(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a project snippet
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   snippet_id: JInt (required)
  ##             : The ID of a project snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762016 = path.getOrDefault("id")
  valid_762016 = validateParameter(valid_762016, JString, required = true,
                                 default = nil)
  if valid_762016 != nil:
    section.add "id", valid_762016
  var valid_762017 = path.getOrDefault("snippet_id")
  valid_762017 = validateParameter(valid_762017, JInt, required = true, default = nil)
  if valid_762017 != nil:
    section.add "snippet_id", valid_762017
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762018: Call_DeleteV3ProjectsIdSnippetsSnippetId_762013;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a project snippet
  ## 
  let valid = call_762018.validator(path, query, header, formData, body)
  let scheme = call_762018.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762018.url(scheme.get, call_762018.host, call_762018.base,
                         call_762018.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762018, url, valid)

proc call*(call_762019: Call_DeleteV3ProjectsIdSnippetsSnippetId_762013;
          id: string; snippetId: int): Recallable =
  ## deleteV3ProjectsIdSnippetsSnippetId
  ## Delete a project snippet
  ##   id: string (required)
  ##     : The ID of a project
  ##   snippetId: int (required)
  ##            : The ID of a project snippet
  var path_762020 = newJObject()
  add(path_762020, "id", newJString(id))
  add(path_762020, "snippet_id", newJInt(snippetId))
  result = call_762019.call(path_762020, nil, nil, nil, nil)

var deleteV3ProjectsIdSnippetsSnippetId* = Call_DeleteV3ProjectsIdSnippetsSnippetId_762013(
    name: "deleteV3ProjectsIdSnippetsSnippetId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/snippets/{snippet_id}",
    validator: validate_DeleteV3ProjectsIdSnippetsSnippetId_762014, base: "/api",
    url: url_DeleteV3ProjectsIdSnippetsSnippetId_762015, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdSnippetsSnippetIdAwardEmoji_762032 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdSnippetsSnippetIdAwardEmoji_762034(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdSnippetsSnippetIdAwardEmoji_762033(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   snippet_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762035 = path.getOrDefault("id")
  valid_762035 = validateParameter(valid_762035, JInt, required = true, default = nil)
  if valid_762035 != nil:
    section.add "id", valid_762035
  var valid_762036 = path.getOrDefault("snippet_id")
  valid_762036 = validateParameter(valid_762036, JInt, required = true, default = nil)
  if valid_762036 != nil:
    section.add "snippet_id", valid_762036
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   name: JString (required)
  ##       : The name of a award_emoji (without colons)
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `name` field"
  var valid_762037 = formData.getOrDefault("name")
  valid_762037 = validateParameter(valid_762037, JString, required = true,
                                 default = nil)
  if valid_762037 != nil:
    section.add "name", valid_762037
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762038: Call_PostV3ProjectsIdSnippetsSnippetIdAwardEmoji_762032;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_762038.validator(path, query, header, formData, body)
  let scheme = call_762038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762038.url(scheme.get, call_762038.host, call_762038.base,
                         call_762038.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762038, url, valid)

proc call*(call_762039: Call_PostV3ProjectsIdSnippetsSnippetIdAwardEmoji_762032;
          id: int; snippetId: int; name: string): Recallable =
  ## postV3ProjectsIdSnippetsSnippetIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   snippetId: int (required)
  ##   name: string (required)
  ##       : The name of a award_emoji (without colons)
  var path_762040 = newJObject()
  var formData_762041 = newJObject()
  add(path_762040, "id", newJInt(id))
  add(path_762040, "snippet_id", newJInt(snippetId))
  add(formData_762041, "name", newJString(name))
  result = call_762039.call(path_762040, nil, nil, formData_762041, nil)

var postV3ProjectsIdSnippetsSnippetIdAwardEmoji* = Call_PostV3ProjectsIdSnippetsSnippetIdAwardEmoji_762032(
    name: "postV3ProjectsIdSnippetsSnippetIdAwardEmoji",
    meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/snippets/{snippet_id}/award_emoji",
    validator: validate_PostV3ProjectsIdSnippetsSnippetIdAwardEmoji_762033,
    base: "/api", url: url_PostV3ProjectsIdSnippetsSnippetIdAwardEmoji_762034,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdSnippetsSnippetIdAwardEmoji_762021 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdSnippetsSnippetIdAwardEmoji_762023(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdSnippetsSnippetIdAwardEmoji_762022(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   snippet_id: JInt (required)
  ##             : The ID of an Issue, Merge Request or Snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762024 = path.getOrDefault("id")
  valid_762024 = validateParameter(valid_762024, JString, required = true,
                                 default = nil)
  if valid_762024 != nil:
    section.add "id", valid_762024
  var valid_762025 = path.getOrDefault("snippet_id")
  valid_762025 = validateParameter(valid_762025, JInt, required = true, default = nil)
  if valid_762025 != nil:
    section.add "snippet_id", valid_762025
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_762026 = query.getOrDefault("per_page")
  valid_762026 = validateParameter(valid_762026, JInt, required = false, default = nil)
  if valid_762026 != nil:
    section.add "per_page", valid_762026
  var valid_762027 = query.getOrDefault("page")
  valid_762027 = validateParameter(valid_762027, JInt, required = false, default = nil)
  if valid_762027 != nil:
    section.add "page", valid_762027
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762028: Call_GetV3ProjectsIdSnippetsSnippetIdAwardEmoji_762021;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_762028.validator(path, query, header, formData, body)
  let scheme = call_762028.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762028.url(scheme.get, call_762028.host, call_762028.base,
                         call_762028.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762028, url, valid)

proc call*(call_762029: Call_GetV3ProjectsIdSnippetsSnippetIdAwardEmoji_762021;
          id: string; snippetId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdSnippetsSnippetIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   snippetId: int (required)
  ##            : The ID of an Issue, Merge Request or Snippet
  var path_762030 = newJObject()
  var query_762031 = newJObject()
  add(path_762030, "id", newJString(id))
  add(query_762031, "per_page", newJInt(perPage))
  add(query_762031, "page", newJInt(page))
  add(path_762030, "snippet_id", newJInt(snippetId))
  result = call_762029.call(path_762030, query_762031, nil, nil, nil)

var getV3ProjectsIdSnippetsSnippetIdAwardEmoji* = Call_GetV3ProjectsIdSnippetsSnippetIdAwardEmoji_762021(
    name: "getV3ProjectsIdSnippetsSnippetIdAwardEmoji", meth: HttpMethod.HttpGet,
    host: "gitlab.com",
    route: "/v3/projects/{id}/snippets/{snippet_id}/award_emoji",
    validator: validate_GetV3ProjectsIdSnippetsSnippetIdAwardEmoji_762022,
    base: "/api", url: url_GetV3ProjectsIdSnippetsSnippetIdAwardEmoji_762023,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762042 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762044(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762043(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of the award
  ##   snippet_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762045 = path.getOrDefault("id")
  valid_762045 = validateParameter(valid_762045, JInt, required = true, default = nil)
  if valid_762045 != nil:
    section.add "id", valid_762045
  var valid_762046 = path.getOrDefault("award_id")
  valid_762046 = validateParameter(valid_762046, JInt, required = true, default = nil)
  if valid_762046 != nil:
    section.add "award_id", valid_762046
  var valid_762047 = path.getOrDefault("snippet_id")
  valid_762047 = validateParameter(valid_762047, JInt, required = true, default = nil)
  if valid_762047 != nil:
    section.add "snippet_id", valid_762047
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762048: Call_GetV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762042;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_762048.validator(path, query, header, formData, body)
  let scheme = call_762048.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762048.url(scheme.get, call_762048.host, call_762048.base,
                         call_762048.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762048, url, valid)

proc call*(call_762049: Call_GetV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762042;
          id: int; awardId: int; snippetId: int): Recallable =
  ## getV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of the award
  ##   snippetId: int (required)
  var path_762050 = newJObject()
  add(path_762050, "id", newJInt(id))
  add(path_762050, "award_id", newJInt(awardId))
  add(path_762050, "snippet_id", newJInt(snippetId))
  result = call_762049.call(path_762050, nil, nil, nil, nil)

var getV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId* = Call_GetV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762042(
    name: "getV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId",
    meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/snippets/{snippet_id}/award_emoji/{award_id}",
    validator: validate_GetV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762043,
    base: "/api", url: url_GetV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762044,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762051 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762053(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762052(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of an award emoji
  ##   snippet_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762054 = path.getOrDefault("id")
  valid_762054 = validateParameter(valid_762054, JInt, required = true, default = nil)
  if valid_762054 != nil:
    section.add "id", valid_762054
  var valid_762055 = path.getOrDefault("award_id")
  valid_762055 = validateParameter(valid_762055, JInt, required = true, default = nil)
  if valid_762055 != nil:
    section.add "award_id", valid_762055
  var valid_762056 = path.getOrDefault("snippet_id")
  valid_762056 = validateParameter(valid_762056, JInt, required = true, default = nil)
  if valid_762056 != nil:
    section.add "snippet_id", valid_762056
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762057: Call_DeleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762051;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_762057.validator(path, query, header, formData, body)
  let scheme = call_762057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762057.url(scheme.get, call_762057.host, call_762057.base,
                         call_762057.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762057, url, valid)

proc call*(call_762058: Call_DeleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762051;
          id: int; awardId: int; snippetId: int): Recallable =
  ## deleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of an award emoji
  ##   snippetId: int (required)
  var path_762059 = newJObject()
  add(path_762059, "id", newJInt(id))
  add(path_762059, "award_id", newJInt(awardId))
  add(path_762059, "snippet_id", newJInt(snippetId))
  result = call_762058.call(path_762059, nil, nil, nil, nil)

var deleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId* = Call_DeleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762051(
    name: "deleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/snippets/{snippet_id}/award_emoji/{award_id}",
    validator: validate_DeleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762052,
    base: "/api", url: url_DeleteV3ProjectsIdSnippetsSnippetIdAwardEmojiAwardId_762053,
    schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762072 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762074(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762073(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   snippet_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762075 = path.getOrDefault("id")
  valid_762075 = validateParameter(valid_762075, JInt, required = true, default = nil)
  if valid_762075 != nil:
    section.add "id", valid_762075
  var valid_762076 = path.getOrDefault("snippet_id")
  valid_762076 = validateParameter(valid_762076, JInt, required = true, default = nil)
  if valid_762076 != nil:
    section.add "snippet_id", valid_762076
  var valid_762077 = path.getOrDefault("note_id")
  valid_762077 = validateParameter(valid_762077, JInt, required = true, default = nil)
  if valid_762077 != nil:
    section.add "note_id", valid_762077
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   name: JString (required)
  ##       : The name of a award_emoji (without colons)
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `name` field"
  var valid_762078 = formData.getOrDefault("name")
  valid_762078 = validateParameter(valid_762078, JString, required = true,
                                 default = nil)
  if valid_762078 != nil:
    section.add "name", valid_762078
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762079: Call_PostV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762072;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_762079.validator(path, query, header, formData, body)
  let scheme = call_762079.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762079.url(scheme.get, call_762079.host, call_762079.base,
                         call_762079.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762079, url, valid)

proc call*(call_762080: Call_PostV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762072;
          id: int; snippetId: int; noteId: int; name: string): Recallable =
  ## postV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   snippetId: int (required)
  ##   noteId: int (required)
  ##   name: string (required)
  ##       : The name of a award_emoji (without colons)
  var path_762081 = newJObject()
  var formData_762082 = newJObject()
  add(path_762081, "id", newJInt(id))
  add(path_762081, "snippet_id", newJInt(snippetId))
  add(path_762081, "note_id", newJInt(noteId))
  add(formData_762082, "name", newJString(name))
  result = call_762080.call(path_762081, nil, nil, formData_762082, nil)

var postV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji* = Call_PostV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762072(
    name: "postV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/projects/{id}/snippets/{snippet_id}/notes/{note_id}/award_emoji",
    validator: validate_PostV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762073,
    base: "/api", url: url_PostV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762074,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762060 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762062(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762061(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   snippet_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762063 = path.getOrDefault("id")
  valid_762063 = validateParameter(valid_762063, JInt, required = true, default = nil)
  if valid_762063 != nil:
    section.add "id", valid_762063
  var valid_762064 = path.getOrDefault("snippet_id")
  valid_762064 = validateParameter(valid_762064, JInt, required = true, default = nil)
  if valid_762064 != nil:
    section.add "snippet_id", valid_762064
  var valid_762065 = path.getOrDefault("note_id")
  valid_762065 = validateParameter(valid_762065, JInt, required = true, default = nil)
  if valid_762065 != nil:
    section.add "note_id", valid_762065
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_762066 = query.getOrDefault("per_page")
  valid_762066 = validateParameter(valid_762066, JInt, required = false, default = nil)
  if valid_762066 != nil:
    section.add "per_page", valid_762066
  var valid_762067 = query.getOrDefault("page")
  valid_762067 = validateParameter(valid_762067, JInt, required = false, default = nil)
  if valid_762067 != nil:
    section.add "page", valid_762067
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762068: Call_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762060;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_762068.validator(path, query, header, formData, body)
  let scheme = call_762068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762068.url(scheme.get, call_762068.host, call_762068.base,
                         call_762068.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762068, url, valid)

proc call*(call_762069: Call_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762060;
          id: int; snippetId: int; noteId: int; perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   snippetId: int (required)
  ##   noteId: int (required)
  var path_762070 = newJObject()
  var query_762071 = newJObject()
  add(path_762070, "id", newJInt(id))
  add(query_762071, "per_page", newJInt(perPage))
  add(query_762071, "page", newJInt(page))
  add(path_762070, "snippet_id", newJInt(snippetId))
  add(path_762070, "note_id", newJInt(noteId))
  result = call_762069.call(path_762070, query_762071, nil, nil, nil)

var getV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji* = Call_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762060(
    name: "getV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/projects/{id}/snippets/{snippet_id}/notes/{note_id}/award_emoji",
    validator: validate_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762061,
    base: "/api", url: url_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmoji_762062,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762083 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762085(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762084(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of the award
  ##   snippet_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762086 = path.getOrDefault("id")
  valid_762086 = validateParameter(valid_762086, JInt, required = true, default = nil)
  if valid_762086 != nil:
    section.add "id", valid_762086
  var valid_762087 = path.getOrDefault("award_id")
  valid_762087 = validateParameter(valid_762087, JInt, required = true, default = nil)
  if valid_762087 != nil:
    section.add "award_id", valid_762087
  var valid_762088 = path.getOrDefault("snippet_id")
  valid_762088 = validateParameter(valid_762088, JInt, required = true, default = nil)
  if valid_762088 != nil:
    section.add "snippet_id", valid_762088
  var valid_762089 = path.getOrDefault("note_id")
  valid_762089 = validateParameter(valid_762089, JInt, required = true, default = nil)
  if valid_762089 != nil:
    section.add "note_id", valid_762089
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762090: Call_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762083;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_762090.validator(path, query, header, formData, body)
  let scheme = call_762090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762090.url(scheme.get, call_762090.host, call_762090.base,
                         call_762090.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762090, url, valid)

proc call*(call_762091: Call_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762083;
          id: int; awardId: int; snippetId: int; noteId: int): Recallable =
  ## getV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of the award
  ##   snippetId: int (required)
  ##   noteId: int (required)
  var path_762092 = newJObject()
  add(path_762092, "id", newJInt(id))
  add(path_762092, "award_id", newJInt(awardId))
  add(path_762092, "snippet_id", newJInt(snippetId))
  add(path_762092, "note_id", newJInt(noteId))
  result = call_762091.call(path_762092, nil, nil, nil, nil)

var getV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId* = Call_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762083(
    name: "getV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/projects/{id}/snippets/{snippet_id}/notes/{note_id}/award_emoji/{award_id}", validator: validate_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762084,
    base: "/api",
    url: url_GetV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762085,
    schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762093 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762095(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  assert "note_id" in path, "`note_id` is a required path parameter"
  assert "award_id" in path, "`award_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id"),
               (kind: ConstantSegment, value: "/notes/"),
               (kind: VariableSegment, value: "note_id"),
               (kind: ConstantSegment, value: "/award_emoji/"),
               (kind: VariableSegment, value: "award_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762094(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## This feature was introduced in 8.9
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##   award_id: JInt (required)
  ##           : The ID of an award emoji
  ##   snippet_id: JInt (required)
  ##   note_id: JInt (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762096 = path.getOrDefault("id")
  valid_762096 = validateParameter(valid_762096, JInt, required = true, default = nil)
  if valid_762096 != nil:
    section.add "id", valid_762096
  var valid_762097 = path.getOrDefault("award_id")
  valid_762097 = validateParameter(valid_762097, JInt, required = true, default = nil)
  if valid_762097 != nil:
    section.add "award_id", valid_762097
  var valid_762098 = path.getOrDefault("snippet_id")
  valid_762098 = validateParameter(valid_762098, JInt, required = true, default = nil)
  if valid_762098 != nil:
    section.add "snippet_id", valid_762098
  var valid_762099 = path.getOrDefault("note_id")
  valid_762099 = validateParameter(valid_762099, JInt, required = true, default = nil)
  if valid_762099 != nil:
    section.add "note_id", valid_762099
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762100: Call_DeleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762093;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This feature was introduced in 8.9
  ## 
  let valid = call_762100.validator(path, query, header, formData, body)
  let scheme = call_762100.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762100.url(scheme.get, call_762100.host, call_762100.base,
                         call_762100.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762100, url, valid)

proc call*(call_762101: Call_DeleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762093;
          id: int; awardId: int; snippetId: int; noteId: int): Recallable =
  ## deleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId
  ## This feature was introduced in 8.9
  ##   id: int (required)
  ##   awardId: int (required)
  ##          : The ID of an award emoji
  ##   snippetId: int (required)
  ##   noteId: int (required)
  var path_762102 = newJObject()
  add(path_762102, "id", newJInt(id))
  add(path_762102, "award_id", newJInt(awardId))
  add(path_762102, "snippet_id", newJInt(snippetId))
  add(path_762102, "note_id", newJInt(noteId))
  result = call_762101.call(path_762102, nil, nil, nil, nil)

var deleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId* = Call_DeleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762093(
    name: "deleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com", route: "/v3/projects/{id}/snippets/{snippet_id}/notes/{note_id}/award_emoji/{award_id}", validator: validate_DeleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762094,
    base: "/api",
    url: url_DeleteV3ProjectsIdSnippetsSnippetIdNotesNoteIdAwardEmojiAwardId_762095,
    schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdSnippetsSnippetIdRaw_762103 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdSnippetsSnippetIdRaw_762105(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "snippet_id" in path, "`snippet_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/snippets/"),
               (kind: VariableSegment, value: "snippet_id"),
               (kind: ConstantSegment, value: "/raw")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdSnippetsSnippetIdRaw_762104(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a raw project snippet
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   snippet_id: JInt (required)
  ##             : The ID of a project snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762106 = path.getOrDefault("id")
  valid_762106 = validateParameter(valid_762106, JString, required = true,
                                 default = nil)
  if valid_762106 != nil:
    section.add "id", valid_762106
  var valid_762107 = path.getOrDefault("snippet_id")
  valid_762107 = validateParameter(valid_762107, JInt, required = true, default = nil)
  if valid_762107 != nil:
    section.add "snippet_id", valid_762107
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762108: Call_GetV3ProjectsIdSnippetsSnippetIdRaw_762103;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a raw project snippet
  ## 
  let valid = call_762108.validator(path, query, header, formData, body)
  let scheme = call_762108.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762108.url(scheme.get, call_762108.host, call_762108.base,
                         call_762108.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762108, url, valid)

proc call*(call_762109: Call_GetV3ProjectsIdSnippetsSnippetIdRaw_762103;
          id: string; snippetId: int): Recallable =
  ## getV3ProjectsIdSnippetsSnippetIdRaw
  ## Get a raw project snippet
  ##   id: string (required)
  ##     : The ID of a project
  ##   snippetId: int (required)
  ##            : The ID of a project snippet
  var path_762110 = newJObject()
  add(path_762110, "id", newJString(id))
  add(path_762110, "snippet_id", newJInt(snippetId))
  result = call_762109.call(path_762110, nil, nil, nil, nil)

var getV3ProjectsIdSnippetsSnippetIdRaw* = Call_GetV3ProjectsIdSnippetsSnippetIdRaw_762103(
    name: "getV3ProjectsIdSnippetsSnippetIdRaw", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/snippets/{snippet_id}/raw",
    validator: validate_GetV3ProjectsIdSnippetsSnippetIdRaw_762104, base: "/api",
    url: url_GetV3ProjectsIdSnippetsSnippetIdRaw_762105, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdStar_762111 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdStar_762113(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdStar_762112(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Star a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762114 = path.getOrDefault("id")
  valid_762114 = validateParameter(valid_762114, JString, required = true,
                                 default = nil)
  if valid_762114 != nil:
    section.add "id", valid_762114
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762115: Call_PostV3ProjectsIdStar_762111; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Star a project
  ## 
  let valid = call_762115.validator(path, query, header, formData, body)
  let scheme = call_762115.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762115.url(scheme.get, call_762115.host, call_762115.base,
                         call_762115.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762115, url, valid)

proc call*(call_762116: Call_PostV3ProjectsIdStar_762111; id: string): Recallable =
  ## postV3ProjectsIdStar
  ## Star a project
  ##   id: string (required)
  ##     : The ID of a project
  var path_762117 = newJObject()
  add(path_762117, "id", newJString(id))
  result = call_762116.call(path_762117, nil, nil, nil, nil)

var postV3ProjectsIdStar* = Call_PostV3ProjectsIdStar_762111(
    name: "postV3ProjectsIdStar", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/star", validator: validate_PostV3ProjectsIdStar_762112,
    base: "/api", url: url_PostV3ProjectsIdStar_762113, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdStar_762118 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdStar_762120(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdStar_762119(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Unstar a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762121 = path.getOrDefault("id")
  valid_762121 = validateParameter(valid_762121, JString, required = true,
                                 default = nil)
  if valid_762121 != nil:
    section.add "id", valid_762121
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762122: Call_DeleteV3ProjectsIdStar_762118; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unstar a project
  ## 
  let valid = call_762122.validator(path, query, header, formData, body)
  let scheme = call_762122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762122.url(scheme.get, call_762122.host, call_762122.base,
                         call_762122.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762122, url, valid)

proc call*(call_762123: Call_DeleteV3ProjectsIdStar_762118; id: string): Recallable =
  ## deleteV3ProjectsIdStar
  ## Unstar a project
  ##   id: string (required)
  ##     : The ID of a project
  var path_762124 = newJObject()
  add(path_762124, "id", newJString(id))
  result = call_762123.call(path_762124, nil, nil, nil, nil)

var deleteV3ProjectsIdStar* = Call_DeleteV3ProjectsIdStar_762118(
    name: "deleteV3ProjectsIdStar", meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/projects/{id}/star", validator: validate_DeleteV3ProjectsIdStar_762119,
    base: "/api", url: url_DeleteV3ProjectsIdStar_762120, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdStatusesSha_762125 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdStatusesSha_762127(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "sha" in path, "`sha` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "sha")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdStatusesSha_762126(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Post status to a commit
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   sha: JString (required)
  ##      : The commit hash
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762128 = path.getOrDefault("id")
  valid_762128 = validateParameter(valid_762128, JString, required = true,
                                 default = nil)
  if valid_762128 != nil:
    section.add "id", valid_762128
  var valid_762129 = path.getOrDefault("sha")
  valid_762129 = validateParameter(valid_762129, JString, required = true,
                                 default = nil)
  if valid_762129 != nil:
    section.add "sha", valid_762129
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   ref: JString
  ##      : The ref
  ##   context: JString
  ##          : A string label to differentiate this status from the status of other systems. Default: "default"
  ##   target_url: JString
  ##             : The target URL to associate with this status
  ##   state: JString (required)
  ##        : The state of the status
  ##   description: JString
  ##              : A short description of the status
  ##   name: JString
  ##       : A string label to differentiate this status from the status of other systems. Default: "default"
  section = newJObject()
  var valid_762130 = formData.getOrDefault("ref")
  valid_762130 = validateParameter(valid_762130, JString, required = false,
                                 default = nil)
  if valid_762130 != nil:
    section.add "ref", valid_762130
  var valid_762131 = formData.getOrDefault("context")
  valid_762131 = validateParameter(valid_762131, JString, required = false,
                                 default = nil)
  if valid_762131 != nil:
    section.add "context", valid_762131
  var valid_762132 = formData.getOrDefault("target_url")
  valid_762132 = validateParameter(valid_762132, JString, required = false,
                                 default = nil)
  if valid_762132 != nil:
    section.add "target_url", valid_762132
  assert formData != nil,
        "formData argument is necessary due to required `state` field"
  var valid_762133 = formData.getOrDefault("state")
  valid_762133 = validateParameter(valid_762133, JString, required = true,
                                 default = newJString("pending"))
  if valid_762133 != nil:
    section.add "state", valid_762133
  var valid_762134 = formData.getOrDefault("description")
  valid_762134 = validateParameter(valid_762134, JString, required = false,
                                 default = nil)
  if valid_762134 != nil:
    section.add "description", valid_762134
  var valid_762135 = formData.getOrDefault("name")
  valid_762135 = validateParameter(valid_762135, JString, required = false,
                                 default = nil)
  if valid_762135 != nil:
    section.add "name", valid_762135
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762136: Call_PostV3ProjectsIdStatusesSha_762125; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Post status to a commit
  ## 
  let valid = call_762136.validator(path, query, header, formData, body)
  let scheme = call_762136.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762136.url(scheme.get, call_762136.host, call_762136.base,
                         call_762136.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762136, url, valid)

proc call*(call_762137: Call_PostV3ProjectsIdStatusesSha_762125; id: string;
          sha: string; `ref`: string = ""; context: string = ""; targetUrl: string = "";
          state: string = "pending"; description: string = ""; name: string = ""): Recallable =
  ## postV3ProjectsIdStatusesSha
  ## Post status to a commit
  ##   ref: string
  ##      : The ref
  ##   context: string
  ##          : A string label to differentiate this status from the status of other systems. Default: "default"
  ##   id: string (required)
  ##     : The ID of a project
  ##   targetUrl: string
  ##            : The target URL to associate with this status
  ##   state: string (required)
  ##        : The state of the status
  ##   description: string
  ##              : A short description of the status
  ##   sha: string (required)
  ##      : The commit hash
  ##   name: string
  ##       : A string label to differentiate this status from the status of other systems. Default: "default"
  var path_762138 = newJObject()
  var formData_762139 = newJObject()
  add(formData_762139, "ref", newJString(`ref`))
  add(formData_762139, "context", newJString(context))
  add(path_762138, "id", newJString(id))
  add(formData_762139, "target_url", newJString(targetUrl))
  add(formData_762139, "state", newJString(state))
  add(formData_762139, "description", newJString(description))
  add(path_762138, "sha", newJString(sha))
  add(formData_762139, "name", newJString(name))
  result = call_762137.call(path_762138, nil, nil, formData_762139, nil)

var postV3ProjectsIdStatusesSha* = Call_PostV3ProjectsIdStatusesSha_762125(
    name: "postV3ProjectsIdStatusesSha", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/statuses/{sha}",
    validator: validate_PostV3ProjectsIdStatusesSha_762126, base: "/api",
    url: url_PostV3ProjectsIdStatusesSha_762127, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdTriggers_762150 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdTriggers_762152(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/triggers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdTriggers_762151(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a trigger
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762153 = path.getOrDefault("id")
  valid_762153 = validateParameter(valid_762153, JString, required = true,
                                 default = nil)
  if valid_762153 != nil:
    section.add "id", valid_762153
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762154: Call_PostV3ProjectsIdTriggers_762150; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a trigger
  ## 
  let valid = call_762154.validator(path, query, header, formData, body)
  let scheme = call_762154.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762154.url(scheme.get, call_762154.host, call_762154.base,
                         call_762154.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762154, url, valid)

proc call*(call_762155: Call_PostV3ProjectsIdTriggers_762150; id: string): Recallable =
  ## postV3ProjectsIdTriggers
  ## Create a trigger
  ##   id: string (required)
  ##     : The ID of a project
  var path_762156 = newJObject()
  add(path_762156, "id", newJString(id))
  result = call_762155.call(path_762156, nil, nil, nil, nil)

var postV3ProjectsIdTriggers* = Call_PostV3ProjectsIdTriggers_762150(
    name: "postV3ProjectsIdTriggers", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/triggers",
    validator: validate_PostV3ProjectsIdTriggers_762151, base: "/api",
    url: url_PostV3ProjectsIdTriggers_762152, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdTriggers_762140 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdTriggers_762142(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/triggers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdTriggers_762141(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get triggers list
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762143 = path.getOrDefault("id")
  valid_762143 = validateParameter(valid_762143, JString, required = true,
                                 default = nil)
  if valid_762143 != nil:
    section.add "id", valid_762143
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_762144 = query.getOrDefault("per_page")
  valid_762144 = validateParameter(valid_762144, JInt, required = false, default = nil)
  if valid_762144 != nil:
    section.add "per_page", valid_762144
  var valid_762145 = query.getOrDefault("page")
  valid_762145 = validateParameter(valid_762145, JInt, required = false, default = nil)
  if valid_762145 != nil:
    section.add "page", valid_762145
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762146: Call_GetV3ProjectsIdTriggers_762140; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get triggers list
  ## 
  let valid = call_762146.validator(path, query, header, formData, body)
  let scheme = call_762146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762146.url(scheme.get, call_762146.host, call_762146.base,
                         call_762146.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762146, url, valid)

proc call*(call_762147: Call_GetV3ProjectsIdTriggers_762140; id: string;
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdTriggers
  ## Get triggers list
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_762148 = newJObject()
  var query_762149 = newJObject()
  add(path_762148, "id", newJString(id))
  add(query_762149, "per_page", newJInt(perPage))
  add(query_762149, "page", newJInt(page))
  result = call_762147.call(path_762148, query_762149, nil, nil, nil)

var getV3ProjectsIdTriggers* = Call_GetV3ProjectsIdTriggers_762140(
    name: "getV3ProjectsIdTriggers", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/triggers",
    validator: validate_GetV3ProjectsIdTriggers_762141, base: "/api",
    url: url_GetV3ProjectsIdTriggers_762142, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdTriggersToken_762157 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdTriggersToken_762159(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "token" in path, "`token` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/triggers/"),
               (kind: VariableSegment, value: "token")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdTriggersToken_762158(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get specific trigger of a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   token: JString (required)
  ##        : The unique token of trigger
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762160 = path.getOrDefault("id")
  valid_762160 = validateParameter(valid_762160, JString, required = true,
                                 default = nil)
  if valid_762160 != nil:
    section.add "id", valid_762160
  var valid_762161 = path.getOrDefault("token")
  valid_762161 = validateParameter(valid_762161, JString, required = true,
                                 default = nil)
  if valid_762161 != nil:
    section.add "token", valid_762161
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762162: Call_GetV3ProjectsIdTriggersToken_762157; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get specific trigger of a project
  ## 
  let valid = call_762162.validator(path, query, header, formData, body)
  let scheme = call_762162.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762162.url(scheme.get, call_762162.host, call_762162.base,
                         call_762162.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762162, url, valid)

proc call*(call_762163: Call_GetV3ProjectsIdTriggersToken_762157; id: string;
          token: string): Recallable =
  ## getV3ProjectsIdTriggersToken
  ## Get specific trigger of a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   token: string (required)
  ##        : The unique token of trigger
  var path_762164 = newJObject()
  add(path_762164, "id", newJString(id))
  add(path_762164, "token", newJString(token))
  result = call_762163.call(path_762164, nil, nil, nil, nil)

var getV3ProjectsIdTriggersToken* = Call_GetV3ProjectsIdTriggersToken_762157(
    name: "getV3ProjectsIdTriggersToken", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/triggers/{token}",
    validator: validate_GetV3ProjectsIdTriggersToken_762158, base: "/api",
    url: url_GetV3ProjectsIdTriggersToken_762159, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdTriggersToken_762165 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdTriggersToken_762167(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "token" in path, "`token` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/triggers/"),
               (kind: VariableSegment, value: "token")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdTriggersToken_762166(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a trigger
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   token: JString (required)
  ##        : The unique token of trigger
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762168 = path.getOrDefault("id")
  valid_762168 = validateParameter(valid_762168, JString, required = true,
                                 default = nil)
  if valid_762168 != nil:
    section.add "id", valid_762168
  var valid_762169 = path.getOrDefault("token")
  valid_762169 = validateParameter(valid_762169, JString, required = true,
                                 default = nil)
  if valid_762169 != nil:
    section.add "token", valid_762169
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762170: Call_DeleteV3ProjectsIdTriggersToken_762165;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a trigger
  ## 
  let valid = call_762170.validator(path, query, header, formData, body)
  let scheme = call_762170.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762170.url(scheme.get, call_762170.host, call_762170.base,
                         call_762170.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762170, url, valid)

proc call*(call_762171: Call_DeleteV3ProjectsIdTriggersToken_762165; id: string;
          token: string): Recallable =
  ## deleteV3ProjectsIdTriggersToken
  ## Delete a trigger
  ##   id: string (required)
  ##     : The ID of a project
  ##   token: string (required)
  ##        : The unique token of trigger
  var path_762172 = newJObject()
  add(path_762172, "id", newJString(id))
  add(path_762172, "token", newJString(token))
  result = call_762171.call(path_762172, nil, nil, nil, nil)

var deleteV3ProjectsIdTriggersToken* = Call_DeleteV3ProjectsIdTriggersToken_762165(
    name: "deleteV3ProjectsIdTriggersToken", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/triggers/{token}",
    validator: validate_DeleteV3ProjectsIdTriggersToken_762166, base: "/api",
    url: url_DeleteV3ProjectsIdTriggersToken_762167, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdUnarchive_762173 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdUnarchive_762175(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/unarchive")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdUnarchive_762174(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Unarchive a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762176 = path.getOrDefault("id")
  valid_762176 = validateParameter(valid_762176, JString, required = true,
                                 default = nil)
  if valid_762176 != nil:
    section.add "id", valid_762176
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762177: Call_PostV3ProjectsIdUnarchive_762173; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unarchive a project
  ## 
  let valid = call_762177.validator(path, query, header, formData, body)
  let scheme = call_762177.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762177.url(scheme.get, call_762177.host, call_762177.base,
                         call_762177.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762177, url, valid)

proc call*(call_762178: Call_PostV3ProjectsIdUnarchive_762173; id: string): Recallable =
  ## postV3ProjectsIdUnarchive
  ## Unarchive a project
  ##   id: string (required)
  ##     : The ID of a project
  var path_762179 = newJObject()
  add(path_762179, "id", newJString(id))
  result = call_762178.call(path_762179, nil, nil, nil, nil)

var postV3ProjectsIdUnarchive* = Call_PostV3ProjectsIdUnarchive_762173(
    name: "postV3ProjectsIdUnarchive", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/unarchive",
    validator: validate_PostV3ProjectsIdUnarchive_762174, base: "/api",
    url: url_PostV3ProjectsIdUnarchive_762175, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdUploads_762180 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdUploads_762182(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/uploads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdUploads_762181(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Upload a file
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762183 = path.getOrDefault("id")
  valid_762183 = validateParameter(valid_762183, JString, required = true,
                                 default = nil)
  if valid_762183 != nil:
    section.add "id", valid_762183
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   file: JString (required)
  ##       : The file to be uploaded
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `file` field"
  var valid_762184 = formData.getOrDefault("file")
  valid_762184 = validateParameter(valid_762184, JString, required = true,
                                 default = nil)
  if valid_762184 != nil:
    section.add "file", valid_762184
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762185: Call_PostV3ProjectsIdUploads_762180; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Upload a file
  ## 
  let valid = call_762185.validator(path, query, header, formData, body)
  let scheme = call_762185.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762185.url(scheme.get, call_762185.host, call_762185.base,
                         call_762185.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762185, url, valid)

proc call*(call_762186: Call_PostV3ProjectsIdUploads_762180; file: string; id: string): Recallable =
  ## postV3ProjectsIdUploads
  ## Upload a file
  ##   file: string (required)
  ##       : The file to be uploaded
  ##   id: string (required)
  ##     : The ID of a project
  var path_762187 = newJObject()
  var formData_762188 = newJObject()
  add(formData_762188, "file", newJString(file))
  add(path_762187, "id", newJString(id))
  result = call_762186.call(path_762187, nil, nil, formData_762188, nil)

var postV3ProjectsIdUploads* = Call_PostV3ProjectsIdUploads_762180(
    name: "postV3ProjectsIdUploads", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/projects/{id}/uploads",
    validator: validate_PostV3ProjectsIdUploads_762181, base: "/api",
    url: url_PostV3ProjectsIdUploads_762182, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdUsers_762189 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdUsers_762191(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/users")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdUsers_762190(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the users list of a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762192 = path.getOrDefault("id")
  valid_762192 = validateParameter(valid_762192, JString, required = true,
                                 default = nil)
  if valid_762192 != nil:
    section.add "id", valid_762192
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   search: JString
  ##         : Return list of users matching the search criteria
  section = newJObject()
  var valid_762193 = query.getOrDefault("per_page")
  valid_762193 = validateParameter(valid_762193, JInt, required = false, default = nil)
  if valid_762193 != nil:
    section.add "per_page", valid_762193
  var valid_762194 = query.getOrDefault("page")
  valid_762194 = validateParameter(valid_762194, JInt, required = false, default = nil)
  if valid_762194 != nil:
    section.add "page", valid_762194
  var valid_762195 = query.getOrDefault("search")
  valid_762195 = validateParameter(valid_762195, JString, required = false,
                                 default = nil)
  if valid_762195 != nil:
    section.add "search", valid_762195
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762196: Call_GetV3ProjectsIdUsers_762189; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the users list of a project
  ## 
  let valid = call_762196.validator(path, query, header, formData, body)
  let scheme = call_762196.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762196.url(scheme.get, call_762196.host, call_762196.base,
                         call_762196.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762196, url, valid)

proc call*(call_762197: Call_GetV3ProjectsIdUsers_762189; id: string;
          perPage: int = 0; page: int = 0; search: string = ""): Recallable =
  ## getV3ProjectsIdUsers
  ## Get the users list of a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   search: string
  ##         : Return list of users matching the search criteria
  var path_762198 = newJObject()
  var query_762199 = newJObject()
  add(path_762198, "id", newJString(id))
  add(query_762199, "per_page", newJInt(perPage))
  add(query_762199, "page", newJInt(page))
  add(query_762199, "search", newJString(search))
  result = call_762197.call(path_762198, query_762199, nil, nil, nil)

var getV3ProjectsIdUsers* = Call_GetV3ProjectsIdUsers_762189(
    name: "getV3ProjectsIdUsers", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/users", validator: validate_GetV3ProjectsIdUsers_762190,
    base: "/api", url: url_GetV3ProjectsIdUsers_762191, schemes: {Scheme.Https})
type
  Call_PostV3ProjectsIdVariables_762210 = ref object of OpenApiRestCall_758573
proc url_PostV3ProjectsIdVariables_762212(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/variables")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3ProjectsIdVariables_762211(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new variable in a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762213 = path.getOrDefault("id")
  valid_762213 = validateParameter(valid_762213, JString, required = true,
                                 default = nil)
  if valid_762213 != nil:
    section.add "id", valid_762213
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   key: JString (required)
  ##      : The key of the variable
  ##   value: JString (required)
  ##        : The value of the variable
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `key` field"
  var valid_762214 = formData.getOrDefault("key")
  valid_762214 = validateParameter(valid_762214, JString, required = true,
                                 default = nil)
  if valid_762214 != nil:
    section.add "key", valid_762214
  var valid_762215 = formData.getOrDefault("value")
  valid_762215 = validateParameter(valid_762215, JString, required = true,
                                 default = nil)
  if valid_762215 != nil:
    section.add "value", valid_762215
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762216: Call_PostV3ProjectsIdVariables_762210; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new variable in a project
  ## 
  let valid = call_762216.validator(path, query, header, formData, body)
  let scheme = call_762216.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762216.url(scheme.get, call_762216.host, call_762216.base,
                         call_762216.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762216, url, valid)

proc call*(call_762217: Call_PostV3ProjectsIdVariables_762210; id: string;
          key: string; value: string): Recallable =
  ## postV3ProjectsIdVariables
  ## Create a new variable in a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   key: string (required)
  ##      : The key of the variable
  ##   value: string (required)
  ##        : The value of the variable
  var path_762218 = newJObject()
  var formData_762219 = newJObject()
  add(path_762218, "id", newJString(id))
  add(formData_762219, "key", newJString(key))
  add(formData_762219, "value", newJString(value))
  result = call_762217.call(path_762218, nil, nil, formData_762219, nil)

var postV3ProjectsIdVariables* = Call_PostV3ProjectsIdVariables_762210(
    name: "postV3ProjectsIdVariables", meth: HttpMethod.HttpPost,
    host: "gitlab.com", route: "/v3/projects/{id}/variables",
    validator: validate_PostV3ProjectsIdVariables_762211, base: "/api",
    url: url_PostV3ProjectsIdVariables_762212, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdVariables_762200 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdVariables_762202(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/variables")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdVariables_762201(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get project variables
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762203 = path.getOrDefault("id")
  valid_762203 = validateParameter(valid_762203, JString, required = true,
                                 default = nil)
  if valid_762203 != nil:
    section.add "id", valid_762203
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_762204 = query.getOrDefault("per_page")
  valid_762204 = validateParameter(valid_762204, JInt, required = false, default = nil)
  if valid_762204 != nil:
    section.add "per_page", valid_762204
  var valid_762205 = query.getOrDefault("page")
  valid_762205 = validateParameter(valid_762205, JInt, required = false, default = nil)
  if valid_762205 != nil:
    section.add "page", valid_762205
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762206: Call_GetV3ProjectsIdVariables_762200; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get project variables
  ## 
  let valid = call_762206.validator(path, query, header, formData, body)
  let scheme = call_762206.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762206.url(scheme.get, call_762206.host, call_762206.base,
                         call_762206.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762206, url, valid)

proc call*(call_762207: Call_GetV3ProjectsIdVariables_762200; id: string;
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3ProjectsIdVariables
  ## Get project variables
  ##   id: string (required)
  ##     : The ID of a project
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_762208 = newJObject()
  var query_762209 = newJObject()
  add(path_762208, "id", newJString(id))
  add(query_762209, "per_page", newJInt(perPage))
  add(query_762209, "page", newJInt(page))
  result = call_762207.call(path_762208, query_762209, nil, nil, nil)

var getV3ProjectsIdVariables* = Call_GetV3ProjectsIdVariables_762200(
    name: "getV3ProjectsIdVariables", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/projects/{id}/variables",
    validator: validate_GetV3ProjectsIdVariables_762201, base: "/api",
    url: url_GetV3ProjectsIdVariables_762202, schemes: {Scheme.Https})
type
  Call_PutV3ProjectsIdVariablesKey_762228 = ref object of OpenApiRestCall_758573
proc url_PutV3ProjectsIdVariablesKey_762230(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key" in path, "`key` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/variables/"),
               (kind: VariableSegment, value: "key")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3ProjectsIdVariablesKey_762229(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update an existing variable from a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   key: JString (required)
  ##      : The key of the variable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762231 = path.getOrDefault("id")
  valid_762231 = validateParameter(valid_762231, JString, required = true,
                                 default = nil)
  if valid_762231 != nil:
    section.add "id", valid_762231
  var valid_762232 = path.getOrDefault("key")
  valid_762232 = validateParameter(valid_762232, JString, required = true,
                                 default = nil)
  if valid_762232 != nil:
    section.add "key", valid_762232
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   value: JString
  ##        : The value of the variable
  section = newJObject()
  var valid_762233 = formData.getOrDefault("value")
  valid_762233 = validateParameter(valid_762233, JString, required = false,
                                 default = nil)
  if valid_762233 != nil:
    section.add "value", valid_762233
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762234: Call_PutV3ProjectsIdVariablesKey_762228; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update an existing variable from a project
  ## 
  let valid = call_762234.validator(path, query, header, formData, body)
  let scheme = call_762234.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762234.url(scheme.get, call_762234.host, call_762234.base,
                         call_762234.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762234, url, valid)

proc call*(call_762235: Call_PutV3ProjectsIdVariablesKey_762228; id: string;
          key: string; value: string = ""): Recallable =
  ## putV3ProjectsIdVariablesKey
  ## Update an existing variable from a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   key: string (required)
  ##      : The key of the variable
  ##   value: string
  ##        : The value of the variable
  var path_762236 = newJObject()
  var formData_762237 = newJObject()
  add(path_762236, "id", newJString(id))
  add(path_762236, "key", newJString(key))
  add(formData_762237, "value", newJString(value))
  result = call_762235.call(path_762236, nil, nil, formData_762237, nil)

var putV3ProjectsIdVariablesKey* = Call_PutV3ProjectsIdVariablesKey_762228(
    name: "putV3ProjectsIdVariablesKey", meth: HttpMethod.HttpPut,
    host: "gitlab.com", route: "/v3/projects/{id}/variables/{key}",
    validator: validate_PutV3ProjectsIdVariablesKey_762229, base: "/api",
    url: url_PutV3ProjectsIdVariablesKey_762230, schemes: {Scheme.Https})
type
  Call_GetV3ProjectsIdVariablesKey_762220 = ref object of OpenApiRestCall_758573
proc url_GetV3ProjectsIdVariablesKey_762222(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key" in path, "`key` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/variables/"),
               (kind: VariableSegment, value: "key")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3ProjectsIdVariablesKey_762221(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a specific variable from a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   key: JString (required)
  ##      : The key of the variable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762223 = path.getOrDefault("id")
  valid_762223 = validateParameter(valid_762223, JString, required = true,
                                 default = nil)
  if valid_762223 != nil:
    section.add "id", valid_762223
  var valid_762224 = path.getOrDefault("key")
  valid_762224 = validateParameter(valid_762224, JString, required = true,
                                 default = nil)
  if valid_762224 != nil:
    section.add "key", valid_762224
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762225: Call_GetV3ProjectsIdVariablesKey_762220; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a specific variable from a project
  ## 
  let valid = call_762225.validator(path, query, header, formData, body)
  let scheme = call_762225.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762225.url(scheme.get, call_762225.host, call_762225.base,
                         call_762225.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762225, url, valid)

proc call*(call_762226: Call_GetV3ProjectsIdVariablesKey_762220; id: string;
          key: string): Recallable =
  ## getV3ProjectsIdVariablesKey
  ## Get a specific variable from a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   key: string (required)
  ##      : The key of the variable
  var path_762227 = newJObject()
  add(path_762227, "id", newJString(id))
  add(path_762227, "key", newJString(key))
  result = call_762226.call(path_762227, nil, nil, nil, nil)

var getV3ProjectsIdVariablesKey* = Call_GetV3ProjectsIdVariablesKey_762220(
    name: "getV3ProjectsIdVariablesKey", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/projects/{id}/variables/{key}",
    validator: validate_GetV3ProjectsIdVariablesKey_762221, base: "/api",
    url: url_GetV3ProjectsIdVariablesKey_762222, schemes: {Scheme.Https})
type
  Call_DeleteV3ProjectsIdVariablesKey_762238 = ref object of OpenApiRestCall_758573
proc url_DeleteV3ProjectsIdVariablesKey_762240(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key" in path, "`key` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/projects/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/variables/"),
               (kind: VariableSegment, value: "key")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3ProjectsIdVariablesKey_762239(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete an existing variable from a project
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##     : The ID of a project
  ##   key: JString (required)
  ##      : The key of the variable
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762241 = path.getOrDefault("id")
  valid_762241 = validateParameter(valid_762241, JString, required = true,
                                 default = nil)
  if valid_762241 != nil:
    section.add "id", valid_762241
  var valid_762242 = path.getOrDefault("key")
  valid_762242 = validateParameter(valid_762242, JString, required = true,
                                 default = nil)
  if valid_762242 != nil:
    section.add "key", valid_762242
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762243: Call_DeleteV3ProjectsIdVariablesKey_762238; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an existing variable from a project
  ## 
  let valid = call_762243.validator(path, query, header, formData, body)
  let scheme = call_762243.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762243.url(scheme.get, call_762243.host, call_762243.base,
                         call_762243.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762243, url, valid)

proc call*(call_762244: Call_DeleteV3ProjectsIdVariablesKey_762238; id: string;
          key: string): Recallable =
  ## deleteV3ProjectsIdVariablesKey
  ## Delete an existing variable from a project
  ##   id: string (required)
  ##     : The ID of a project
  ##   key: string (required)
  ##      : The key of the variable
  var path_762245 = newJObject()
  add(path_762245, "id", newJString(id))
  add(path_762245, "key", newJString(key))
  result = call_762244.call(path_762245, nil, nil, nil, nil)

var deleteV3ProjectsIdVariablesKey* = Call_DeleteV3ProjectsIdVariablesKey_762238(
    name: "deleteV3ProjectsIdVariablesKey", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/projects/{id}/variables/{key}",
    validator: validate_DeleteV3ProjectsIdVariablesKey_762239, base: "/api",
    url: url_DeleteV3ProjectsIdVariablesKey_762240, schemes: {Scheme.Https})
type
  Call_GetV3Runners_762246 = ref object of OpenApiRestCall_758573
proc url_GetV3Runners_762248(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Runners_762247(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Get runners available for user
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   scope: JString
  ##        : The scope of specific runners to show
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_762249 = query.getOrDefault("scope")
  valid_762249 = validateParameter(valid_762249, JString, required = false,
                                 default = newJString("active"))
  if valid_762249 != nil:
    section.add "scope", valid_762249
  var valid_762250 = query.getOrDefault("per_page")
  valid_762250 = validateParameter(valid_762250, JInt, required = false, default = nil)
  if valid_762250 != nil:
    section.add "per_page", valid_762250
  var valid_762251 = query.getOrDefault("page")
  valid_762251 = validateParameter(valid_762251, JInt, required = false, default = nil)
  if valid_762251 != nil:
    section.add "page", valid_762251
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762252: Call_GetV3Runners_762246; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get runners available for user
  ## 
  let valid = call_762252.validator(path, query, header, formData, body)
  let scheme = call_762252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762252.url(scheme.get, call_762252.host, call_762252.base,
                         call_762252.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762252, url, valid)

proc call*(call_762253: Call_GetV3Runners_762246; scope: string = "active";
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3Runners
  ## Get runners available for user
  ##   scope: string
  ##        : The scope of specific runners to show
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var query_762254 = newJObject()
  add(query_762254, "scope", newJString(scope))
  add(query_762254, "per_page", newJInt(perPage))
  add(query_762254, "page", newJInt(page))
  result = call_762253.call(nil, query_762254, nil, nil, nil)

var getV3Runners* = Call_GetV3Runners_762246(name: "getV3Runners",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/runners",
    validator: validate_GetV3Runners_762247, base: "/api", url: url_GetV3Runners_762248,
    schemes: {Scheme.Https})
type
  Call_GetV3RunnersAll_762255 = ref object of OpenApiRestCall_758573
proc url_GetV3RunnersAll_762257(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3RunnersAll_762256(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Get all runners - shared and specific
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   scope: JString
  ##        : The scope of specific runners to show
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_762258 = query.getOrDefault("scope")
  valid_762258 = validateParameter(valid_762258, JString, required = false,
                                 default = newJString("active"))
  if valid_762258 != nil:
    section.add "scope", valid_762258
  var valid_762259 = query.getOrDefault("per_page")
  valid_762259 = validateParameter(valid_762259, JInt, required = false, default = nil)
  if valid_762259 != nil:
    section.add "per_page", valid_762259
  var valid_762260 = query.getOrDefault("page")
  valid_762260 = validateParameter(valid_762260, JInt, required = false, default = nil)
  if valid_762260 != nil:
    section.add "page", valid_762260
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762261: Call_GetV3RunnersAll_762255; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get all runners - shared and specific
  ## 
  let valid = call_762261.validator(path, query, header, formData, body)
  let scheme = call_762261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762261.url(scheme.get, call_762261.host, call_762261.base,
                         call_762261.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762261, url, valid)

proc call*(call_762262: Call_GetV3RunnersAll_762255; scope: string = "active";
          perPage: int = 0; page: int = 0): Recallable =
  ## getV3RunnersAll
  ## Get all runners - shared and specific
  ##   scope: string
  ##        : The scope of specific runners to show
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var query_762263 = newJObject()
  add(query_762263, "scope", newJString(scope))
  add(query_762263, "per_page", newJInt(perPage))
  add(query_762263, "page", newJInt(page))
  result = call_762262.call(nil, query_762263, nil, nil, nil)

var getV3RunnersAll* = Call_GetV3RunnersAll_762255(name: "getV3RunnersAll",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/runners/all",
    validator: validate_GetV3RunnersAll_762256, base: "/api",
    url: url_GetV3RunnersAll_762257, schemes: {Scheme.Https})
type
  Call_PutV3RunnersId_762271 = ref object of OpenApiRestCall_758573
proc url_PutV3RunnersId_762273(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/runners/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3RunnersId_762272(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Update runner's details
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the runner
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762274 = path.getOrDefault("id")
  valid_762274 = validateParameter(valid_762274, JInt, required = true, default = nil)
  if valid_762274 != nil:
    section.add "id", valid_762274
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   run_untagged: JBool
  ##               : Flag indicating the runner can execute untagged jobs
  ##   tag_list: JArray
  ##           : The list of tags for a runner
  ##   locked: JBool
  ##         : Flag indicating the runner is locked
  ##   description: JString
  ##              : The description of the runner
  ##   active: JBool
  ##         : The state of a runner
  section = newJObject()
  var valid_762275 = formData.getOrDefault("run_untagged")
  valid_762275 = validateParameter(valid_762275, JBool, required = false, default = nil)
  if valid_762275 != nil:
    section.add "run_untagged", valid_762275
  var valid_762276 = formData.getOrDefault("tag_list")
  valid_762276 = validateParameter(valid_762276, JArray, required = false,
                                 default = nil)
  if valid_762276 != nil:
    section.add "tag_list", valid_762276
  var valid_762277 = formData.getOrDefault("locked")
  valid_762277 = validateParameter(valid_762277, JBool, required = false, default = nil)
  if valid_762277 != nil:
    section.add "locked", valid_762277
  var valid_762278 = formData.getOrDefault("description")
  valid_762278 = validateParameter(valid_762278, JString, required = false,
                                 default = nil)
  if valid_762278 != nil:
    section.add "description", valid_762278
  var valid_762279 = formData.getOrDefault("active")
  valid_762279 = validateParameter(valid_762279, JBool, required = false, default = nil)
  if valid_762279 != nil:
    section.add "active", valid_762279
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762280: Call_PutV3RunnersId_762271; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update runner's details
  ## 
  let valid = call_762280.validator(path, query, header, formData, body)
  let scheme = call_762280.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762280.url(scheme.get, call_762280.host, call_762280.base,
                         call_762280.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762280, url, valid)

proc call*(call_762281: Call_PutV3RunnersId_762271; id: int;
          runUntagged: bool = false; tagList: JsonNode = nil; locked: bool = false;
          description: string = ""; active: bool = false): Recallable =
  ## putV3RunnersId
  ## Update runner's details
  ##   runUntagged: bool
  ##              : Flag indicating the runner can execute untagged jobs
  ##   tagList: JArray
  ##          : The list of tags for a runner
  ##   id: int (required)
  ##     : The ID of the runner
  ##   locked: bool
  ##         : Flag indicating the runner is locked
  ##   description: string
  ##              : The description of the runner
  ##   active: bool
  ##         : The state of a runner
  var path_762282 = newJObject()
  var formData_762283 = newJObject()
  add(formData_762283, "run_untagged", newJBool(runUntagged))
  if tagList != nil:
    formData_762283.add "tag_list", tagList
  add(path_762282, "id", newJInt(id))
  add(formData_762283, "locked", newJBool(locked))
  add(formData_762283, "description", newJString(description))
  add(formData_762283, "active", newJBool(active))
  result = call_762281.call(path_762282, nil, nil, formData_762283, nil)

var putV3RunnersId* = Call_PutV3RunnersId_762271(name: "putV3RunnersId",
    meth: HttpMethod.HttpPut, host: "gitlab.com", route: "/v3/runners/{id}",
    validator: validate_PutV3RunnersId_762272, base: "/api",
    url: url_PutV3RunnersId_762273, schemes: {Scheme.Https})
type
  Call_GetV3RunnersId_762264 = ref object of OpenApiRestCall_758573
proc url_GetV3RunnersId_762266(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/runners/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3RunnersId_762265(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Get runner's details
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the runner
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762267 = path.getOrDefault("id")
  valid_762267 = validateParameter(valid_762267, JInt, required = true, default = nil)
  if valid_762267 != nil:
    section.add "id", valid_762267
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762268: Call_GetV3RunnersId_762264; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get runner's details
  ## 
  let valid = call_762268.validator(path, query, header, formData, body)
  let scheme = call_762268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762268.url(scheme.get, call_762268.host, call_762268.base,
                         call_762268.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762268, url, valid)

proc call*(call_762269: Call_GetV3RunnersId_762264; id: int): Recallable =
  ## getV3RunnersId
  ## Get runner's details
  ##   id: int (required)
  ##     : The ID of the runner
  var path_762270 = newJObject()
  add(path_762270, "id", newJInt(id))
  result = call_762269.call(path_762270, nil, nil, nil, nil)

var getV3RunnersId* = Call_GetV3RunnersId_762264(name: "getV3RunnersId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/runners/{id}",
    validator: validate_GetV3RunnersId_762265, base: "/api",
    url: url_GetV3RunnersId_762266, schemes: {Scheme.Https})
type
  Call_DeleteV3RunnersId_762284 = ref object of OpenApiRestCall_758573
proc url_DeleteV3RunnersId_762286(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/runners/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3RunnersId_762285(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Remove a runner
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the runner
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762287 = path.getOrDefault("id")
  valid_762287 = validateParameter(valid_762287, JInt, required = true, default = nil)
  if valid_762287 != nil:
    section.add "id", valid_762287
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762288: Call_DeleteV3RunnersId_762284; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove a runner
  ## 
  let valid = call_762288.validator(path, query, header, formData, body)
  let scheme = call_762288.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762288.url(scheme.get, call_762288.host, call_762288.base,
                         call_762288.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762288, url, valid)

proc call*(call_762289: Call_DeleteV3RunnersId_762284; id: int): Recallable =
  ## deleteV3RunnersId
  ## Remove a runner
  ##   id: int (required)
  ##     : The ID of the runner
  var path_762290 = newJObject()
  add(path_762290, "id", newJInt(id))
  result = call_762289.call(path_762290, nil, nil, nil, nil)

var deleteV3RunnersId* = Call_DeleteV3RunnersId_762284(name: "deleteV3RunnersId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com", route: "/v3/runners/{id}",
    validator: validate_DeleteV3RunnersId_762285, base: "/api",
    url: url_DeleteV3RunnersId_762286, schemes: {Scheme.Https})
type
  Call_PostV3Session_762291 = ref object of OpenApiRestCall_758573
proc url_PostV3Session_762293(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3Session_762292(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Login to get token
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   password: JString (required)
  ##           : The password of the user
  ##   email: JString
  ##        : The email of the user
  ##   login: JString
  ##        : The username
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `password` field"
  var valid_762294 = formData.getOrDefault("password")
  valid_762294 = validateParameter(valid_762294, JString, required = true,
                                 default = nil)
  if valid_762294 != nil:
    section.add "password", valid_762294
  var valid_762295 = formData.getOrDefault("email")
  valid_762295 = validateParameter(valid_762295, JString, required = false,
                                 default = nil)
  if valid_762295 != nil:
    section.add "email", valid_762295
  var valid_762296 = formData.getOrDefault("login")
  valid_762296 = validateParameter(valid_762296, JString, required = false,
                                 default = nil)
  if valid_762296 != nil:
    section.add "login", valid_762296
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762297: Call_PostV3Session_762291; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Login to get token
  ## 
  let valid = call_762297.validator(path, query, header, formData, body)
  let scheme = call_762297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762297.url(scheme.get, call_762297.host, call_762297.base,
                         call_762297.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762297, url, valid)

proc call*(call_762298: Call_PostV3Session_762291; password: string;
          email: string = ""; login: string = ""): Recallable =
  ## postV3Session
  ## Login to get token
  ##   password: string (required)
  ##           : The password of the user
  ##   email: string
  ##        : The email of the user
  ##   login: string
  ##        : The username
  var formData_762299 = newJObject()
  add(formData_762299, "password", newJString(password))
  add(formData_762299, "email", newJString(email))
  add(formData_762299, "login", newJString(login))
  result = call_762298.call(nil, nil, nil, formData_762299, nil)

var postV3Session* = Call_PostV3Session_762291(name: "postV3Session",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/session",
    validator: validate_PostV3Session_762292, base: "/api", url: url_PostV3Session_762293,
    schemes: {Scheme.Https})
type
  Call_GetV3SidekiqCompoundMetrics_762300 = ref object of OpenApiRestCall_758573
proc url_GetV3SidekiqCompoundMetrics_762302(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3SidekiqCompoundMetrics_762301(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the Sidekiq Compound metrics. Includes queue, process, and job statistics
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762303: Call_GetV3SidekiqCompoundMetrics_762300; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the Sidekiq Compound metrics. Includes queue, process, and job statistics
  ## 
  let valid = call_762303.validator(path, query, header, formData, body)
  let scheme = call_762303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762303.url(scheme.get, call_762303.host, call_762303.base,
                         call_762303.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762303, url, valid)

proc call*(call_762304: Call_GetV3SidekiqCompoundMetrics_762300): Recallable =
  ## getV3SidekiqCompoundMetrics
  ## Get the Sidekiq Compound metrics. Includes queue, process, and job statistics
  result = call_762304.call(nil, nil, nil, nil, nil)

var getV3SidekiqCompoundMetrics* = Call_GetV3SidekiqCompoundMetrics_762300(
    name: "getV3SidekiqCompoundMetrics", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/sidekiq/compound_metrics",
    validator: validate_GetV3SidekiqCompoundMetrics_762301, base: "/api",
    url: url_GetV3SidekiqCompoundMetrics_762302, schemes: {Scheme.Https})
type
  Call_GetV3SidekiqJobStats_762305 = ref object of OpenApiRestCall_758573
proc url_GetV3SidekiqJobStats_762307(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3SidekiqJobStats_762306(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the Sidekiq job statistics
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762308: Call_GetV3SidekiqJobStats_762305; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the Sidekiq job statistics
  ## 
  let valid = call_762308.validator(path, query, header, formData, body)
  let scheme = call_762308.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762308.url(scheme.get, call_762308.host, call_762308.base,
                         call_762308.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762308, url, valid)

proc call*(call_762309: Call_GetV3SidekiqJobStats_762305): Recallable =
  ## getV3SidekiqJobStats
  ## Get the Sidekiq job statistics
  result = call_762309.call(nil, nil, nil, nil, nil)

var getV3SidekiqJobStats* = Call_GetV3SidekiqJobStats_762305(
    name: "getV3SidekiqJobStats", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/sidekiq/job_stats", validator: validate_GetV3SidekiqJobStats_762306,
    base: "/api", url: url_GetV3SidekiqJobStats_762307, schemes: {Scheme.Https})
type
  Call_GetV3SidekiqProcessMetrics_762310 = ref object of OpenApiRestCall_758573
proc url_GetV3SidekiqProcessMetrics_762312(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3SidekiqProcessMetrics_762311(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the Sidekiq process metrics
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762313: Call_GetV3SidekiqProcessMetrics_762310; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the Sidekiq process metrics
  ## 
  let valid = call_762313.validator(path, query, header, formData, body)
  let scheme = call_762313.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762313.url(scheme.get, call_762313.host, call_762313.base,
                         call_762313.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762313, url, valid)

proc call*(call_762314: Call_GetV3SidekiqProcessMetrics_762310): Recallable =
  ## getV3SidekiqProcessMetrics
  ## Get the Sidekiq process metrics
  result = call_762314.call(nil, nil, nil, nil, nil)

var getV3SidekiqProcessMetrics* = Call_GetV3SidekiqProcessMetrics_762310(
    name: "getV3SidekiqProcessMetrics", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/sidekiq/process_metrics",
    validator: validate_GetV3SidekiqProcessMetrics_762311, base: "/api",
    url: url_GetV3SidekiqProcessMetrics_762312, schemes: {Scheme.Https})
type
  Call_GetV3SidekiqQueueMetrics_762315 = ref object of OpenApiRestCall_758573
proc url_GetV3SidekiqQueueMetrics_762317(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3SidekiqQueueMetrics_762316(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the Sidekiq queue metrics
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762318: Call_GetV3SidekiqQueueMetrics_762315; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the Sidekiq queue metrics
  ## 
  let valid = call_762318.validator(path, query, header, formData, body)
  let scheme = call_762318.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762318.url(scheme.get, call_762318.host, call_762318.base,
                         call_762318.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762318, url, valid)

proc call*(call_762319: Call_GetV3SidekiqQueueMetrics_762315): Recallable =
  ## getV3SidekiqQueueMetrics
  ## Get the Sidekiq queue metrics
  result = call_762319.call(nil, nil, nil, nil, nil)

var getV3SidekiqQueueMetrics* = Call_GetV3SidekiqQueueMetrics_762315(
    name: "getV3SidekiqQueueMetrics", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/sidekiq/queue_metrics",
    validator: validate_GetV3SidekiqQueueMetrics_762316, base: "/api",
    url: url_GetV3SidekiqQueueMetrics_762317, schemes: {Scheme.Https})
type
  Call_PostV3Snippets_762328 = ref object of OpenApiRestCall_758573
proc url_PostV3Snippets_762330(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3Snippets_762329(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   file_name: JString (required)
  ##            : The name of a snippet file
  ##   content: JString (required)
  ##          : The content of a snippet
  ##   title: JString (required)
  ##        : The title of a snippet
  ##   visibility_level: JInt
  ##                   : The visibility level of the snippet
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `file_name` field"
  var valid_762331 = formData.getOrDefault("file_name")
  valid_762331 = validateParameter(valid_762331, JString, required = true,
                                 default = nil)
  if valid_762331 != nil:
    section.add "file_name", valid_762331
  var valid_762332 = formData.getOrDefault("content")
  valid_762332 = validateParameter(valid_762332, JString, required = true,
                                 default = nil)
  if valid_762332 != nil:
    section.add "content", valid_762332
  var valid_762333 = formData.getOrDefault("title")
  valid_762333 = validateParameter(valid_762333, JString, required = true,
                                 default = nil)
  if valid_762333 != nil:
    section.add "title", valid_762333
  var valid_762334 = formData.getOrDefault("visibility_level")
  valid_762334 = validateParameter(valid_762334, JInt, required = false,
                                 default = newJInt(10))
  if valid_762334 != nil:
    section.add "visibility_level", valid_762334
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762335: Call_PostV3Snippets_762328; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15.
  ## 
  let valid = call_762335.validator(path, query, header, formData, body)
  let scheme = call_762335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762335.url(scheme.get, call_762335.host, call_762335.base,
                         call_762335.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762335, url, valid)

proc call*(call_762336: Call_PostV3Snippets_762328; fileName: string;
          content: string; title: string; visibilityLevel: int = 10): Recallable =
  ## postV3Snippets
  ## This feature was introduced in GitLab 8.15.
  ##   fileName: string (required)
  ##           : The name of a snippet file
  ##   content: string (required)
  ##          : The content of a snippet
  ##   title: string (required)
  ##        : The title of a snippet
  ##   visibilityLevel: int
  ##                  : The visibility level of the snippet
  var formData_762337 = newJObject()
  add(formData_762337, "file_name", newJString(fileName))
  add(formData_762337, "content", newJString(content))
  add(formData_762337, "title", newJString(title))
  add(formData_762337, "visibility_level", newJInt(visibilityLevel))
  result = call_762336.call(nil, nil, nil, formData_762337, nil)

var postV3Snippets* = Call_PostV3Snippets_762328(name: "postV3Snippets",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/snippets",
    validator: validate_PostV3Snippets_762329, base: "/api",
    url: url_PostV3Snippets_762330, schemes: {Scheme.Https})
type
  Call_GetV3Snippets_762320 = ref object of OpenApiRestCall_758573
proc url_GetV3Snippets_762322(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Snippets_762321(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_762323 = query.getOrDefault("per_page")
  valid_762323 = validateParameter(valid_762323, JInt, required = false, default = nil)
  if valid_762323 != nil:
    section.add "per_page", valid_762323
  var valid_762324 = query.getOrDefault("page")
  valid_762324 = validateParameter(valid_762324, JInt, required = false, default = nil)
  if valid_762324 != nil:
    section.add "page", valid_762324
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762325: Call_GetV3Snippets_762320; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15.
  ## 
  let valid = call_762325.validator(path, query, header, formData, body)
  let scheme = call_762325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762325.url(scheme.get, call_762325.host, call_762325.base,
                         call_762325.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762325, url, valid)

proc call*(call_762326: Call_GetV3Snippets_762320; perPage: int = 0; page: int = 0): Recallable =
  ## getV3Snippets
  ## This feature was introduced in GitLab 8.15.
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var query_762327 = newJObject()
  add(query_762327, "per_page", newJInt(perPage))
  add(query_762327, "page", newJInt(page))
  result = call_762326.call(nil, query_762327, nil, nil, nil)

var getV3Snippets* = Call_GetV3Snippets_762320(name: "getV3Snippets",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/snippets",
    validator: validate_GetV3Snippets_762321, base: "/api", url: url_GetV3Snippets_762322,
    schemes: {Scheme.Https})
type
  Call_GetV3SnippetsPublic_762338 = ref object of OpenApiRestCall_758573
proc url_GetV3SnippetsPublic_762340(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3SnippetsPublic_762339(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_762341 = query.getOrDefault("per_page")
  valid_762341 = validateParameter(valid_762341, JInt, required = false, default = nil)
  if valid_762341 != nil:
    section.add "per_page", valid_762341
  var valid_762342 = query.getOrDefault("page")
  valid_762342 = validateParameter(valid_762342, JInt, required = false, default = nil)
  if valid_762342 != nil:
    section.add "page", valid_762342
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762343: Call_GetV3SnippetsPublic_762338; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15.
  ## 
  let valid = call_762343.validator(path, query, header, formData, body)
  let scheme = call_762343.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762343.url(scheme.get, call_762343.host, call_762343.base,
                         call_762343.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762343, url, valid)

proc call*(call_762344: Call_GetV3SnippetsPublic_762338; perPage: int = 0;
          page: int = 0): Recallable =
  ## getV3SnippetsPublic
  ## This feature was introduced in GitLab 8.15.
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var query_762345 = newJObject()
  add(query_762345, "per_page", newJInt(perPage))
  add(query_762345, "page", newJInt(page))
  result = call_762344.call(nil, query_762345, nil, nil, nil)

var getV3SnippetsPublic* = Call_GetV3SnippetsPublic_762338(
    name: "getV3SnippetsPublic", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/snippets/public", validator: validate_GetV3SnippetsPublic_762339,
    base: "/api", url: url_GetV3SnippetsPublic_762340, schemes: {Scheme.Https})
type
  Call_PutV3SnippetsId_762353 = ref object of OpenApiRestCall_758573
proc url_PutV3SnippetsId_762355(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/snippets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3SnippetsId_762354(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of a snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762356 = path.getOrDefault("id")
  valid_762356 = validateParameter(valid_762356, JInt, required = true, default = nil)
  if valid_762356 != nil:
    section.add "id", valid_762356
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   file_name: JString
  ##            : The name of a snippet file
  ##   content: JString
  ##          : The content of a snippet
  ##   title: JString
  ##        : The title of a snippet
  ##   visibility_level: JInt
  ##                   : The visibility level of the snippet
  section = newJObject()
  var valid_762357 = formData.getOrDefault("file_name")
  valid_762357 = validateParameter(valid_762357, JString, required = false,
                                 default = nil)
  if valid_762357 != nil:
    section.add "file_name", valid_762357
  var valid_762358 = formData.getOrDefault("content")
  valid_762358 = validateParameter(valid_762358, JString, required = false,
                                 default = nil)
  if valid_762358 != nil:
    section.add "content", valid_762358
  var valid_762359 = formData.getOrDefault("title")
  valid_762359 = validateParameter(valid_762359, JString, required = false,
                                 default = nil)
  if valid_762359 != nil:
    section.add "title", valid_762359
  var valid_762360 = formData.getOrDefault("visibility_level")
  valid_762360 = validateParameter(valid_762360, JInt, required = false, default = nil)
  if valid_762360 != nil:
    section.add "visibility_level", valid_762360
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762361: Call_PutV3SnippetsId_762353; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15.
  ## 
  let valid = call_762361.validator(path, query, header, formData, body)
  let scheme = call_762361.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762361.url(scheme.get, call_762361.host, call_762361.base,
                         call_762361.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762361, url, valid)

proc call*(call_762362: Call_PutV3SnippetsId_762353; id: int; fileName: string = "";
          content: string = ""; title: string = ""; visibilityLevel: int = 0): Recallable =
  ## putV3SnippetsId
  ## This feature was introduced in GitLab 8.15.
  ##   fileName: string
  ##           : The name of a snippet file
  ##   content: string
  ##          : The content of a snippet
  ##   title: string
  ##        : The title of a snippet
  ##   id: int (required)
  ##     : The ID of a snippet
  ##   visibilityLevel: int
  ##                  : The visibility level of the snippet
  var path_762363 = newJObject()
  var formData_762364 = newJObject()
  add(formData_762364, "file_name", newJString(fileName))
  add(formData_762364, "content", newJString(content))
  add(formData_762364, "title", newJString(title))
  add(path_762363, "id", newJInt(id))
  add(formData_762364, "visibility_level", newJInt(visibilityLevel))
  result = call_762362.call(path_762363, nil, nil, formData_762364, nil)

var putV3SnippetsId* = Call_PutV3SnippetsId_762353(name: "putV3SnippetsId",
    meth: HttpMethod.HttpPut, host: "gitlab.com", route: "/v3/snippets/{id}",
    validator: validate_PutV3SnippetsId_762354, base: "/api",
    url: url_PutV3SnippetsId_762355, schemes: {Scheme.Https})
type
  Call_GetV3SnippetsId_762346 = ref object of OpenApiRestCall_758573
proc url_GetV3SnippetsId_762348(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/snippets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3SnippetsId_762347(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of a snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762349 = path.getOrDefault("id")
  valid_762349 = validateParameter(valid_762349, JInt, required = true, default = nil)
  if valid_762349 != nil:
    section.add "id", valid_762349
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762350: Call_GetV3SnippetsId_762346; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15.
  ## 
  let valid = call_762350.validator(path, query, header, formData, body)
  let scheme = call_762350.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762350.url(scheme.get, call_762350.host, call_762350.base,
                         call_762350.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762350, url, valid)

proc call*(call_762351: Call_GetV3SnippetsId_762346; id: int): Recallable =
  ## getV3SnippetsId
  ## This feature was introduced in GitLab 8.15.
  ##   id: int (required)
  ##     : The ID of a snippet
  var path_762352 = newJObject()
  add(path_762352, "id", newJInt(id))
  result = call_762351.call(path_762352, nil, nil, nil, nil)

var getV3SnippetsId* = Call_GetV3SnippetsId_762346(name: "getV3SnippetsId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/snippets/{id}",
    validator: validate_GetV3SnippetsId_762347, base: "/api",
    url: url_GetV3SnippetsId_762348, schemes: {Scheme.Https})
type
  Call_DeleteV3SnippetsId_762365 = ref object of OpenApiRestCall_758573
proc url_DeleteV3SnippetsId_762367(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/snippets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3SnippetsId_762366(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of a snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762368 = path.getOrDefault("id")
  valid_762368 = validateParameter(valid_762368, JInt, required = true, default = nil)
  if valid_762368 != nil:
    section.add "id", valid_762368
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762369: Call_DeleteV3SnippetsId_762365; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15.
  ## 
  let valid = call_762369.validator(path, query, header, formData, body)
  let scheme = call_762369.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762369.url(scheme.get, call_762369.host, call_762369.base,
                         call_762369.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762369, url, valid)

proc call*(call_762370: Call_DeleteV3SnippetsId_762365; id: int): Recallable =
  ## deleteV3SnippetsId
  ## This feature was introduced in GitLab 8.15.
  ##   id: int (required)
  ##     : The ID of a snippet
  var path_762371 = newJObject()
  add(path_762371, "id", newJInt(id))
  result = call_762370.call(path_762371, nil, nil, nil, nil)

var deleteV3SnippetsId* = Call_DeleteV3SnippetsId_762365(
    name: "deleteV3SnippetsId", meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/snippets/{id}", validator: validate_DeleteV3SnippetsId_762366,
    base: "/api", url: url_DeleteV3SnippetsId_762367, schemes: {Scheme.Https})
type
  Call_GetV3SnippetsIdRaw_762372 = ref object of OpenApiRestCall_758573
proc url_GetV3SnippetsIdRaw_762374(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/snippets/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/raw")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3SnippetsIdRaw_762373(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of a snippet
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762375 = path.getOrDefault("id")
  valid_762375 = validateParameter(valid_762375, JInt, required = true, default = nil)
  if valid_762375 != nil:
    section.add "id", valid_762375
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762376: Call_GetV3SnippetsIdRaw_762372; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15.
  ## 
  let valid = call_762376.validator(path, query, header, formData, body)
  let scheme = call_762376.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762376.url(scheme.get, call_762376.host, call_762376.base,
                         call_762376.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762376, url, valid)

proc call*(call_762377: Call_GetV3SnippetsIdRaw_762372; id: int): Recallable =
  ## getV3SnippetsIdRaw
  ## This feature was introduced in GitLab 8.15.
  ##   id: int (required)
  ##     : The ID of a snippet
  var path_762378 = newJObject()
  add(path_762378, "id", newJInt(id))
  result = call_762377.call(path_762378, nil, nil, nil, nil)

var getV3SnippetsIdRaw* = Call_GetV3SnippetsIdRaw_762372(
    name: "getV3SnippetsIdRaw", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/snippets/{id}/raw", validator: validate_GetV3SnippetsIdRaw_762373,
    base: "/api", url: url_GetV3SnippetsIdRaw_762374, schemes: {Scheme.Https})
type
  Call_GetV3TemplatesDockerfiles_762379 = ref object of OpenApiRestCall_758573
proc url_GetV3TemplatesDockerfiles_762381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3TemplatesDockerfiles_762380(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762382: Call_GetV3TemplatesDockerfiles_762379; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15.
  ## 
  let valid = call_762382.validator(path, query, header, formData, body)
  let scheme = call_762382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762382.url(scheme.get, call_762382.host, call_762382.base,
                         call_762382.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762382, url, valid)

proc call*(call_762383: Call_GetV3TemplatesDockerfiles_762379): Recallable =
  ## getV3TemplatesDockerfiles
  ## This feature was introduced in GitLab 8.15.
  result = call_762383.call(nil, nil, nil, nil, nil)

var getV3TemplatesDockerfiles* = Call_GetV3TemplatesDockerfiles_762379(
    name: "getV3TemplatesDockerfiles", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/templates/dockerfiles",
    validator: validate_GetV3TemplatesDockerfiles_762380, base: "/api",
    url: url_GetV3TemplatesDockerfiles_762381, schemes: {Scheme.Https})
type
  Call_GetV3TemplatesDockerfilesName_762384 = ref object of OpenApiRestCall_758573
proc url_GetV3TemplatesDockerfilesName_762386(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/templates/dockerfiles/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3TemplatesDockerfilesName_762385(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.15.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : The name of the template
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_762387 = path.getOrDefault("name")
  valid_762387 = validateParameter(valid_762387, JString, required = true,
                                 default = nil)
  if valid_762387 != nil:
    section.add "name", valid_762387
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762388: Call_GetV3TemplatesDockerfilesName_762384; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.15.
  ## 
  let valid = call_762388.validator(path, query, header, formData, body)
  let scheme = call_762388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762388.url(scheme.get, call_762388.host, call_762388.base,
                         call_762388.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762388, url, valid)

proc call*(call_762389: Call_GetV3TemplatesDockerfilesName_762384; name: string): Recallable =
  ## getV3TemplatesDockerfilesName
  ## This feature was introduced in GitLab 8.15.
  ##   name: string (required)
  ##       : The name of the template
  var path_762390 = newJObject()
  add(path_762390, "name", newJString(name))
  result = call_762389.call(path_762390, nil, nil, nil, nil)

var getV3TemplatesDockerfilesName* = Call_GetV3TemplatesDockerfilesName_762384(
    name: "getV3TemplatesDockerfilesName", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/templates/dockerfiles/{name}",
    validator: validate_GetV3TemplatesDockerfilesName_762385, base: "/api",
    url: url_GetV3TemplatesDockerfilesName_762386, schemes: {Scheme.Https})
type
  Call_GetV3TemplatesGitignores_762391 = ref object of OpenApiRestCall_758573
proc url_GetV3TemplatesGitignores_762393(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3TemplatesGitignores_762392(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.8.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762394: Call_GetV3TemplatesGitignores_762391; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.8.
  ## 
  let valid = call_762394.validator(path, query, header, formData, body)
  let scheme = call_762394.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762394.url(scheme.get, call_762394.host, call_762394.base,
                         call_762394.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762394, url, valid)

proc call*(call_762395: Call_GetV3TemplatesGitignores_762391): Recallable =
  ## getV3TemplatesGitignores
  ## This feature was introduced in GitLab 8.8.
  result = call_762395.call(nil, nil, nil, nil, nil)

var getV3TemplatesGitignores* = Call_GetV3TemplatesGitignores_762391(
    name: "getV3TemplatesGitignores", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/templates/gitignores",
    validator: validate_GetV3TemplatesGitignores_762392, base: "/api",
    url: url_GetV3TemplatesGitignores_762393, schemes: {Scheme.Https})
type
  Call_GetV3TemplatesGitignoresName_762396 = ref object of OpenApiRestCall_758573
proc url_GetV3TemplatesGitignoresName_762398(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/templates/gitignores/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3TemplatesGitignoresName_762397(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.8.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : The name of the template
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_762399 = path.getOrDefault("name")
  valid_762399 = validateParameter(valid_762399, JString, required = true,
                                 default = nil)
  if valid_762399 != nil:
    section.add "name", valid_762399
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762400: Call_GetV3TemplatesGitignoresName_762396; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.8.
  ## 
  let valid = call_762400.validator(path, query, header, formData, body)
  let scheme = call_762400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762400.url(scheme.get, call_762400.host, call_762400.base,
                         call_762400.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762400, url, valid)

proc call*(call_762401: Call_GetV3TemplatesGitignoresName_762396; name: string): Recallable =
  ## getV3TemplatesGitignoresName
  ## This feature was introduced in GitLab 8.8.
  ##   name: string (required)
  ##       : The name of the template
  var path_762402 = newJObject()
  add(path_762402, "name", newJString(name))
  result = call_762401.call(path_762402, nil, nil, nil, nil)

var getV3TemplatesGitignoresName* = Call_GetV3TemplatesGitignoresName_762396(
    name: "getV3TemplatesGitignoresName", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/templates/gitignores/{name}",
    validator: validate_GetV3TemplatesGitignoresName_762397, base: "/api",
    url: url_GetV3TemplatesGitignoresName_762398, schemes: {Scheme.Https})
type
  Call_GetV3TemplatesGitlabCiYmls_762403 = ref object of OpenApiRestCall_758573
proc url_GetV3TemplatesGitlabCiYmls_762405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3TemplatesGitlabCiYmls_762404(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.9.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762406: Call_GetV3TemplatesGitlabCiYmls_762403; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.9.
  ## 
  let valid = call_762406.validator(path, query, header, formData, body)
  let scheme = call_762406.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762406.url(scheme.get, call_762406.host, call_762406.base,
                         call_762406.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762406, url, valid)

proc call*(call_762407: Call_GetV3TemplatesGitlabCiYmls_762403): Recallable =
  ## getV3TemplatesGitlabCiYmls
  ## This feature was introduced in GitLab 8.9.
  result = call_762407.call(nil, nil, nil, nil, nil)

var getV3TemplatesGitlabCiYmls* = Call_GetV3TemplatesGitlabCiYmls_762403(
    name: "getV3TemplatesGitlabCiYmls", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/templates/gitlab_ci_ymls",
    validator: validate_GetV3TemplatesGitlabCiYmls_762404, base: "/api",
    url: url_GetV3TemplatesGitlabCiYmls_762405, schemes: {Scheme.Https})
type
  Call_GetV3TemplatesGitlabCiYmlsName_762408 = ref object of OpenApiRestCall_758573
proc url_GetV3TemplatesGitlabCiYmlsName_762410(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/templates/gitlab_ci_ymls/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3TemplatesGitlabCiYmlsName_762409(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.9.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : The name of the template
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_762411 = path.getOrDefault("name")
  valid_762411 = validateParameter(valid_762411, JString, required = true,
                                 default = nil)
  if valid_762411 != nil:
    section.add "name", valid_762411
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762412: Call_GetV3TemplatesGitlabCiYmlsName_762408; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.9.
  ## 
  let valid = call_762412.validator(path, query, header, formData, body)
  let scheme = call_762412.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762412.url(scheme.get, call_762412.host, call_762412.base,
                         call_762412.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762412, url, valid)

proc call*(call_762413: Call_GetV3TemplatesGitlabCiYmlsName_762408; name: string): Recallable =
  ## getV3TemplatesGitlabCiYmlsName
  ## This feature was introduced in GitLab 8.9.
  ##   name: string (required)
  ##       : The name of the template
  var path_762414 = newJObject()
  add(path_762414, "name", newJString(name))
  result = call_762413.call(path_762414, nil, nil, nil, nil)

var getV3TemplatesGitlabCiYmlsName* = Call_GetV3TemplatesGitlabCiYmlsName_762408(
    name: "getV3TemplatesGitlabCiYmlsName", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/templates/gitlab_ci_ymls/{name}",
    validator: validate_GetV3TemplatesGitlabCiYmlsName_762409, base: "/api",
    url: url_GetV3TemplatesGitlabCiYmlsName_762410, schemes: {Scheme.Https})
type
  Call_GetV3TemplatesLicenses_762415 = ref object of OpenApiRestCall_758573
proc url_GetV3TemplatesLicenses_762417(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3TemplatesLicenses_762416(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.7.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   popular: JBool
  ##          : If passed, returns only popular licenses
  section = newJObject()
  var valid_762418 = query.getOrDefault("popular")
  valid_762418 = validateParameter(valid_762418, JBool, required = false, default = nil)
  if valid_762418 != nil:
    section.add "popular", valid_762418
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762419: Call_GetV3TemplatesLicenses_762415; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.7.
  ## 
  let valid = call_762419.validator(path, query, header, formData, body)
  let scheme = call_762419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762419.url(scheme.get, call_762419.host, call_762419.base,
                         call_762419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762419, url, valid)

proc call*(call_762420: Call_GetV3TemplatesLicenses_762415; popular: bool = false): Recallable =
  ## getV3TemplatesLicenses
  ## This feature was introduced in GitLab 8.7.
  ##   popular: bool
  ##          : If passed, returns only popular licenses
  var query_762421 = newJObject()
  add(query_762421, "popular", newJBool(popular))
  result = call_762420.call(nil, query_762421, nil, nil, nil)

var getV3TemplatesLicenses* = Call_GetV3TemplatesLicenses_762415(
    name: "getV3TemplatesLicenses", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/templates/licenses", validator: validate_GetV3TemplatesLicenses_762416,
    base: "/api", url: url_GetV3TemplatesLicenses_762417, schemes: {Scheme.Https})
type
  Call_GetV3TemplatesLicensesName_762422 = ref object of OpenApiRestCall_758573
proc url_GetV3TemplatesLicensesName_762424(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/templates/licenses/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3TemplatesLicensesName_762423(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.7.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : The name of the template
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_762425 = path.getOrDefault("name")
  valid_762425 = validateParameter(valid_762425, JString, required = true,
                                 default = nil)
  if valid_762425 != nil:
    section.add "name", valid_762425
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762426: Call_GetV3TemplatesLicensesName_762422; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.7.
  ## 
  let valid = call_762426.validator(path, query, header, formData, body)
  let scheme = call_762426.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762426.url(scheme.get, call_762426.host, call_762426.base,
                         call_762426.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762426, url, valid)

proc call*(call_762427: Call_GetV3TemplatesLicensesName_762422; name: string): Recallable =
  ## getV3TemplatesLicensesName
  ## This feature was introduced in GitLab 8.7.
  ##   name: string (required)
  ##       : The name of the template
  var path_762428 = newJObject()
  add(path_762428, "name", newJString(name))
  result = call_762427.call(path_762428, nil, nil, nil, nil)

var getV3TemplatesLicensesName* = Call_GetV3TemplatesLicensesName_762422(
    name: "getV3TemplatesLicensesName", meth: HttpMethod.HttpGet,
    host: "gitlab.com", route: "/v3/templates/licenses/{name}",
    validator: validate_GetV3TemplatesLicensesName_762423, base: "/api",
    url: url_GetV3TemplatesLicensesName_762424, schemes: {Scheme.Https})
type
  Call_GetV3Todos_762429 = ref object of OpenApiRestCall_758573
proc url_GetV3Todos_762431(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Todos_762430(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a todo list
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_762432 = query.getOrDefault("per_page")
  valid_762432 = validateParameter(valid_762432, JInt, required = false, default = nil)
  if valid_762432 != nil:
    section.add "per_page", valid_762432
  var valid_762433 = query.getOrDefault("page")
  valid_762433 = validateParameter(valid_762433, JInt, required = false, default = nil)
  if valid_762433 != nil:
    section.add "page", valid_762433
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762434: Call_GetV3Todos_762429; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a todo list
  ## 
  let valid = call_762434.validator(path, query, header, formData, body)
  let scheme = call_762434.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762434.url(scheme.get, call_762434.host, call_762434.base,
                         call_762434.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762434, url, valid)

proc call*(call_762435: Call_GetV3Todos_762429; perPage: int = 0; page: int = 0): Recallable =
  ## getV3Todos
  ## Get a todo list
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var query_762436 = newJObject()
  add(query_762436, "per_page", newJInt(perPage))
  add(query_762436, "page", newJInt(page))
  result = call_762435.call(nil, query_762436, nil, nil, nil)

var getV3Todos* = Call_GetV3Todos_762429(name: "getV3Todos",
                                      meth: HttpMethod.HttpGet,
                                      host: "gitlab.com", route: "/v3/todos",
                                      validator: validate_GetV3Todos_762430,
                                      base: "/api", url: url_GetV3Todos_762431,
                                      schemes: {Scheme.Https})
type
  Call_DeleteV3Todos_762437 = ref object of OpenApiRestCall_758573
proc url_DeleteV3Todos_762439(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteV3Todos_762438(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Mark all todos as done
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762440: Call_DeleteV3Todos_762437; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Mark all todos as done
  ## 
  let valid = call_762440.validator(path, query, header, formData, body)
  let scheme = call_762440.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762440.url(scheme.get, call_762440.host, call_762440.base,
                         call_762440.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762440, url, valid)

proc call*(call_762441: Call_DeleteV3Todos_762437): Recallable =
  ## deleteV3Todos
  ## Mark all todos as done
  result = call_762441.call(nil, nil, nil, nil, nil)

var deleteV3Todos* = Call_DeleteV3Todos_762437(name: "deleteV3Todos",
    meth: HttpMethod.HttpDelete, host: "gitlab.com", route: "/v3/todos",
    validator: validate_DeleteV3Todos_762438, base: "/api", url: url_DeleteV3Todos_762439,
    schemes: {Scheme.Https})
type
  Call_DeleteV3TodosId_762442 = ref object of OpenApiRestCall_758573
proc url_DeleteV3TodosId_762444(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/todos/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3TodosId_762443(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Mark a todo as done
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the todo being marked as done
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762445 = path.getOrDefault("id")
  valid_762445 = validateParameter(valid_762445, JInt, required = true, default = nil)
  if valid_762445 != nil:
    section.add "id", valid_762445
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762446: Call_DeleteV3TodosId_762442; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Mark a todo as done
  ## 
  let valid = call_762446.validator(path, query, header, formData, body)
  let scheme = call_762446.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762446.url(scheme.get, call_762446.host, call_762446.base,
                         call_762446.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762446, url, valid)

proc call*(call_762447: Call_DeleteV3TodosId_762442; id: int): Recallable =
  ## deleteV3TodosId
  ## Mark a todo as done
  ##   id: int (required)
  ##     : The ID of the todo being marked as done
  var path_762448 = newJObject()
  add(path_762448, "id", newJInt(id))
  result = call_762447.call(path_762448, nil, nil, nil, nil)

var deleteV3TodosId* = Call_DeleteV3TodosId_762442(name: "deleteV3TodosId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com", route: "/v3/todos/{id}",
    validator: validate_DeleteV3TodosId_762443, base: "/api",
    url: url_DeleteV3TodosId_762444, schemes: {Scheme.Https})
type
  Call_GetV3User_762449 = ref object of OpenApiRestCall_758573
proc url_GetV3User_762451(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3User_762450(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the currently authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762452: Call_GetV3User_762449; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the currently authenticated user
  ## 
  let valid = call_762452.validator(path, query, header, formData, body)
  let scheme = call_762452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762452.url(scheme.get, call_762452.host, call_762452.base,
                         call_762452.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762452, url, valid)

proc call*(call_762453: Call_GetV3User_762449): Recallable =
  ## getV3User
  ## Get the currently authenticated user
  result = call_762453.call(nil, nil, nil, nil, nil)

var getV3User* = Call_GetV3User_762449(name: "getV3User", meth: HttpMethod.HttpGet,
                                    host: "gitlab.com", route: "/v3/user",
                                    validator: validate_GetV3User_762450,
                                    base: "/api", url: url_GetV3User_762451,
                                    schemes: {Scheme.Https})
type
  Call_PostV3UserEmails_762459 = ref object of OpenApiRestCall_758573
proc url_PostV3UserEmails_762461(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3UserEmails_762460(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Add new email address to the currently authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   email: JString (required)
  ##        : The new email
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `email` field"
  var valid_762462 = formData.getOrDefault("email")
  valid_762462 = validateParameter(valid_762462, JString, required = true,
                                 default = nil)
  if valid_762462 != nil:
    section.add "email", valid_762462
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762463: Call_PostV3UserEmails_762459; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Add new email address to the currently authenticated user
  ## 
  let valid = call_762463.validator(path, query, header, formData, body)
  let scheme = call_762463.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762463.url(scheme.get, call_762463.host, call_762463.base,
                         call_762463.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762463, url, valid)

proc call*(call_762464: Call_PostV3UserEmails_762459; email: string): Recallable =
  ## postV3UserEmails
  ## Add new email address to the currently authenticated user
  ##   email: string (required)
  ##        : The new email
  var formData_762465 = newJObject()
  add(formData_762465, "email", newJString(email))
  result = call_762464.call(nil, nil, nil, formData_762465, nil)

var postV3UserEmails* = Call_PostV3UserEmails_762459(name: "postV3UserEmails",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/user/emails",
    validator: validate_PostV3UserEmails_762460, base: "/api",
    url: url_PostV3UserEmails_762461, schemes: {Scheme.Https})
type
  Call_GetV3UserEmails_762454 = ref object of OpenApiRestCall_758573
proc url_GetV3UserEmails_762456(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3UserEmails_762455(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Get the currently authenticated user's email addresses
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762457: Call_GetV3UserEmails_762454; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the currently authenticated user's email addresses
  ## 
  let valid = call_762457.validator(path, query, header, formData, body)
  let scheme = call_762457.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762457.url(scheme.get, call_762457.host, call_762457.base,
                         call_762457.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762457, url, valid)

proc call*(call_762458: Call_GetV3UserEmails_762454): Recallable =
  ## getV3UserEmails
  ## Get the currently authenticated user's email addresses
  result = call_762458.call(nil, nil, nil, nil, nil)

var getV3UserEmails* = Call_GetV3UserEmails_762454(name: "getV3UserEmails",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/user/emails",
    validator: validate_GetV3UserEmails_762455, base: "/api",
    url: url_GetV3UserEmails_762456, schemes: {Scheme.Https})
type
  Call_GetV3UserEmailsEmailId_762466 = ref object of OpenApiRestCall_758573
proc url_GetV3UserEmailsEmailId_762468(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "email_id" in path, "`email_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/user/emails/"),
               (kind: VariableSegment, value: "email_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3UserEmailsEmailId_762467(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single email address owned by the currently authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   email_id: JInt (required)
  ##           : The ID of the email
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `email_id` field"
  var valid_762469 = path.getOrDefault("email_id")
  valid_762469 = validateParameter(valid_762469, JInt, required = true, default = nil)
  if valid_762469 != nil:
    section.add "email_id", valid_762469
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762470: Call_GetV3UserEmailsEmailId_762466; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single email address owned by the currently authenticated user
  ## 
  let valid = call_762470.validator(path, query, header, formData, body)
  let scheme = call_762470.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762470.url(scheme.get, call_762470.host, call_762470.base,
                         call_762470.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762470, url, valid)

proc call*(call_762471: Call_GetV3UserEmailsEmailId_762466; emailId: int): Recallable =
  ## getV3UserEmailsEmailId
  ## Get a single email address owned by the currently authenticated user
  ##   emailId: int (required)
  ##          : The ID of the email
  var path_762472 = newJObject()
  add(path_762472, "email_id", newJInt(emailId))
  result = call_762471.call(path_762472, nil, nil, nil, nil)

var getV3UserEmailsEmailId* = Call_GetV3UserEmailsEmailId_762466(
    name: "getV3UserEmailsEmailId", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/user/emails/{email_id}",
    validator: validate_GetV3UserEmailsEmailId_762467, base: "/api",
    url: url_GetV3UserEmailsEmailId_762468, schemes: {Scheme.Https})
type
  Call_DeleteV3UserEmailsEmailId_762473 = ref object of OpenApiRestCall_758573
proc url_DeleteV3UserEmailsEmailId_762475(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "email_id" in path, "`email_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/user/emails/"),
               (kind: VariableSegment, value: "email_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3UserEmailsEmailId_762474(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete an email address from the currently authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   email_id: JInt (required)
  ##           : The ID of the email
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `email_id` field"
  var valid_762476 = path.getOrDefault("email_id")
  valid_762476 = validateParameter(valid_762476, JInt, required = true, default = nil)
  if valid_762476 != nil:
    section.add "email_id", valid_762476
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762477: Call_DeleteV3UserEmailsEmailId_762473; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an email address from the currently authenticated user
  ## 
  let valid = call_762477.validator(path, query, header, formData, body)
  let scheme = call_762477.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762477.url(scheme.get, call_762477.host, call_762477.base,
                         call_762477.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762477, url, valid)

proc call*(call_762478: Call_DeleteV3UserEmailsEmailId_762473; emailId: int): Recallable =
  ## deleteV3UserEmailsEmailId
  ## Delete an email address from the currently authenticated user
  ##   emailId: int (required)
  ##          : The ID of the email
  var path_762479 = newJObject()
  add(path_762479, "email_id", newJInt(emailId))
  result = call_762478.call(path_762479, nil, nil, nil, nil)

var deleteV3UserEmailsEmailId* = Call_DeleteV3UserEmailsEmailId_762473(
    name: "deleteV3UserEmailsEmailId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/user/emails/{email_id}",
    validator: validate_DeleteV3UserEmailsEmailId_762474, base: "/api",
    url: url_DeleteV3UserEmailsEmailId_762475, schemes: {Scheme.Https})
type
  Call_PostV3UserKeys_762485 = ref object of OpenApiRestCall_758573
proc url_PostV3UserKeys_762487(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3UserKeys_762486(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Add a new SSH key to the currently authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   title: JString (required)
  ##        : The title of the new SSH key
  ##   key: JString (required)
  ##      : The new SSH key
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `title` field"
  var valid_762488 = formData.getOrDefault("title")
  valid_762488 = validateParameter(valid_762488, JString, required = true,
                                 default = nil)
  if valid_762488 != nil:
    section.add "title", valid_762488
  var valid_762489 = formData.getOrDefault("key")
  valid_762489 = validateParameter(valid_762489, JString, required = true,
                                 default = nil)
  if valid_762489 != nil:
    section.add "key", valid_762489
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762490: Call_PostV3UserKeys_762485; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Add a new SSH key to the currently authenticated user
  ## 
  let valid = call_762490.validator(path, query, header, formData, body)
  let scheme = call_762490.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762490.url(scheme.get, call_762490.host, call_762490.base,
                         call_762490.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762490, url, valid)

proc call*(call_762491: Call_PostV3UserKeys_762485; title: string; key: string): Recallable =
  ## postV3UserKeys
  ## Add a new SSH key to the currently authenticated user
  ##   title: string (required)
  ##        : The title of the new SSH key
  ##   key: string (required)
  ##      : The new SSH key
  var formData_762492 = newJObject()
  add(formData_762492, "title", newJString(title))
  add(formData_762492, "key", newJString(key))
  result = call_762491.call(nil, nil, nil, formData_762492, nil)

var postV3UserKeys* = Call_PostV3UserKeys_762485(name: "postV3UserKeys",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/user/keys",
    validator: validate_PostV3UserKeys_762486, base: "/api",
    url: url_PostV3UserKeys_762487, schemes: {Scheme.Https})
type
  Call_GetV3UserKeys_762480 = ref object of OpenApiRestCall_758573
proc url_GetV3UserKeys_762482(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3UserKeys_762481(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the currently authenticated user's SSH keys
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762483: Call_GetV3UserKeys_762480; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the currently authenticated user's SSH keys
  ## 
  let valid = call_762483.validator(path, query, header, formData, body)
  let scheme = call_762483.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762483.url(scheme.get, call_762483.host, call_762483.base,
                         call_762483.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762483, url, valid)

proc call*(call_762484: Call_GetV3UserKeys_762480): Recallable =
  ## getV3UserKeys
  ## Get the currently authenticated user's SSH keys
  result = call_762484.call(nil, nil, nil, nil, nil)

var getV3UserKeys* = Call_GetV3UserKeys_762480(name: "getV3UserKeys",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/user/keys",
    validator: validate_GetV3UserKeys_762481, base: "/api", url: url_GetV3UserKeys_762482,
    schemes: {Scheme.Https})
type
  Call_GetV3UserKeysKeyId_762493 = ref object of OpenApiRestCall_758573
proc url_GetV3UserKeysKeyId_762495(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/user/keys/"),
               (kind: VariableSegment, value: "key_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3UserKeysKeyId_762494(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Get a single key owned by currently authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   key_id: JInt (required)
  ##         : The ID of the SSH key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `key_id` field"
  var valid_762496 = path.getOrDefault("key_id")
  valid_762496 = validateParameter(valid_762496, JInt, required = true, default = nil)
  if valid_762496 != nil:
    section.add "key_id", valid_762496
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762497: Call_GetV3UserKeysKeyId_762493; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single key owned by currently authenticated user
  ## 
  let valid = call_762497.validator(path, query, header, formData, body)
  let scheme = call_762497.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762497.url(scheme.get, call_762497.host, call_762497.base,
                         call_762497.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762497, url, valid)

proc call*(call_762498: Call_GetV3UserKeysKeyId_762493; keyId: int): Recallable =
  ## getV3UserKeysKeyId
  ## Get a single key owned by currently authenticated user
  ##   keyId: int (required)
  ##        : The ID of the SSH key
  var path_762499 = newJObject()
  add(path_762499, "key_id", newJInt(keyId))
  result = call_762498.call(path_762499, nil, nil, nil, nil)

var getV3UserKeysKeyId* = Call_GetV3UserKeysKeyId_762493(
    name: "getV3UserKeysKeyId", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/user/keys/{key_id}", validator: validate_GetV3UserKeysKeyId_762494,
    base: "/api", url: url_GetV3UserKeysKeyId_762495, schemes: {Scheme.Https})
type
  Call_DeleteV3UserKeysKeyId_762500 = ref object of OpenApiRestCall_758573
proc url_DeleteV3UserKeysKeyId_762502(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/user/keys/"),
               (kind: VariableSegment, value: "key_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3UserKeysKeyId_762501(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete an SSH key from the currently authenticated user
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   key_id: JInt (required)
  ##         : The ID of the SSH key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `key_id` field"
  var valid_762503 = path.getOrDefault("key_id")
  valid_762503 = validateParameter(valid_762503, JInt, required = true, default = nil)
  if valid_762503 != nil:
    section.add "key_id", valid_762503
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762504: Call_DeleteV3UserKeysKeyId_762500; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an SSH key from the currently authenticated user
  ## 
  let valid = call_762504.validator(path, query, header, formData, body)
  let scheme = call_762504.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762504.url(scheme.get, call_762504.host, call_762504.base,
                         call_762504.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762504, url, valid)

proc call*(call_762505: Call_DeleteV3UserKeysKeyId_762500; keyId: int): Recallable =
  ## deleteV3UserKeysKeyId
  ## Delete an SSH key from the currently authenticated user
  ##   keyId: int (required)
  ##        : The ID of the SSH key
  var path_762506 = newJObject()
  add(path_762506, "key_id", newJInt(keyId))
  result = call_762505.call(path_762506, nil, nil, nil, nil)

var deleteV3UserKeysKeyId* = Call_DeleteV3UserKeysKeyId_762500(
    name: "deleteV3UserKeysKeyId", meth: HttpMethod.HttpDelete, host: "gitlab.com",
    route: "/v3/user/keys/{key_id}", validator: validate_DeleteV3UserKeysKeyId_762501,
    base: "/api", url: url_DeleteV3UserKeysKeyId_762502, schemes: {Scheme.Https})
type
  Call_PostV3Users_762520 = ref object of OpenApiRestCall_758573
proc url_PostV3Users_762522(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostV3Users_762521(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   password: JString (required)
  ##           : The password of the new user
  ##   email: JString (required)
  ##        : The email of the user
  ##   organization: JString
  ##               : The organization of the user
  ##   provider: JString
  ##           : The external provider
  ##   website_url: JString
  ##              : The website of the user
  ##   external: JBool
  ##           : Flag indicating the user is an external user
  ##   linkedin: JString
  ##           : The LinkedIn username
  ##   location: JString
  ##           : The location of the user
  ##   twitter: JString
  ##          : The Twitter username
  ##   confirm: JBool
  ##          : Flag indicating the account needs to be confirmed
  ##   extern_uid: JString
  ##             : The external authentication provider UID
  ##   can_create_group: JBool
  ##                   : Flag indicating the user can create groups
  ##   admin: JBool
  ##        : Flag indicating the user is an administrator
  ##   bio: JString
  ##      : The biography of the user
  ##   username: JString (required)
  ##           : The username of the user
  ##   skype: JString
  ##        : The Skype username
  ##   projects_limit: JInt
  ##                 : The number of projects a user can create
  ##   name: JString (required)
  ##       : The name of the user
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `password` field"
  var valid_762523 = formData.getOrDefault("password")
  valid_762523 = validateParameter(valid_762523, JString, required = true,
                                 default = nil)
  if valid_762523 != nil:
    section.add "password", valid_762523
  var valid_762524 = formData.getOrDefault("email")
  valid_762524 = validateParameter(valid_762524, JString, required = true,
                                 default = nil)
  if valid_762524 != nil:
    section.add "email", valid_762524
  var valid_762525 = formData.getOrDefault("organization")
  valid_762525 = validateParameter(valid_762525, JString, required = false,
                                 default = nil)
  if valid_762525 != nil:
    section.add "organization", valid_762525
  var valid_762526 = formData.getOrDefault("provider")
  valid_762526 = validateParameter(valid_762526, JString, required = false,
                                 default = nil)
  if valid_762526 != nil:
    section.add "provider", valid_762526
  var valid_762527 = formData.getOrDefault("website_url")
  valid_762527 = validateParameter(valid_762527, JString, required = false,
                                 default = nil)
  if valid_762527 != nil:
    section.add "website_url", valid_762527
  var valid_762528 = formData.getOrDefault("external")
  valid_762528 = validateParameter(valid_762528, JBool, required = false, default = nil)
  if valid_762528 != nil:
    section.add "external", valid_762528
  var valid_762529 = formData.getOrDefault("linkedin")
  valid_762529 = validateParameter(valid_762529, JString, required = false,
                                 default = nil)
  if valid_762529 != nil:
    section.add "linkedin", valid_762529
  var valid_762530 = formData.getOrDefault("location")
  valid_762530 = validateParameter(valid_762530, JString, required = false,
                                 default = nil)
  if valid_762530 != nil:
    section.add "location", valid_762530
  var valid_762531 = formData.getOrDefault("twitter")
  valid_762531 = validateParameter(valid_762531, JString, required = false,
                                 default = nil)
  if valid_762531 != nil:
    section.add "twitter", valid_762531
  var valid_762532 = formData.getOrDefault("confirm")
  valid_762532 = validateParameter(valid_762532, JBool, required = false, default = nil)
  if valid_762532 != nil:
    section.add "confirm", valid_762532
  var valid_762533 = formData.getOrDefault("extern_uid")
  valid_762533 = validateParameter(valid_762533, JString, required = false,
                                 default = nil)
  if valid_762533 != nil:
    section.add "extern_uid", valid_762533
  var valid_762534 = formData.getOrDefault("can_create_group")
  valid_762534 = validateParameter(valid_762534, JBool, required = false, default = nil)
  if valid_762534 != nil:
    section.add "can_create_group", valid_762534
  var valid_762535 = formData.getOrDefault("admin")
  valid_762535 = validateParameter(valid_762535, JBool, required = false, default = nil)
  if valid_762535 != nil:
    section.add "admin", valid_762535
  var valid_762536 = formData.getOrDefault("bio")
  valid_762536 = validateParameter(valid_762536, JString, required = false,
                                 default = nil)
  if valid_762536 != nil:
    section.add "bio", valid_762536
  var valid_762537 = formData.getOrDefault("username")
  valid_762537 = validateParameter(valid_762537, JString, required = true,
                                 default = nil)
  if valid_762537 != nil:
    section.add "username", valid_762537
  var valid_762538 = formData.getOrDefault("skype")
  valid_762538 = validateParameter(valid_762538, JString, required = false,
                                 default = nil)
  if valid_762538 != nil:
    section.add "skype", valid_762538
  var valid_762539 = formData.getOrDefault("projects_limit")
  valid_762539 = validateParameter(valid_762539, JInt, required = false, default = nil)
  if valid_762539 != nil:
    section.add "projects_limit", valid_762539
  var valid_762540 = formData.getOrDefault("name")
  valid_762540 = validateParameter(valid_762540, JString, required = true,
                                 default = nil)
  if valid_762540 != nil:
    section.add "name", valid_762540
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762541: Call_PostV3Users_762520; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a user. Available only for admins.
  ## 
  let valid = call_762541.validator(path, query, header, formData, body)
  let scheme = call_762541.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762541.url(scheme.get, call_762541.host, call_762541.base,
                         call_762541.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762541, url, valid)

proc call*(call_762542: Call_PostV3Users_762520; password: string; email: string;
          username: string; name: string; organization: string = "";
          provider: string = ""; websiteUrl: string = ""; external: bool = false;
          linkedin: string = ""; location: string = ""; twitter: string = "";
          confirm: bool = false; externUid: string = ""; canCreateGroup: bool = false;
          admin: bool = false; bio: string = ""; skype: string = ""; projectsLimit: int = 0): Recallable =
  ## postV3Users
  ## Create a user. Available only for admins.
  ##   password: string (required)
  ##           : The password of the new user
  ##   email: string (required)
  ##        : The email of the user
  ##   organization: string
  ##               : The organization of the user
  ##   provider: string
  ##           : The external provider
  ##   websiteUrl: string
  ##             : The website of the user
  ##   external: bool
  ##           : Flag indicating the user is an external user
  ##   linkedin: string
  ##           : The LinkedIn username
  ##   location: string
  ##           : The location of the user
  ##   twitter: string
  ##          : The Twitter username
  ##   confirm: bool
  ##          : Flag indicating the account needs to be confirmed
  ##   externUid: string
  ##            : The external authentication provider UID
  ##   canCreateGroup: bool
  ##                 : Flag indicating the user can create groups
  ##   admin: bool
  ##        : Flag indicating the user is an administrator
  ##   bio: string
  ##      : The biography of the user
  ##   username: string (required)
  ##           : The username of the user
  ##   skype: string
  ##        : The Skype username
  ##   projectsLimit: int
  ##                : The number of projects a user can create
  ##   name: string (required)
  ##       : The name of the user
  var formData_762543 = newJObject()
  add(formData_762543, "password", newJString(password))
  add(formData_762543, "email", newJString(email))
  add(formData_762543, "organization", newJString(organization))
  add(formData_762543, "provider", newJString(provider))
  add(formData_762543, "website_url", newJString(websiteUrl))
  add(formData_762543, "external", newJBool(external))
  add(formData_762543, "linkedin", newJString(linkedin))
  add(formData_762543, "location", newJString(location))
  add(formData_762543, "twitter", newJString(twitter))
  add(formData_762543, "confirm", newJBool(confirm))
  add(formData_762543, "extern_uid", newJString(externUid))
  add(formData_762543, "can_create_group", newJBool(canCreateGroup))
  add(formData_762543, "admin", newJBool(admin))
  add(formData_762543, "bio", newJString(bio))
  add(formData_762543, "username", newJString(username))
  add(formData_762543, "skype", newJString(skype))
  add(formData_762543, "projects_limit", newJInt(projectsLimit))
  add(formData_762543, "name", newJString(name))
  result = call_762542.call(nil, nil, nil, formData_762543, nil)

var postV3Users* = Call_PostV3Users_762520(name: "postV3Users",
                                        meth: HttpMethod.HttpPost,
                                        host: "gitlab.com", route: "/v3/users",
                                        validator: validate_PostV3Users_762521,
                                        base: "/api", url: url_PostV3Users_762522,
                                        schemes: {Scheme.Https})
type
  Call_GetV3Users_762507 = ref object of OpenApiRestCall_758573
proc url_GetV3Users_762509(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Users_762508(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the list of users
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   active: JBool
  ##         : Filters only active users
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  ##   username: JString
  ##           : Get a single user with a specific username
  ##   external: JBool
  ##           : Filters only external users
  ##   search: JString
  ##         : Search for a username
  ##   blocked: JBool
  ##          : Filters only blocked users
  section = newJObject()
  var valid_762510 = query.getOrDefault("active")
  valid_762510 = validateParameter(valid_762510, JBool, required = false, default = nil)
  if valid_762510 != nil:
    section.add "active", valid_762510
  var valid_762511 = query.getOrDefault("per_page")
  valid_762511 = validateParameter(valid_762511, JInt, required = false, default = nil)
  if valid_762511 != nil:
    section.add "per_page", valid_762511
  var valid_762512 = query.getOrDefault("page")
  valid_762512 = validateParameter(valid_762512, JInt, required = false, default = nil)
  if valid_762512 != nil:
    section.add "page", valid_762512
  var valid_762513 = query.getOrDefault("username")
  valid_762513 = validateParameter(valid_762513, JString, required = false,
                                 default = nil)
  if valid_762513 != nil:
    section.add "username", valid_762513
  var valid_762514 = query.getOrDefault("external")
  valid_762514 = validateParameter(valid_762514, JBool, required = false, default = nil)
  if valid_762514 != nil:
    section.add "external", valid_762514
  var valid_762515 = query.getOrDefault("search")
  valid_762515 = validateParameter(valid_762515, JString, required = false,
                                 default = nil)
  if valid_762515 != nil:
    section.add "search", valid_762515
  var valid_762516 = query.getOrDefault("blocked")
  valid_762516 = validateParameter(valid_762516, JBool, required = false, default = nil)
  if valid_762516 != nil:
    section.add "blocked", valid_762516
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762517: Call_GetV3Users_762507; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the list of users
  ## 
  let valid = call_762517.validator(path, query, header, formData, body)
  let scheme = call_762517.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762517.url(scheme.get, call_762517.host, call_762517.base,
                         call_762517.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762517, url, valid)

proc call*(call_762518: Call_GetV3Users_762507; active: bool = false; perPage: int = 0;
          page: int = 0; username: string = ""; external: bool = false; search: string = "";
          blocked: bool = false): Recallable =
  ## getV3Users
  ## Get the list of users
  ##   active: bool
  ##         : Filters only active users
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  ##   username: string
  ##           : Get a single user with a specific username
  ##   external: bool
  ##           : Filters only external users
  ##   search: string
  ##         : Search for a username
  ##   blocked: bool
  ##          : Filters only blocked users
  var query_762519 = newJObject()
  add(query_762519, "active", newJBool(active))
  add(query_762519, "per_page", newJInt(perPage))
  add(query_762519, "page", newJInt(page))
  add(query_762519, "username", newJString(username))
  add(query_762519, "external", newJBool(external))
  add(query_762519, "search", newJString(search))
  add(query_762519, "blocked", newJBool(blocked))
  result = call_762518.call(nil, query_762519, nil, nil, nil)

var getV3Users* = Call_GetV3Users_762507(name: "getV3Users",
                                      meth: HttpMethod.HttpGet,
                                      host: "gitlab.com", route: "/v3/users",
                                      validator: validate_GetV3Users_762508,
                                      base: "/api", url: url_GetV3Users_762509,
                                      schemes: {Scheme.Https})
type
  Call_PutV3UsersId_762551 = ref object of OpenApiRestCall_758573
proc url_PutV3UsersId_762553(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3UsersId_762552(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762554 = path.getOrDefault("id")
  valid_762554 = validateParameter(valid_762554, JInt, required = true, default = nil)
  if valid_762554 != nil:
    section.add "id", valid_762554
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   password: JString
  ##           : The password of the new user
  ##   email: JString
  ##        : The email of the user
  ##   organization: JString
  ##               : The organization of the user
  ##   provider: JString
  ##           : The external provider
  ##   website_url: JString
  ##              : The website of the user
  ##   external: JBool
  ##           : Flag indicating the user is an external user
  ##   linkedin: JString
  ##           : The LinkedIn username
  ##   location: JString
  ##           : The location of the user
  ##   twitter: JString
  ##          : The Twitter username
  ##   confirm: JBool
  ##          : Flag indicating the account needs to be confirmed
  ##   extern_uid: JString
  ##             : The external authentication provider UID
  ##   can_create_group: JBool
  ##                   : Flag indicating the user can create groups
  ##   admin: JBool
  ##        : Flag indicating the user is an administrator
  ##   bio: JString
  ##      : The biography of the user
  ##   username: JString
  ##           : The username of the user
  ##   skype: JString
  ##        : The Skype username
  ##   projects_limit: JInt
  ##                 : The number of projects a user can create
  ##   name: JString
  ##       : The name of the user
  section = newJObject()
  var valid_762555 = formData.getOrDefault("password")
  valid_762555 = validateParameter(valid_762555, JString, required = false,
                                 default = nil)
  if valid_762555 != nil:
    section.add "password", valid_762555
  var valid_762556 = formData.getOrDefault("email")
  valid_762556 = validateParameter(valid_762556, JString, required = false,
                                 default = nil)
  if valid_762556 != nil:
    section.add "email", valid_762556
  var valid_762557 = formData.getOrDefault("organization")
  valid_762557 = validateParameter(valid_762557, JString, required = false,
                                 default = nil)
  if valid_762557 != nil:
    section.add "organization", valid_762557
  var valid_762558 = formData.getOrDefault("provider")
  valid_762558 = validateParameter(valid_762558, JString, required = false,
                                 default = nil)
  if valid_762558 != nil:
    section.add "provider", valid_762558
  var valid_762559 = formData.getOrDefault("website_url")
  valid_762559 = validateParameter(valid_762559, JString, required = false,
                                 default = nil)
  if valid_762559 != nil:
    section.add "website_url", valid_762559
  var valid_762560 = formData.getOrDefault("external")
  valid_762560 = validateParameter(valid_762560, JBool, required = false, default = nil)
  if valid_762560 != nil:
    section.add "external", valid_762560
  var valid_762561 = formData.getOrDefault("linkedin")
  valid_762561 = validateParameter(valid_762561, JString, required = false,
                                 default = nil)
  if valid_762561 != nil:
    section.add "linkedin", valid_762561
  var valid_762562 = formData.getOrDefault("location")
  valid_762562 = validateParameter(valid_762562, JString, required = false,
                                 default = nil)
  if valid_762562 != nil:
    section.add "location", valid_762562
  var valid_762563 = formData.getOrDefault("twitter")
  valid_762563 = validateParameter(valid_762563, JString, required = false,
                                 default = nil)
  if valid_762563 != nil:
    section.add "twitter", valid_762563
  var valid_762564 = formData.getOrDefault("confirm")
  valid_762564 = validateParameter(valid_762564, JBool, required = false, default = nil)
  if valid_762564 != nil:
    section.add "confirm", valid_762564
  var valid_762565 = formData.getOrDefault("extern_uid")
  valid_762565 = validateParameter(valid_762565, JString, required = false,
                                 default = nil)
  if valid_762565 != nil:
    section.add "extern_uid", valid_762565
  var valid_762566 = formData.getOrDefault("can_create_group")
  valid_762566 = validateParameter(valid_762566, JBool, required = false, default = nil)
  if valid_762566 != nil:
    section.add "can_create_group", valid_762566
  var valid_762567 = formData.getOrDefault("admin")
  valid_762567 = validateParameter(valid_762567, JBool, required = false, default = nil)
  if valid_762567 != nil:
    section.add "admin", valid_762567
  var valid_762568 = formData.getOrDefault("bio")
  valid_762568 = validateParameter(valid_762568, JString, required = false,
                                 default = nil)
  if valid_762568 != nil:
    section.add "bio", valid_762568
  var valid_762569 = formData.getOrDefault("username")
  valid_762569 = validateParameter(valid_762569, JString, required = false,
                                 default = nil)
  if valid_762569 != nil:
    section.add "username", valid_762569
  var valid_762570 = formData.getOrDefault("skype")
  valid_762570 = validateParameter(valid_762570, JString, required = false,
                                 default = nil)
  if valid_762570 != nil:
    section.add "skype", valid_762570
  var valid_762571 = formData.getOrDefault("projects_limit")
  valid_762571 = validateParameter(valid_762571, JInt, required = false, default = nil)
  if valid_762571 != nil:
    section.add "projects_limit", valid_762571
  var valid_762572 = formData.getOrDefault("name")
  valid_762572 = validateParameter(valid_762572, JString, required = false,
                                 default = nil)
  if valid_762572 != nil:
    section.add "name", valid_762572
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762573: Call_PutV3UsersId_762551; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a user. Available only for admins.
  ## 
  let valid = call_762573.validator(path, query, header, formData, body)
  let scheme = call_762573.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762573.url(scheme.get, call_762573.host, call_762573.base,
                         call_762573.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762573, url, valid)

proc call*(call_762574: Call_PutV3UsersId_762551; id: int; password: string = "";
          email: string = ""; organization: string = ""; provider: string = "";
          websiteUrl: string = ""; external: bool = false; linkedin: string = "";
          location: string = ""; twitter: string = ""; confirm: bool = false;
          externUid: string = ""; canCreateGroup: bool = false; admin: bool = false;
          bio: string = ""; username: string = ""; skype: string = "";
          projectsLimit: int = 0; name: string = ""): Recallable =
  ## putV3UsersId
  ## Update a user. Available only for admins.
  ##   password: string
  ##           : The password of the new user
  ##   email: string
  ##        : The email of the user
  ##   organization: string
  ##               : The organization of the user
  ##   provider: string
  ##           : The external provider
  ##   id: int (required)
  ##     : The ID of the user
  ##   websiteUrl: string
  ##             : The website of the user
  ##   external: bool
  ##           : Flag indicating the user is an external user
  ##   linkedin: string
  ##           : The LinkedIn username
  ##   location: string
  ##           : The location of the user
  ##   twitter: string
  ##          : The Twitter username
  ##   confirm: bool
  ##          : Flag indicating the account needs to be confirmed
  ##   externUid: string
  ##            : The external authentication provider UID
  ##   canCreateGroup: bool
  ##                 : Flag indicating the user can create groups
  ##   admin: bool
  ##        : Flag indicating the user is an administrator
  ##   bio: string
  ##      : The biography of the user
  ##   username: string
  ##           : The username of the user
  ##   skype: string
  ##        : The Skype username
  ##   projectsLimit: int
  ##                : The number of projects a user can create
  ##   name: string
  ##       : The name of the user
  var path_762575 = newJObject()
  var formData_762576 = newJObject()
  add(formData_762576, "password", newJString(password))
  add(formData_762576, "email", newJString(email))
  add(formData_762576, "organization", newJString(organization))
  add(formData_762576, "provider", newJString(provider))
  add(path_762575, "id", newJInt(id))
  add(formData_762576, "website_url", newJString(websiteUrl))
  add(formData_762576, "external", newJBool(external))
  add(formData_762576, "linkedin", newJString(linkedin))
  add(formData_762576, "location", newJString(location))
  add(formData_762576, "twitter", newJString(twitter))
  add(formData_762576, "confirm", newJBool(confirm))
  add(formData_762576, "extern_uid", newJString(externUid))
  add(formData_762576, "can_create_group", newJBool(canCreateGroup))
  add(formData_762576, "admin", newJBool(admin))
  add(formData_762576, "bio", newJString(bio))
  add(formData_762576, "username", newJString(username))
  add(formData_762576, "skype", newJString(skype))
  add(formData_762576, "projects_limit", newJInt(projectsLimit))
  add(formData_762576, "name", newJString(name))
  result = call_762574.call(path_762575, nil, nil, formData_762576, nil)

var putV3UsersId* = Call_PutV3UsersId_762551(name: "putV3UsersId",
    meth: HttpMethod.HttpPut, host: "gitlab.com", route: "/v3/users/{id}",
    validator: validate_PutV3UsersId_762552, base: "/api", url: url_PutV3UsersId_762553,
    schemes: {Scheme.Https})
type
  Call_GetV3UsersId_762544 = ref object of OpenApiRestCall_758573
proc url_GetV3UsersId_762546(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3UsersId_762545(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single user
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762547 = path.getOrDefault("id")
  valid_762547 = validateParameter(valid_762547, JInt, required = true, default = nil)
  if valid_762547 != nil:
    section.add "id", valid_762547
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762548: Call_GetV3UsersId_762544; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single user
  ## 
  let valid = call_762548.validator(path, query, header, formData, body)
  let scheme = call_762548.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762548.url(scheme.get, call_762548.host, call_762548.base,
                         call_762548.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762548, url, valid)

proc call*(call_762549: Call_GetV3UsersId_762544; id: int): Recallable =
  ## getV3UsersId
  ## Get a single user
  ##   id: int (required)
  ##     : The ID of the user
  var path_762550 = newJObject()
  add(path_762550, "id", newJInt(id))
  result = call_762549.call(path_762550, nil, nil, nil, nil)

var getV3UsersId* = Call_GetV3UsersId_762544(name: "getV3UsersId",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/users/{id}",
    validator: validate_GetV3UsersId_762545, base: "/api", url: url_GetV3UsersId_762546,
    schemes: {Scheme.Https})
type
  Call_DeleteV3UsersId_762577 = ref object of OpenApiRestCall_758573
proc url_DeleteV3UsersId_762579(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3UsersId_762578(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete a user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762580 = path.getOrDefault("id")
  valid_762580 = validateParameter(valid_762580, JInt, required = true, default = nil)
  if valid_762580 != nil:
    section.add "id", valid_762580
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762581: Call_DeleteV3UsersId_762577; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a user. Available only for admins.
  ## 
  let valid = call_762581.validator(path, query, header, formData, body)
  let scheme = call_762581.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762581.url(scheme.get, call_762581.host, call_762581.base,
                         call_762581.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762581, url, valid)

proc call*(call_762582: Call_DeleteV3UsersId_762577; id: int): Recallable =
  ## deleteV3UsersId
  ## Delete a user. Available only for admins.
  ##   id: int (required)
  ##     : The ID of the user
  var path_762583 = newJObject()
  add(path_762583, "id", newJInt(id))
  result = call_762582.call(path_762583, nil, nil, nil, nil)

var deleteV3UsersId* = Call_DeleteV3UsersId_762577(name: "deleteV3UsersId",
    meth: HttpMethod.HttpDelete, host: "gitlab.com", route: "/v3/users/{id}",
    validator: validate_DeleteV3UsersId_762578, base: "/api",
    url: url_DeleteV3UsersId_762579, schemes: {Scheme.Https})
type
  Call_PutV3UsersIdBlock_762584 = ref object of OpenApiRestCall_758573
proc url_PutV3UsersIdBlock_762586(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/block")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3UsersIdBlock_762585(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Block a user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762587 = path.getOrDefault("id")
  valid_762587 = validateParameter(valid_762587, JInt, required = true, default = nil)
  if valid_762587 != nil:
    section.add "id", valid_762587
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762588: Call_PutV3UsersIdBlock_762584; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Block a user. Available only for admins.
  ## 
  let valid = call_762588.validator(path, query, header, formData, body)
  let scheme = call_762588.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762588.url(scheme.get, call_762588.host, call_762588.base,
                         call_762588.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762588, url, valid)

proc call*(call_762589: Call_PutV3UsersIdBlock_762584; id: int): Recallable =
  ## putV3UsersIdBlock
  ## Block a user. Available only for admins.
  ##   id: int (required)
  ##     : The ID of the user
  var path_762590 = newJObject()
  add(path_762590, "id", newJInt(id))
  result = call_762589.call(path_762590, nil, nil, nil, nil)

var putV3UsersIdBlock* = Call_PutV3UsersIdBlock_762584(name: "putV3UsersIdBlock",
    meth: HttpMethod.HttpPut, host: "gitlab.com", route: "/v3/users/{id}/block",
    validator: validate_PutV3UsersIdBlock_762585, base: "/api",
    url: url_PutV3UsersIdBlock_762586, schemes: {Scheme.Https})
type
  Call_PostV3UsersIdEmails_762598 = ref object of OpenApiRestCall_758573
proc url_PostV3UsersIdEmails_762600(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/emails")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3UsersIdEmails_762599(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Add an email address to a specified user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762601 = path.getOrDefault("id")
  valid_762601 = validateParameter(valid_762601, JInt, required = true, default = nil)
  if valid_762601 != nil:
    section.add "id", valid_762601
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   email: JString (required)
  ##        : The email of the user
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `email` field"
  var valid_762602 = formData.getOrDefault("email")
  valid_762602 = validateParameter(valid_762602, JString, required = true,
                                 default = nil)
  if valid_762602 != nil:
    section.add "email", valid_762602
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762603: Call_PostV3UsersIdEmails_762598; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Add an email address to a specified user. Available only for admins.
  ## 
  let valid = call_762603.validator(path, query, header, formData, body)
  let scheme = call_762603.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762603.url(scheme.get, call_762603.host, call_762603.base,
                         call_762603.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762603, url, valid)

proc call*(call_762604: Call_PostV3UsersIdEmails_762598; email: string; id: int): Recallable =
  ## postV3UsersIdEmails
  ## Add an email address to a specified user. Available only for admins.
  ##   email: string (required)
  ##        : The email of the user
  ##   id: int (required)
  ##     : The ID of the user
  var path_762605 = newJObject()
  var formData_762606 = newJObject()
  add(formData_762606, "email", newJString(email))
  add(path_762605, "id", newJInt(id))
  result = call_762604.call(path_762605, nil, nil, formData_762606, nil)

var postV3UsersIdEmails* = Call_PostV3UsersIdEmails_762598(
    name: "postV3UsersIdEmails", meth: HttpMethod.HttpPost, host: "gitlab.com",
    route: "/v3/users/{id}/emails", validator: validate_PostV3UsersIdEmails_762599,
    base: "/api", url: url_PostV3UsersIdEmails_762600, schemes: {Scheme.Https})
type
  Call_GetV3UsersIdEmails_762591 = ref object of OpenApiRestCall_758573
proc url_GetV3UsersIdEmails_762593(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/emails")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3UsersIdEmails_762592(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Get the emails addresses of a specified user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762594 = path.getOrDefault("id")
  valid_762594 = validateParameter(valid_762594, JInt, required = true, default = nil)
  if valid_762594 != nil:
    section.add "id", valid_762594
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762595: Call_GetV3UsersIdEmails_762591; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the emails addresses of a specified user. Available only for admins.
  ## 
  let valid = call_762595.validator(path, query, header, formData, body)
  let scheme = call_762595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762595.url(scheme.get, call_762595.host, call_762595.base,
                         call_762595.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762595, url, valid)

proc call*(call_762596: Call_GetV3UsersIdEmails_762591; id: int): Recallable =
  ## getV3UsersIdEmails
  ## Get the emails addresses of a specified user. Available only for admins.
  ##   id: int (required)
  ##     : The ID of the user
  var path_762597 = newJObject()
  add(path_762597, "id", newJInt(id))
  result = call_762596.call(path_762597, nil, nil, nil, nil)

var getV3UsersIdEmails* = Call_GetV3UsersIdEmails_762591(
    name: "getV3UsersIdEmails", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/users/{id}/emails", validator: validate_GetV3UsersIdEmails_762592,
    base: "/api", url: url_GetV3UsersIdEmails_762593, schemes: {Scheme.Https})
type
  Call_DeleteV3UsersIdEmailsEmailId_762607 = ref object of OpenApiRestCall_758573
proc url_DeleteV3UsersIdEmailsEmailId_762609(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "email_id" in path, "`email_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/emails/"),
               (kind: VariableSegment, value: "email_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3UsersIdEmailsEmailId_762608(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete an email address of a specified user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  ##   email_id: JInt (required)
  ##           : The ID of the email
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762610 = path.getOrDefault("id")
  valid_762610 = validateParameter(valid_762610, JInt, required = true, default = nil)
  if valid_762610 != nil:
    section.add "id", valid_762610
  var valid_762611 = path.getOrDefault("email_id")
  valid_762611 = validateParameter(valid_762611, JInt, required = true, default = nil)
  if valid_762611 != nil:
    section.add "email_id", valid_762611
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762612: Call_DeleteV3UsersIdEmailsEmailId_762607; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an email address of a specified user. Available only for admins.
  ## 
  let valid = call_762612.validator(path, query, header, formData, body)
  let scheme = call_762612.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762612.url(scheme.get, call_762612.host, call_762612.base,
                         call_762612.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762612, url, valid)

proc call*(call_762613: Call_DeleteV3UsersIdEmailsEmailId_762607; id: int;
          emailId: int): Recallable =
  ## deleteV3UsersIdEmailsEmailId
  ## Delete an email address of a specified user. Available only for admins.
  ##   id: int (required)
  ##     : The ID of the user
  ##   emailId: int (required)
  ##          : The ID of the email
  var path_762614 = newJObject()
  add(path_762614, "id", newJInt(id))
  add(path_762614, "email_id", newJInt(emailId))
  result = call_762613.call(path_762614, nil, nil, nil, nil)

var deleteV3UsersIdEmailsEmailId* = Call_DeleteV3UsersIdEmailsEmailId_762607(
    name: "deleteV3UsersIdEmailsEmailId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/users/{id}/emails/{email_id}",
    validator: validate_DeleteV3UsersIdEmailsEmailId_762608, base: "/api",
    url: url_DeleteV3UsersIdEmailsEmailId_762609, schemes: {Scheme.Https})
type
  Call_GetV3UsersIdEvents_762615 = ref object of OpenApiRestCall_758573
proc url_GetV3UsersIdEvents_762617(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3UsersIdEvents_762616(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.13.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762618 = path.getOrDefault("id")
  valid_762618 = validateParameter(valid_762618, JInt, required = true, default = nil)
  if valid_762618 != nil:
    section.add "id", valid_762618
  result.add "path", section
  ## parameters in `query` object:
  ##   per_page: JInt
  ##           : Number of items per page
  ##   page: JInt
  ##       : Current page number
  section = newJObject()
  var valid_762619 = query.getOrDefault("per_page")
  valid_762619 = validateParameter(valid_762619, JInt, required = false, default = nil)
  if valid_762619 != nil:
    section.add "per_page", valid_762619
  var valid_762620 = query.getOrDefault("page")
  valid_762620 = validateParameter(valid_762620, JInt, required = false, default = nil)
  if valid_762620 != nil:
    section.add "page", valid_762620
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762621: Call_GetV3UsersIdEvents_762615; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.13.
  ## 
  let valid = call_762621.validator(path, query, header, formData, body)
  let scheme = call_762621.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762621.url(scheme.get, call_762621.host, call_762621.base,
                         call_762621.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762621, url, valid)

proc call*(call_762622: Call_GetV3UsersIdEvents_762615; id: int; perPage: int = 0;
          page: int = 0): Recallable =
  ## getV3UsersIdEvents
  ## This feature was introduced in GitLab 8.13.
  ##   id: int (required)
  ##     : The ID of the user
  ##   perPage: int
  ##          : Number of items per page
  ##   page: int
  ##       : Current page number
  var path_762623 = newJObject()
  var query_762624 = newJObject()
  add(path_762623, "id", newJInt(id))
  add(query_762624, "per_page", newJInt(perPage))
  add(query_762624, "page", newJInt(page))
  result = call_762622.call(path_762623, query_762624, nil, nil, nil)

var getV3UsersIdEvents* = Call_GetV3UsersIdEvents_762615(
    name: "getV3UsersIdEvents", meth: HttpMethod.HttpGet, host: "gitlab.com",
    route: "/v3/users/{id}/events", validator: validate_GetV3UsersIdEvents_762616,
    base: "/api", url: url_GetV3UsersIdEvents_762617, schemes: {Scheme.Https})
type
  Call_PostV3UsersIdKeys_762632 = ref object of OpenApiRestCall_758573
proc url_PostV3UsersIdKeys_762634(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostV3UsersIdKeys_762633(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Add an SSH key to a specified user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762635 = path.getOrDefault("id")
  valid_762635 = validateParameter(valid_762635, JInt, required = true, default = nil)
  if valid_762635 != nil:
    section.add "id", valid_762635
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  ## parameters in `formData` object:
  ##   title: JString (required)
  ##        : The title of the new SSH key
  ##   key: JString (required)
  ##      : The new SSH key
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `title` field"
  var valid_762636 = formData.getOrDefault("title")
  valid_762636 = validateParameter(valid_762636, JString, required = true,
                                 default = nil)
  if valid_762636 != nil:
    section.add "title", valid_762636
  var valid_762637 = formData.getOrDefault("key")
  valid_762637 = validateParameter(valid_762637, JString, required = true,
                                 default = nil)
  if valid_762637 != nil:
    section.add "key", valid_762637
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762638: Call_PostV3UsersIdKeys_762632; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Add an SSH key to a specified user. Available only for admins.
  ## 
  let valid = call_762638.validator(path, query, header, formData, body)
  let scheme = call_762638.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762638.url(scheme.get, call_762638.host, call_762638.base,
                         call_762638.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762638, url, valid)

proc call*(call_762639: Call_PostV3UsersIdKeys_762632; title: string; id: int;
          key: string): Recallable =
  ## postV3UsersIdKeys
  ## Add an SSH key to a specified user. Available only for admins.
  ##   title: string (required)
  ##        : The title of the new SSH key
  ##   id: int (required)
  ##     : The ID of the user
  ##   key: string (required)
  ##      : The new SSH key
  var path_762640 = newJObject()
  var formData_762641 = newJObject()
  add(formData_762641, "title", newJString(title))
  add(path_762640, "id", newJInt(id))
  add(formData_762641, "key", newJString(key))
  result = call_762639.call(path_762640, nil, nil, formData_762641, nil)

var postV3UsersIdKeys* = Call_PostV3UsersIdKeys_762632(name: "postV3UsersIdKeys",
    meth: HttpMethod.HttpPost, host: "gitlab.com", route: "/v3/users/{id}/keys",
    validator: validate_PostV3UsersIdKeys_762633, base: "/api",
    url: url_PostV3UsersIdKeys_762634, schemes: {Scheme.Https})
type
  Call_GetV3UsersIdKeys_762625 = ref object of OpenApiRestCall_758573
proc url_GetV3UsersIdKeys_762627(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetV3UsersIdKeys_762626(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Get the SSH keys of a specified user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762628 = path.getOrDefault("id")
  valid_762628 = validateParameter(valid_762628, JInt, required = true, default = nil)
  if valid_762628 != nil:
    section.add "id", valid_762628
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762629: Call_GetV3UsersIdKeys_762625; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the SSH keys of a specified user. Available only for admins.
  ## 
  let valid = call_762629.validator(path, query, header, formData, body)
  let scheme = call_762629.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762629.url(scheme.get, call_762629.host, call_762629.base,
                         call_762629.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762629, url, valid)

proc call*(call_762630: Call_GetV3UsersIdKeys_762625; id: int): Recallable =
  ## getV3UsersIdKeys
  ## Get the SSH keys of a specified user. Available only for admins.
  ##   id: int (required)
  ##     : The ID of the user
  var path_762631 = newJObject()
  add(path_762631, "id", newJInt(id))
  result = call_762630.call(path_762631, nil, nil, nil, nil)

var getV3UsersIdKeys* = Call_GetV3UsersIdKeys_762625(name: "getV3UsersIdKeys",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/users/{id}/keys",
    validator: validate_GetV3UsersIdKeys_762626, base: "/api",
    url: url_GetV3UsersIdKeys_762627, schemes: {Scheme.Https})
type
  Call_DeleteV3UsersIdKeysKeyId_762642 = ref object of OpenApiRestCall_758573
proc url_DeleteV3UsersIdKeysKeyId_762644(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "key_id" in path, "`key_id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "key_id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteV3UsersIdKeysKeyId_762643(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete an existing SSH key from a specified user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  ##   key_id: JInt (required)
  ##         : The ID of the SSH key
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762645 = path.getOrDefault("id")
  valid_762645 = validateParameter(valid_762645, JInt, required = true, default = nil)
  if valid_762645 != nil:
    section.add "id", valid_762645
  var valid_762646 = path.getOrDefault("key_id")
  valid_762646 = validateParameter(valid_762646, JInt, required = true, default = nil)
  if valid_762646 != nil:
    section.add "key_id", valid_762646
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762647: Call_DeleteV3UsersIdKeysKeyId_762642; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an existing SSH key from a specified user. Available only for admins.
  ## 
  let valid = call_762647.validator(path, query, header, formData, body)
  let scheme = call_762647.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762647.url(scheme.get, call_762647.host, call_762647.base,
                         call_762647.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762647, url, valid)

proc call*(call_762648: Call_DeleteV3UsersIdKeysKeyId_762642; id: int; keyId: int): Recallable =
  ## deleteV3UsersIdKeysKeyId
  ## Delete an existing SSH key from a specified user. Available only for admins.
  ##   id: int (required)
  ##     : The ID of the user
  ##   keyId: int (required)
  ##        : The ID of the SSH key
  var path_762649 = newJObject()
  add(path_762649, "id", newJInt(id))
  add(path_762649, "key_id", newJInt(keyId))
  result = call_762648.call(path_762649, nil, nil, nil, nil)

var deleteV3UsersIdKeysKeyId* = Call_DeleteV3UsersIdKeysKeyId_762642(
    name: "deleteV3UsersIdKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "gitlab.com", route: "/v3/users/{id}/keys/{key_id}",
    validator: validate_DeleteV3UsersIdKeysKeyId_762643, base: "/api",
    url: url_DeleteV3UsersIdKeysKeyId_762644, schemes: {Scheme.Https})
type
  Call_PutV3UsersIdUnblock_762650 = ref object of OpenApiRestCall_758573
proc url_PutV3UsersIdUnblock_762652(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/v3/users/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/unblock")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutV3UsersIdUnblock_762651(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Unblock a user. Available only for admins.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The ID of the user
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_762653 = path.getOrDefault("id")
  valid_762653 = validateParameter(valid_762653, JInt, required = true, default = nil)
  if valid_762653 != nil:
    section.add "id", valid_762653
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762654: Call_PutV3UsersIdUnblock_762650; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unblock a user. Available only for admins.
  ## 
  let valid = call_762654.validator(path, query, header, formData, body)
  let scheme = call_762654.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762654.url(scheme.get, call_762654.host, call_762654.base,
                         call_762654.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762654, url, valid)

proc call*(call_762655: Call_PutV3UsersIdUnblock_762650; id: int): Recallable =
  ## putV3UsersIdUnblock
  ## Unblock a user. Available only for admins.
  ##   id: int (required)
  ##     : The ID of the user
  var path_762656 = newJObject()
  add(path_762656, "id", newJInt(id))
  result = call_762655.call(path_762656, nil, nil, nil, nil)

var putV3UsersIdUnblock* = Call_PutV3UsersIdUnblock_762650(
    name: "putV3UsersIdUnblock", meth: HttpMethod.HttpPut, host: "gitlab.com",
    route: "/v3/users/{id}/unblock", validator: validate_PutV3UsersIdUnblock_762651,
    base: "/api", url: url_PutV3UsersIdUnblock_762652, schemes: {Scheme.Https})
type
  Call_GetV3Version_762657 = ref object of OpenApiRestCall_758573
proc url_GetV3Version_762659(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV3Version_762658(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## This feature was introduced in GitLab 8.13.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_762660: Call_GetV3Version_762657; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This feature was introduced in GitLab 8.13.
  ## 
  let valid = call_762660.validator(path, query, header, formData, body)
  let scheme = call_762660.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_762660.url(scheme.get, call_762660.host, call_762660.base,
                         call_762660.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = newRecallable(call_762660, url, valid)

proc call*(call_762661: Call_GetV3Version_762657): Recallable =
  ## getV3Version
  ## This feature was introduced in GitLab 8.13.
  result = call_762661.call(nil, nil, nil, nil, nil)

var getV3Version* = Call_GetV3Version_762657(name: "getV3Version",
    meth: HttpMethod.HttpGet, host: "gitlab.com", route: "/v3/version",
    validator: validate_GetV3Version_762658, base: "/api", url: url_GetV3Version_762659,
    schemes: {Scheme.Https})
export
  rest
